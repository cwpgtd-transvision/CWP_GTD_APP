!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(e._Highcharts,e._Highcharts.SeriesRegistry):"function"==typeof define&&define.amd?define("highcharts/indicators/klinger",["highcharts/highcharts"],function(e){return t(e,e.SeriesRegistry)}):"object"==typeof exports?exports["highcharts/indicators/klinger"]=t(e._Highcharts,e._Highcharts.SeriesRegistry):e.Highcharts=t(e.Highcharts,e.Highcharts.SeriesRegistry)}("undefined"==typeof window?this:window,(O,V)=>(()=>{"use strict";var r={512:e=>{e.exports=V},944:e=>{e.exports=O}},i={};function o(e){var t=i[e];if(void 0!==t)return t.exports;t=i[e]={exports:{}};return r[e](t,t.exports,o),t.exports}o.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return o.d(t,{a:t}),t},o.d=(e,t)=>{for(var r in t)o.o(t,r)&&!o.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var e,t={},s=(o.d(t,{default:()=>C}),o(944)),s=o.n(s),a=o(512),a=o.n(a);const f=a().seriesTypes["sma"]["prototype"],{defined:y,error:m,merge:v}=s();{var n=e=e||{};const E=["bottomLine"],G=["top","bottom"],N=["top"];function A(e){return"plot"+e.charAt(0).toUpperCase()+e.slice(1)}function P(e,t){const r=[];return(e.pointArrayMap||[]).forEach(e=>{e!==t&&r.push(A(e))}),r}function l(){const r=this,e=r.pointValKey,t=r.linesApiNames,i=r.areaLinesNames,o=r.points,s=r.options,a=r.graph,n={options:{gapSize:s.gapSize}},l=[],p=P(r,e);let h=o.length,c;var g,u,d;p.forEach((e,t)=>{for(l[t]=[];h--;)c=o[h],l[t].push({x:c.x,plotX:c.plotX,plotY:c[e],isNull:!y(c[e])});h=o.length}),r.userOptions.fillColor&&i.length&&(g=p.indexOf(A(i[0])),g=l[g],u=1===i.length?o:l[p.indexOf(A(i[1]))],d=r.color,r.points=u,r.nextPoints=g,r.color=r.userOptions.fillColor,r.options=v(o,n),r.graph=r.area,r.fillGraph=!0,f.drawGraph.call(r),r.area=r.graph,delete r.nextPoints,delete r.fillGraph,r.color=d),t.forEach((e,t)=>{l[t]?(r.points=l[t],s[e]?r.options=v(s[e].styles,n):m('Error: "There is no '+e+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),r.graph=r["graph"+e],f.drawGraph.call(r),r["graph"+e]=r.graph):m('Error: "'+e+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),r.points=o,r.options=s,r.graph=a,f.drawGraph.call(r)}function p(e){let t,r=[],i;if(e=e||this.points,this.fillGraph&&this.nextPoints){if((t=f.getGraphPath.call(this,this.nextPoints))&&t.length){t[0][0]="L",r=f.getGraphPath.call(this,e);for(let e=(i=t.slice(0,r.length)).length-1;0<=e;e--)r.push(i[e])}}else r=f.getGraphPath.apply(this,arguments);return r}function h(t){const r=[];return(this.pointArrayMap||[]).forEach(e=>{r.push(t[e])}),r}function c(){const e=this.pointArrayMap;let i,o;i=P(this),f.translate.apply(this,arguments),this.points.forEach(r=>{e.forEach((e,t)=>{o=r[e],null!==(o=this.dataModify?this.dataModify.modifyValue(o):o)&&(r[i[t]]=this.yAxis.toPixels(o,!0))})})}e.compose=function(e){const t=e.prototype;return t.linesApiNames=t.linesApiNames||E.slice(),t.pointArrayMap=t.pointArrayMap||G.slice(),t.pointValKey=t.pointValKey||"top",t.areaLinesNames=t.areaLinesNames||N.slice(),t.drawGraph=l,t.getGraphPath=p,t.toYData=h,t.translate=c,e}}const g=e,{ema:u,sma:d}=a().seriesTypes,{correctFloat:x,error:M,extend:S,isArray:w,merge:b}=s();class D extends d{calculateTrend(e,t){return e[t][1]+e[t][2]+e[t][3]>e[t-1][1]+e[t-1][2]+e[t-1][3]?1:-1}isValidData(e){const t=this.chart,r=this.options,i=this.linkedParent,o=w(e)&&4===e.length,s=this.volumeSeries||(this.volumeSeries=t.get(r.params.volumeSeriesID));return s||M("Series "+r.params.volumeSeriesID+" not found! Check `volumeSeriesID`.",!0,i.chart),!(![i,s].every(function(e){return e&&e.dataTable.rowCount>=r.params.slowAvgPeriod})||!o)}getCM(e,t,r,i,o){return x(t+(r===i?e:o))}getDM(e,t){return x(e-t)}getVolumeForce(e){const t=[];let r,i,o,s=1,a=0,n=e[0][1]-e[0][2],l=0,p;for(s;s<e.length;s++)p=this.calculateTrend(e,s),i=this.getDM(e[s][1],e[s][2]),r=this.getCM(a,i,p,l,n),o=this.volumeSeries.getColumn("y")[s]*p*Math.abs(2*(i/r-1))*100,t.push([o]),l=p,a=r,n=i;return t}getEMA(e,t,r,i,o,s,a){return u.prototype.calculateEma(a||[],e,void 0===s?1:s,i,t,void 0===o?-1:o,r)}getSMA(e,t,r){return u.prototype.accumulatePeriodPoints(e,t,r)/e}getValues(e,t){const r=[],i=e.xData,o=e.yData,s=[],a=[],n=[];let l,p=0,h=0,c,g=void 0,u=void 0,d=null;if(this.isValidData(o[0])){var f=this.getVolumeForce(o),y=this.getSMA(t.fastAvgPeriod,0,f),m=this.getSMA(t.slowAvgPeriod,0,f),v=2/(t.fastAvgPeriod+1),A=2/(t.slowAvgPeriod+1);for(p;p<o.length;p++)p>=t.fastAvgPeriod&&(h=this.getEMA(f,g,y,v,0,p,i)[1],g=h),p>=t.slowAvgPeriod&&(c=this.getEMA(f,u,m,A,0,p,i)[1],u=c,l=x(h-c),n.push(l),n.length>=t.signalPeriod&&(d=n.slice(-t.signalPeriod).reduce((e,t)=>e+t)/t.signalPeriod),r.push([i[p],l,d]),s.push(i[p]),a.push([l,d]));return{values:r,xData:s,yData:a}}}}D.defaultOptions=b(d.defaultOptions,{params:{fastAvgPeriod:34,slowAvgPeriod:55,signalPeriod:13,volumeSeriesID:"volume"},signalLine:{styles:{lineWidth:1,lineColor:"#ff0000"}},dataGrouping:{approximation:"averages"},tooltip:{pointFormat:'<span style="color: {point.color}">‚óè</span><b> {series.name}</b><br/><span style="color: {point.color}">Klinger</span>: {point.y}<br/><span style="color: {point.series.options.signalLine.styles.lineColor}">Signal</span>: {point.signal}<br/>'}}),S(D.prototype,{areaLinesNames:[],linesApiNames:["signalLine"],nameBase:"Klinger",nameComponents:["fastAvgPeriod","slowAvgPeriod"],pointArrayMap:["y","signal"],parallelArrays:["x","y","signal"],pointValKey:"y"}),g.compose(D),a().registerSeriesType("klinger",D);const C=s();return t.default})());