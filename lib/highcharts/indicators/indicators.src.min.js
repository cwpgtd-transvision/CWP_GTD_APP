!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(t._Highcharts,t._Highcharts.Chart,t._Highcharts.SeriesRegistry):"function"==typeof define&&define.amd?define("highcharts/indicators/indicators",["highcharts/highcharts"],function(t){return e(t,t.Chart,t.SeriesRegistry)}):"object"==typeof exports?exports["highcharts/indicators/indicators"]=e(t._Highcharts,t._Highcharts.Chart,t._Highcharts.SeriesRegistry):t.Highcharts=e(t.Highcharts,t.Highcharts.Chart,t.Highcharts.SeriesRegistry)}("undefined"==typeof window?this:window,(L,_,j)=>(()=>{"use strict";var a={512:t=>{t.exports=j},944:t=>{t.exports=L},960:t=>{t.exports=_}},n={};function i(t){var e=n[t];if(void 0!==e)return e.exports;e=n[t]={exports:{}};return a[t](e,e.exports,i),e.exports}i.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return i.d(e,{a:e}),e},i.d=(t,e)=>{for(var a in e)i.o(e,a)&&!i.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:e[a]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var t={},e=(i.d(t,{default:()=>U}),i(944)),e=i.n(e),r=i(960),s=i.n(r),r=i(512),r=i.n(r),o=r().seriesTypes["line"];const{addEvent:l,fireEvent:D,error:p,extend:h,isArray:v,merge:c,pick:d}=e(),P=(e,a)=>{const t=[],n=e.pointArrayMap,i=a&&e.dataTable.modified||e.dataTable;if(!n)return e.getColumn("y",a);const r=n.map(t=>e.getColumn(t,a));for(let a=0;a<i.rowCount;a++){var s=n.map((t,e)=>r[e]?.[a]||0);t.push(s)}return t};class u extends o{destroy(){this.dataEventsToUnbind.forEach(function(t){t()}),super.destroy.apply(this,arguments)}getName(){const a=[];let t=this.name;return t||((this.nameComponents||[]).forEach(function(t,e){a.push(this.options.params[t]+d(this.nameSuffixes[e],""))},this),t=(this.nameBase||this.type.toUpperCase())+(this.nameComponents?" ("+a.join(", ")+")":"")),t}getValues(t,e){const a=e.period,n=t.xData||[],i=t.yData,r=i.length,s=[],o=[],l=[];let p,h=-1,c=0,d,u=0;if(!(n.length<a)){for(v(i[0])&&(h=e.index||0);c<a-1;)u+=h<0?i[c]:i[c][h],c++;for(p=c;p<r;p++)u+=h<0?i[p]:i[p][h],d=[n[p],u/a],s.push(d),o.push(d[0]),l.push(d[1]),u-=h<0?i[p-c]:i[p-c][h];return{values:s,xData:o,yData:l}}}init(a,t){const n=this;super.init.call(n,a,t);t=l(s(),"afterLinkSeries",function({isUpdating:t}){if(!t){t=!!n.dataEventsToUnbind.length;if(!n.linkedParent)return p("Series "+n.options.linkedTo+" not found! Check `linkedTo`.",!1,a);if(t||(n.dataEventsToUnbind.push(l(n.linkedParent,"updatedData",function(){n.recalculateValues()})),n.calculateOn.xAxis&&n.dataEventsToUnbind.push(l(n.linkedParent.xAxis,n.calculateOn.xAxis,function(){n.recalculateValues()}))),"init"===n.calculateOn.chart)n.closestPointRange||n.recalculateValues();else if(!t){const e=l(n.chart,n.calculateOn.chart,function(){n.recalculateValues(),e()})}}},{order:0});n.dataEventsToUnbind=[],n.eventsToUnbind.push(t)}recalculateValues(){const t=[],e=this,a=this.dataTable,n=e.points||[],i=e.dataTable.rowCount,r={values:[],xData:[],yData:[]};let s=!0,o,l,p,h;var c=e.linkedParent.yData,d=e.linkedParent.processedYData;e.linkedParent.xData=e.linkedParent.getColumn("x"),e.linkedParent.yData=P(e.linkedParent),e.linkedParent.processedYData=P(e.linkedParent,!0);const u=e.linkedParent.options&&e.linkedParent.dataTable.rowCount&&e.getValues(e.linkedParent,e.options.params)||r,f=(delete e.linkedParent.xData,e.linkedParent.yData=c,e.linkedParent.processedYData=d,e.pointArrayMap||["y"]),m={};if(u.yData.forEach(n=>{f.forEach((t,e)=>{const a=m[t]||[];a.push(v(n)?n[e]:n),m[t]||(m[t]=a)})}),i&&!e.hasGroupedData&&e.visible&&e.points)if(e.cropped){e.xAxis&&(p=e.xAxis.min,h=e.xAxis.max);var g=e.cropData(a,p,h);const x=["x",...e.pointArrayMap||["y"]];for(let e=0;e<(g.modified?.rowCount||0);e++){var y=x.map(t=>this.getColumn(t)[e]||0);t.push(y)}c=e.getColumn("x");o=u.xData.indexOf(c[0]),l=u.xData.indexOf(c[c.length-1]),-1===o&&l===u.xData.length-2&&t[0][0]===n[0].x&&t.shift(),e.updateData(t)}else(e.updateAllPoints||u.xData.length!==i-1&&u.xData.length!==i+1)&&(s=!1,e.updateData(u.values));s&&(a.setColumns({...m,x:u.xData}),e.options.data=u.values),e.calculateOn.xAxis&&e.getColumn("x",!0).length&&(e.isDirty=!0,e.redraw()),e.isDirtyData=!!e.linkedSeries.length,D(e,"updatedData")}processData(){var t=this,e=t.options.compareToMain,a=t.linkedParent;super.processData.apply(t,arguments),t.dataModify&&a&&a.dataModify&&a.dataModify.compareValue&&e&&(t.dataModify.compareValue=a.dataModify.compareValue)}}u.defaultOptions=c(o.defaultOptions,{name:void 0,tooltip:{valueDecimals:4},linkedTo:void 0,compareToMain:!1,params:{index:3,period:14}}),h(u.prototype,{calculateOn:{chart:"init"},hasDerivedData:!0,nameComponents:["period"],nameSuffixes:[],useCommonDataGrouping:!0}),r().registerSeriesType("sma",u);o=r().seriesTypes.sma;const{correctFloat:f,isArray:m,merge:g}=e();class y extends o{accumulatePeriodPoints(t,e,a){let n=0,i=0,r;for(;i<t;)r=e<0?a[i]:a[i][e],n+=r,i++;return n}calculateEma(t,e,a,n,i,r,s){t=t[a-1],e=r<0?e[a-1]:e[a-1][r];return[t,void 0===i?s:f(e*n+i*(1-n))]}getValues(t,e){const a=e.period,n=t.xData,i=t.yData,r=i?i.length:0,s=2/(a+1),o=[],l=[],p=[];let h,c,d,u=-1,f;if(!(r<a)){for(m(i[0])&&(u=e.index||0),f=this.accumulatePeriodPoints(a,u,i)/a,d=a;d<r+1;d++)c=this.calculateEma(n,i,d,s,h,u,f),o.push(c),l.push(c[0]),p.push(c[1]),h=c[1];return{values:o,xData:l,yData:p}}}}y.defaultOptions=g(o.defaultOptions,{params:{index:3,period:9}}),r().registerSeriesType("ema",y);var x;const C=r().seriesTypes["sma"]["prototype"],{defined:A,error:k,merge:T}=e();{o=x=x||{};const G=["bottomLine"],H=["top","bottom"],N=["top"];function M(t){return"plot"+t.charAt(0).toUpperCase()+t.slice(1)}function E(t,e){const a=[];return(t.pointArrayMap||[]).forEach(t=>{t!==e&&a.push(M(t))}),a}function O(){const a=this,t=a.pointValKey,e=a.linesApiNames,n=a.areaLinesNames,i=a.points,r=a.options,s=a.graph,o={options:{gapSize:r.gapSize}},l=[],p=E(a,t);let h=i.length,c;var d,u,f;p.forEach((t,e)=>{for(l[e]=[];h--;)c=i[h],l[e].push({x:c.x,plotX:c.plotX,plotY:c[t],isNull:!A(c[t])});h=i.length}),a.userOptions.fillColor&&n.length&&(d=p.indexOf(M(n[0])),d=l[d],u=1===n.length?i:l[p.indexOf(M(n[1]))],f=a.color,a.points=u,a.nextPoints=d,a.color=a.userOptions.fillColor,a.options=T(i,o),a.graph=a.area,a.fillGraph=!0,C.drawGraph.call(a),a.area=a.graph,delete a.nextPoints,delete a.fillGraph,a.color=f),e.forEach((t,e)=>{l[e]?(a.points=l[e],r[t]?a.options=T(r[t].styles,o):k('Error: "There is no '+t+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),a.graph=a["graph"+t],C.drawGraph.call(a),a["graph"+t]=a.graph):k('Error: "'+t+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),a.points=i,a.options=r,a.graph=s,C.drawGraph.call(a)}function b(t){let e,a=[],n;if(t=t||this.points,this.fillGraph&&this.nextPoints){if((e=C.getGraphPath.call(this,this.nextPoints))&&e.length){e[0][0]="L",a=C.getGraphPath.call(this,t);for(let t=(n=e.slice(0,a.length)).length-1;0<=t;t--)a.push(n[t])}}else a=C.getGraphPath.apply(this,arguments);return a}function w(e){const a=[];return(this.pointArrayMap||[]).forEach(t=>{a.push(e[t])}),a}function S(){const t=this.pointArrayMap;let n,i;n=E(this),C.translate.apply(this,arguments),this.points.forEach(a=>{t.forEach((t,e)=>{i=a[t],null!==(i=this.dataModify?this.dataModify.modifyValue(i):i)&&(a[n[e]]=this.yAxis.toPixels(i,!0))})})}o.compose=function(t){const e=t.prototype;return e.linesApiNames=e.linesApiNames||G.slice(),e.pointArrayMap=e.pointArrayMap||H.slice(),e.pointValKey=e.pointValKey||"top",e.areaLinesNames=e.areaLinesNames||N.slice(),e.drawGraph=O,e.getGraphPath=b,e.toYData=w,e.translate=S,t}}r=x;const V=e(),U=(V.MultipleLinesComposition=V.MultipleLinesComposition||r,e());return t.default})());