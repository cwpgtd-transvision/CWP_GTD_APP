!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(t._Highcharts,t._Highcharts.SeriesRegistry):"function"==typeof define&&define.amd?define("highcharts/indicators/dmi",["highcharts/highcharts"],function(t){return e(t,t.SeriesRegistry)}):"object"==typeof exports?exports["highcharts/indicators/dmi"]=e(t._Highcharts,t._Highcharts.SeriesRegistry):t.Highcharts=e(t.Highcharts,t.Highcharts.SeriesRegistry)}("undefined"==typeof window?this:window,(O,P)=>(()=>{"use strict";var s={512:t=>{t.exports=P},944:t=>{t.exports=O}},a={};function i(t){var e=a[t];if(void 0!==e)return e.exports;e=a[t]={exports:{}};return s[t](e,e.exports,i),e.exports}i.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return i.d(e,{a:e}),e},i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var t,e={},r=(i.d(e,{default:()=>v}),i(944)),r=i.n(r),o=i(512),o=i.n(o);const f=o().seriesTypes["sma"]["prototype"],{defined:g,error:m,merge:D}=r();{var n=t=t||{};const G=["bottomLine"],L=["top","bottom"],N=["top"];function x(t){return"plot"+t.charAt(0).toUpperCase()+t.slice(1)}function M(t,e){const s=[];return(t.pointArrayMap||[]).forEach(t=>{t!==e&&s.push(x(t))}),s}function l(){const s=this,t=s.pointValKey,e=s.linesApiNames,a=s.areaLinesNames,i=s.points,r=s.options,o=s.graph,n={options:{gapSize:r.gapSize}},l=[],p=M(s,t);let h=i.length,c;var u,y,d;p.forEach((t,e)=>{for(l[e]=[];h--;)c=i[h],l[e].push({x:c.x,plotX:c.plotX,plotY:c[t],isNull:!g(c[t])});h=i.length}),s.userOptions.fillColor&&a.length&&(u=p.indexOf(x(a[0])),u=l[u],y=1===a.length?i:l[p.indexOf(x(a[1]))],d=s.color,s.points=y,s.nextPoints=u,s.color=s.userOptions.fillColor,s.options=D(i,n),s.graph=s.area,s.fillGraph=!0,f.drawGraph.call(s),s.area=s.graph,delete s.nextPoints,delete s.fillGraph,s.color=d),e.forEach((t,e)=>{l[e]?(s.points=l[e],r[t]?s.options=D(r[t].styles,n):m('Error: "There is no '+t+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),s.graph=s["graph"+t],f.drawGraph.call(s),s["graph"+t]=s.graph):m('Error: "'+t+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),s.points=i,s.options=r,s.graph=o,f.drawGraph.call(s)}function p(t){let e,s=[],a;if(t=t||this.points,this.fillGraph&&this.nextPoints){if((e=f.getGraphPath.call(this,this.nextPoints))&&e.length){e[0][0]="L",s=f.getGraphPath.call(this,t);for(let t=(a=e.slice(0,s.length)).length-1;0<=t;t--)s.push(a[t])}}else s=f.getGraphPath.apply(this,arguments);return s}function h(e){const s=[];return(this.pointArrayMap||[]).forEach(t=>{s.push(e[t])}),s}function c(){const t=this.pointArrayMap;let a,i;a=M(this),f.translate.apply(this,arguments),this.points.forEach(s=>{t.forEach((t,e)=>{i=s[t],null!==(i=this.dataModify?this.dataModify.modifyValue(i):i)&&(s[a[e]]=this.yAxis.toPixels(i,!0))})})}n.compose=function(t){const e=t.prototype;return e.linesApiNames=e.linesApiNames||G.slice(),e.pointArrayMap=e.pointArrayMap||L.slice(),e.pointValKey=e.pointValKey||"top",e.areaLinesNames=e.areaLinesNames||N.slice(),e.drawGraph=l,e.getGraphPath=p,e.toYData=h,e.translate=c,t}}const u=t;n=o().seriesTypes.sma;const{correctFloat:y,extend:d,isArray:b,merge:I}=r();class A extends n{calculateDM(t,e,s){var a=t[e][1],i=t[e][2],r=t[e-1][1],t=t[e-1][2];let o;return o=t-i<a-r?s?Math.max(a-r,0):0:s?0:Math.max(t-i,0),y(o)}calculateDI(t,e){return t/e*100}calculateDX(t,e){return y(Math.abs(t-e)/Math.abs(t+e)*100)}smoothValues(t,e,s){return y(t-t/s+e)}getTR(t,e){return y(Math.max(t[1]-t[2],e?Math.abs(t[1]-e[3]):0,e?Math.abs(t[2]-e[3]):0))}getValues(t,e){const y=e.period,d=t.xData,f=t.yData,s=f?f.length:0,g=[],m=[],D=[];if(!(d.length<=y)&&b(f[0])&&4===f[0].length){let p=0,h=0,c=0,u;for(u=1;u<s;u++){let t,e,s,a,i,r,o,n,l;u<=y?(a=this.calculateDM(f,u,!0),i=this.calculateDM(f,u),r=this.getTR(f[u],f[u-1]),p+=a,h+=i,c+=r,u===y&&(o=this.calculateDI(p,c),n=this.calculateDI(h,c),l=this.calculateDX(p,h),g.push([d[u],l,o,n]),m.push(d[u]),D.push([l,o,n]))):(a=this.calculateDM(f,u,!0),i=this.calculateDM(f,u),r=this.getTR(f[u],f[u-1]),t=this.smoothValues(p,a,y),e=this.smoothValues(h,i,y),s=this.smoothValues(c,r,y),p=t,h=e,c=s,o=this.calculateDI(p,c),n=this.calculateDI(h,c),l=this.calculateDX(p,h),g.push([d[u],l,o,n]),m.push(d[u]),D.push([l,o,n]))}return{values:g,xData:m,yData:D}}}}A.defaultOptions=I(n.defaultOptions,{params:{index:void 0},marker:{enabled:!1},tooltip:{pointFormat:'<span style="color: {point.color}">‚óè</span><b> {series.name}</b><br/><span style="color: {point.color}">DX</span>: {point.y}<br/><span style="color: {point.series.options.plusDILine.styles.lineColor}">+DI</span>: {point.plusDI}<br/><span style="color: {point.series.options.minusDILine.styles.lineColor}">-DI</span>: {point.minusDI}<br/>'},plusDILine:{styles:{lineWidth:1,lineColor:"#06b535"}},minusDILine:{styles:{lineWidth:1,lineColor:"#f21313"}},dataGrouping:{approximation:"averages"}}),d(A.prototype,{areaLinesNames:[],nameBase:"DMI",linesApiNames:["plusDILine","minusDILine"],pointArrayMap:["y","plusDI","minusDI"],parallelArrays:["x","y","plusDI","minusDI"],pointValKey:"y"}),u.compose(A),o().registerSeriesType("dmi",A);const v=r();return e.default})());