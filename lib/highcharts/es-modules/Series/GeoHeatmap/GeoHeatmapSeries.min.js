"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const{animObject,stop}=A;import GeoHeatmapPoint from"./GeoHeatmapPoint.js";import H from"../../Core/Globals.js";const noop=H["noop"];import IU from"../InterpolationUtilities.js";const{colorFromPoint,getContext}=IU;import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{map:MapSeries}=SeriesRegistry["seriesTypes"];import U from"../../Core/Utilities.js";const{addEvent,error,extend,isNumber,isObject,merge,pick}=U;function normalizeLonValue(t){return t-360*Math.floor((t+180)/360)}function scaledPointPos(t,e,o,i,a,r){return Math.ceil(o*(i-1-(e+90)/r)+(t+180)/a)}class GeoHeatmapSeries extends MapSeries{constructor(){super(...arguments),this.isDirtyCanvas=!0}update(){var t=this;t.options=merge(t.options,arguments[0]),t.getInterpolation().enabled&&(t.isDirtyCanvas=!0,t.points.forEach(t=>{t.graphic&&(t.graphic.destroy(),delete t.graphic)})),super.update.apply(t,arguments)}translate(){this.getInterpolation().enabled&&this.image&&!this.isDirty&&!this.isDirtyData||super.translate.apply(this,arguments)}getInterpolation(){return isObject(this.options.interpolation)?this.options.interpolation:{blur:1,enabled:this.options.interpolation}}drawPoints(){const t=this,e=t.chart,o=e.mapView,i=t.options;if(t.getInterpolation().enabled&&o&&t.bounds){const m=t.context||getContext(t),{canvas:c,colorAxis:k,image:g,chart:e,points:u}=t,[y,b]=[pick(i.colsize,1),pick(i.rowsize,1)],f=o.projectedUnitsToPixels({x:t.bounds.x1,y:t.bounds.y2}),x=o.projectedUnitsToPixels({x:t.bounds.x2,y:t.bounds.y1});if(c&&m&&k&&f&&x){const{x:D,y:w}=f,v=x.x-D,C=x.y-w,P={x:D,y:w,width:v,height:C};if(t.isDirtyCanvas||t.isDirtyData||"Orthographic"===o.projection.options.name){const j=c.width=1+~~(360/y),S=c.height=1+~~(180/b),O=j*S,I=new Uint8ClampedArray(4*O),{lat:R=0,lon:N=0}=u[0].options,U=N%b!=0,L=R%y!=0,V=U?t=>Math.round(t/b)*b:t=>t,F=L?t=>Math.round(t/y)*y:t=>t,X=u.length;(U||L)&&error("Highcharts Warning: For best performance, lon/lat datapoints should spaced by a single colsize/rowsize",!1,t.chart,{colsize:String(y),rowsize:String(b)}),t.directTouch=!1,t.isDirtyCanvas=!0;for(let t=0;t<X;t++){var a=u[t],{lon:r,lat:n}=a.options;isNumber(r)&&isNumber(n)&&I.set(colorFromPoint(a.value,a),4*scaledPointPos(V(r),F(n),j,S,y,b))}var s=t.getInterpolation().blur,s=0===s?1:11*s,p=~~(j*s),s=~~(S*s),l=~~v,h=~~C,d=new ImageData(I,j,S),d=(c.width=p,c.height=s,m.putImageData(d,0,0),m.globalCompositeOperation="copy",m.drawImage(c,0,0,d.width,d.height,0,0,p,s),this.getProjectedImageData(o,l,h,m.getImageData(0,0,p,s),c,D,w));c.width=l,c.height=h,m.putImageData(new ImageData(d,l,h),0,0)}if(g)if(e.renderer.globalAnimation&&e.hasRendered){const z=Number(g.attr("x")),A=Number(g.attr("y")),H=Number(g.attr("width")),T=Number(g.attr("height")),G=merge(animObject(e.renderer.globalAnimation)),M=G.step;G.step=function(){M&&M.apply(this,arguments),((t,e)=>{e=e.pos;g.attr({x:z+(D-z)*e,y:A+(w-A)*e,width:H+(v-H)*e,height:T+(C-T)*e})}).apply(this,arguments)},g.attr(merge({animator:0},t.isDirtyCanvas?{href:c.toDataURL("image/png",1)}:void 0)).animate({animator:1},G)}else stop(g),g.attr(merge(P,t.isDirtyCanvas?{href:c.toDataURL("image/png",1)}:void 0));else t.image=e.renderer.image(c.toDataURL("image/png",1)).attr(P).add(t.group);t.isDirtyCanvas=!1}}else super.drawPoints.apply(t,arguments)}getProjectedImageData(e,o,t,i,a,r,n){const s=new Uint8ClampedArray(o*t*4),p=pick(e.projection.options.rotation?.[0],0),l=a.width/360,h=-1*a.height/180;let d=-1;for(let t=0;t<s.length;t+=4){var m,c=t/4%o;0==c&&d++;const g=e.pixelsToLonLat({x:r+c,y:n+d});g&&(g.lon>-180-p&&g.lon<180-p&&(g.lon=normalizeLonValue(g.lon)),m=(c=[g.lon,g.lat])[0]*l+a.width/2,c=c[1]*h+a.height/2,0<=m&&m<=a.width&&0<=c&&c<=a.height&&(c=Math.floor(c)*a.width*4+4*Math.round(m),s[t]=i.data[c],s[t+1]=i.data[1+c],s[t+2]=i.data[2+c],s[t+3]=i.data[3+c]))}return s}searchPoint(t,e){const o=this,i=this.chart,a=i.mapView;if(a&&o.bounds&&o.image&&i.tooltip&&i.tooltip.options.enabled)if(!i.pointer.hasDragged&&(+o.image.attr("animator")<=.01||.99<=+o.image.attr("animator"))){var r=a.projectedUnitsToPixels({x:o.bounds.x1,y:o.bounds.y2}),n=a.projectedUnitsToPixels({x:o.bounds.x2,y:o.bounds.y1});if(i.pointer.normalize(t),t.lon&&t.lat&&r&&n&&t.chartX-i.plotLeft>r.x&&t.chartX-i.plotLeft<n.x&&t.chartY-i.plotTop>r.y&&t.chartY-i.plotTop<n.y)return this.searchKDTree({clientX:t.chartX,lon:normalizeLonValue(t.lon),lat:t.lat},e,t)}else i.tooltip.destroy()}}GeoHeatmapSeries.defaultOptions=merge(MapSeries.defaultOptions,{nullColor:"transparent",tooltip:{pointFormat:"Lat: {point.lat}, Lon: {point.lon}, Value: {point.value}<br/>"},borderWidth:0,colsize:1,rowsize:1,stickyTracking:!0,interpolation:{enabled:!1,blur:1}}),addEvent(GeoHeatmapSeries,"afterDataClassLegendClick",function(){this.isDirtyCanvas=!0,this.drawPoints()}),extend(GeoHeatmapSeries.prototype,{type:"geoheatmap",applyJitter:noop,pointClass:GeoHeatmapPoint,pointArrayMap:["lon","lat","value"],kdAxisArray:["lon","lat"]}),SeriesRegistry.registerSeriesType("geoheatmap",GeoHeatmapSeries);export default GeoHeatmapSeries;