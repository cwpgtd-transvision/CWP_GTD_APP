"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import Color from"../../Core/Color/Color.js";const color=Color["parse"];import ColumnSeriesDefaults from"./ColumnSeriesDefaults.js";import H from"../../Core/Globals.js";const noop=H["noop"];import Series from"../../Core/Series/Series.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";import U from"../../Core/Utilities.js";const{clamp,crisp,defined,extend,fireEvent,isArray,isNumber,merge,pick,objectEach}=U;class ColumnSeries extends Series{animate(t){const o=this,e=this.yAxis,s=e.pos,i=e.reversed,r=o.options,{clipOffset:n,inverted:a}=this.chart,l={},p=a?"translateX":"translateY";let c,h;t&&n?(l.scaleY=.001,h=clamp(e.toPixels(r.threshold||0),s,s+e.len),a?(h+=i?-Math.floor(n[0]):Math.ceil(n[2]),l.translateX=h-e.len):(h+=i?Math.ceil(n[0]):-Math.floor(n[2]),l.translateY=h),o.clipBox&&o.setClip(),o.group.attr(l)):(c=Number(o.group.attr(p)),o.group.animate({scaleY:1},extend(animObject(o.options.animation),{step:function(t,e){o.group&&(l[p]=c+e.pos*(s-c),o.group.attr(l))}})))}init(t,e){super.init.apply(this,arguments);const o=this;(t=o.chart).hasRendered&&t.series.forEach(function(t){t.type===o.type&&(t.isDirty=!0)})}getColumnMetrics(){const i=this,t=i.options,e=i.xAxis,r=i.yAxis,o=e.options.reversedStacks,s=e.reversed&&!o||!e.reversed&&o,n={};let a,l=0;!1===t.grouping?l=1:i.chart.series.forEach(function(t){var e=t.yAxis,o=t.options;let s;t.type===i.type&&t.reserveSpace()&&r.len===e.len&&r.pos===e.pos&&(o.stacking&&"group"!==o.stacking?(a=t.stackKey,void 0===n[a]&&(n[a]=l++),s=n[a]):!1!==o.grouping&&(s=l++),t.columnIndex=s)});var p=Math.min(Math.abs(e.transA)*(!e.brokenAxis?.hasBreaks&&e.ordinal?.slope||t.pointRange||e.closestPointRange||e.tickInterval||1),e.len),c=p*t.groupPadding,h=(p-2*c)/(l||1),d=Math.min(t.maxPointWidth||e.len,pick(t.pointWidth,h*(1-2*t.pointPadding))),u=(i.columnIndex||0)+(s?1:0);return i.columnMetrics={width:d,offset:(h-d)/2+(c+u*h-p/2)*(s?-1:1),paddedWidth:h,columnCount:l},i.columnMetrics}crispCol(t,e,o,s){var i=this.borderWidth,r=this.chart.inverted;return s=crisp(e+s,i,r)-(e=crisp(e,i,r)),this.options.crisp&&(o=crisp(t+o,i)-(t=crisp(t,i))),{x:t,y:e,width:o,height:s}}adjustForMissingColumns(t,e,a,o){if(!a.isNull&&1<o.columnCount){const l=this.xAxis.series.filter(t=>t.visible).map(t=>t.index);let r=0,n=0;objectEach(this.xAxis.stacking?.stacks,t=>{const e="number"==typeof a.x?t[a.x.toString()]?.points:void 0,o=e?.[this.index],s={};if(e&&isArray(o)){let o=this.index;const i=Object.keys(e).filter(t=>!t.match(",")&&e[t]&&1<e[t].length).map(parseFloat).filter(t=>-1!==l.indexOf(t)).filter(t=>{var e=this.chart.series[t].options,e=e.stacking&&e.stack;if(defined(e)){if(isNumber(s[e]))return o===t&&(o=s[e]),!1;s[e]=t}return!0}).sort((t,e)=>e-t);r=i.indexOf(o),n=i.length}}),r=this.xAxis.reversed?n-1-r:r;var s=(n-1)*o.paddedWidth+e;t=(a.plotX||0)+s/2-e-r*o.paddedWidth}return t}translate(){const c=this,h=c.chart,d=c.options,t=c.dense=c.closestPointRange*c.xAxis.transA<2,e=c.borderWidth=pick(d.borderWidth,t?0:1),u=c.xAxis,m=c.yAxis,g=d.threshold,f=pick(d.minPointLength,5),y=c.getColumnMetrics(),b=y.width,x=c.pointXOffset=y.offset,v=c.dataMin,C=c.dataMax,S=c.translatedThreshold=m.getThreshold(g);let k=c.barW=Math.max(b,1+2*e);d.pointPadding&&d.crisp&&(k=Math.ceil(k)),Series.prototype.translate.apply(c),c.points.forEach(function(t){var e=pick(t.yBottom,S),o=999+Math.abs(e),s=t.plotX||0,o=clamp(t.plotY,-o,m.len+o);let i,r=Math.min(o,e),n=Math.max(o,e)-r,a=b,l=s+x,p=k;f&&Math.abs(n)<f&&(n=f,i=!m.reversed&&!t.negative||m.reversed&&t.negative,isNumber(g)&&isNumber(C)&&t.y===g&&C<=g&&(m.min||0)<g&&(v!==C||(m.max||0)<=g)&&(i=!i,t.negative=!t.negative),r=Math.abs(r-S)>f?e-f:S-(i?f:0)),defined(t.options.pointWidth)&&(a=p=Math.ceil(t.options.pointWidth),l-=Math.round((a-b)/2)),d.centerInCategory&&(l=c.adjustForMissingColumns(l,a,t,y)),t.barX=l,t.pointWidth=a,t.tooltipPos=h.inverted?[clamp(m.len+m.pos-h.plotLeft-o,m.pos-h.plotLeft,m.len+m.pos-h.plotLeft),u.len+u.pos-h.plotTop-l-p/2,n]:[u.left-h.plotLeft+l+p/2,clamp(o+m.pos-h.plotTop,m.pos-h.plotTop,m.len+m.pos-h.plotTop),n],t.shapeType=c.pointClass.prototype.shapeType||"roundedRect",t.shapeArgs=c.crispCol(l,r,p,t.isNull?0:n)}),fireEvent(this,"afterColumnTranslate")}drawGraph(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")}pointAttribs(t,e){var o=this.options,s=this.pointAttrToOptions||{},i=s.stroke||"borderColor",s=s["stroke-width"]||"borderWidth";let r,n,a,l=t&&t.color||this.color,p=t&&t[i]||o[i]||l,c=t&&t.options.dashStyle||o.dashStyle,h=t&&t[s]||o[s]||this[s]||0,d=t?.isNull&&o.nullInteraction?0:t?.opacity??o.opacity??1;t&&this.zones.length&&(n=t.getZone(),l=t.options.color||n&&(n.color||t.nonZonedColor)||this.color,n&&(p=n.borderColor||p,c=n.dashStyle||c,h=n.borderWidth||h)),e&&t&&(a=(r=merge(o.states[e],t.options.states&&t.options.states[e]||{})).brightness,l=r.color||void 0!==a&&color(l).brighten(r.brightness).get()||l,p=r[i]||p,h=r[s]||h,c=r.dashStyle||c,d=pick(r.opacity,d));const u={fill:l,stroke:p,"stroke-width":h,opacity:d};return c&&(u.dashstyle=c),u}drawPoints(t=this.points){const r=this,n=this.chart,a=r.options,l=a.nullInteraction,p=n.renderer,c=a.animationLimit||250;let h;t.forEach(function(t){var e=t.plotY;let o=t.graphic,s=!!o,i=o&&n.pointCount<c?"animate":"attr";isNumber(e)&&(null!==t.y||l)?(h=t.shapeArgs,o&&t.hasNewShapeType()&&(o=o.destroy()),r.enabledDataSorting&&(t.startXPos=r.xAxis.reversed?-(h&&h.width||0):r.xAxis.width),o||(t.graphic=o=p[t.shapeType](h).add(t.group||r.group),o&&r.enabledDataSorting&&n.hasRendered&&n.pointCount<c&&(o.attr({x:t.startXPos}),s=!0,i="animate")),o&&s&&o[i](merge(h)),n.styledMode||o[i](r.pointAttribs(t,t.selected&&"select")).shadow(!1!==t.allowShadow&&a.shadow),o&&(o.addClass(t.getClassName(),!0),o.attr({visibility:t.visible?"inherit":"hidden"}))):o&&(t.graphic=o.destroy())})}drawTracker(t=this.points){function e(t){i?.normalize(t);const e=i?.getPointFromEvent(t);i&&e&&o.options.enableMouseTracking&&(s.isInsidePlot(t.chartX-s.plotLeft,t.chartY-s.plotTop,{visiblePlotOnly:!0})||i?.inClass(t.target,"highcharts-data-label"))&&(i.isDirectTouch=!0,e.onMouseOver(t))}const o=this,s=o.chart,i=s.pointer;let r;t.forEach(function(e){r=isArray(e.dataLabels)?e.dataLabels:e.dataLabel?[e.dataLabel]:[],e.graphic&&(e.graphic.element.point=e),r.forEach(function(t){(t.div||t.element).point=e})}),o._hasTracking||(o.trackerGroups.forEach(function(t){o[t]&&(o[t].addClass("highcharts-tracker").on("mouseover",e).on("mouseout",function(t){i?.onTrackerMouseOut(t)}).on("touchstart",e),!s.styledMode&&o.options.cursor&&o[t].css({cursor:o.options.cursor}))}),o._hasTracking=!0),fireEvent(this,"afterDrawTracker")}remove(){const e=this,t=e.chart;t.hasRendered&&t.series.forEach(function(t){t.type===e.type&&(t.isDirty=!0)}),Series.prototype.remove.apply(e,arguments)}}ColumnSeries.defaultOptions=merge(Series.defaultOptions,ColumnSeriesDefaults),extend(ColumnSeries.prototype,{directTouch:!0,getSymbol:noop,negStacks:!0,trackerGroups:["group","dataLabelsGroup"]}),SeriesRegistry.registerSeriesType("column",ColumnSeries);export default ColumnSeries;