"use strict";import A from"../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import H from"../Core/Globals.js";const composed=H["composed"];import Series from"../Core/Series/Series.js";import Pane from"../Extensions/Pane/Pane.js";import RadialAxis from"../Core/Axis/RadialAxis.js";import U from"../Core/Utilities.js";const{addEvent,defined,find,isNumber,merge,pick,pushUnique,relativeLength,splat,uniqueKey,wrap}=U;function clipCircle(t,e,a,i,r){const n=uniqueKey(),o=t.createElement("clipPath").attr({id:n}).add(t.defs),s=(r?t.arc(e,a,i,r,0,2*Math.PI):t.circle(e,a,i)).add(o);return s.id=n,s.clipPath=o,s}function findAlignments(t,e){let a,i;return null===e.align&&(a=20<t&&t<160?"left":200<t&&t<340?"right":"center",e.align=a),null===e.verticalAlign&&(i=t<45||315<t?"bottom":135<t&&t<225?"top":"middle",e.verticalAlign=i),e}function getConnectors(t,e,a,i){var r=1.5,n=2.5,o=i?1:0;let s,l,p,h,c,d;var e=(s=0<=e&&e<=t.length-1?e:e<0?t.length-1+e:0)-1<0?t.length-(1+o):s-1,o=s+1>t.length-1?o:s+1,f=t[e],o=t[o],g=f.plotX,f=f.plotY,x=o.plotX,o=o.plotY,m=t[s].plotX,u=t[s].plotY,g=(l=(r*m+g)/n,p=(r*u+f)/n,h=(r*m+x)/n,c=(r*u+o)/n,Math.sqrt(Math.pow(l-m,2)+Math.pow(p-u,2))),f=Math.sqrt(Math.pow(h-m,2)+Math.pow(c-u,2)),x=Math.atan2(p-u,l-m),r=Math.atan2(c-u,h-m);d=Math.PI/2+(x+r)/2,Math.abs(x-d)>Math.PI/2&&(d-=Math.PI),l=m+Math.cos(d)*g,p=u+Math.sin(d)*g;const A={rightContX:m+Math.cos(Math.PI+d)*f,rightContY:u+Math.sin(Math.PI+d)*f,leftContX:l,leftContY:p,plotX:m,plotY:u};return a&&(A.prevPointCont=getConnectors(t,e,!1,i)),A}function onChartAfterDrawChartBox(){(this.pane||[]).forEach(t=>{t.render()})}function onChartAfterInit(t){const e=t.args[0].xAxis,a=t.args[0].yAxis,i=t.args[0].chart;e&&a&&("polygon"===a.gridLineInterpolation?(e.startOnTick=!0,e.endOnTick=!0):"polygon"===e.gridLineInterpolation&&i.inverted&&(a.startOnTick=!0,a.endOnTick=!0))}function onChartCreateAxes(){this.pane||(this.pane=[]),this.options.pane=splat(this.options.pane||{}),splat(this.userOptions.pane||{}).forEach(t=>{new Pane(t,this)},this)}function onPointerGetSelectionBox(t){const e=t.args.marker,a=this.chart.xAxis[0],i=this.chart.yAxis[0],r=this.chart.inverted,n=r?i:a,o=r?a:i;var s,l,p,h;this.chart.polar&&(t.preventDefault(),s=(e.attr?e.attr("start"):e.start)-n.startAngleRad,l=e.attr?e.attr("r"):e.r,p=(e.attr?e.attr("end"):e.end)-n.startAngleRad,h=e.attr?e.attr("innerR"):e.innerR,t.result.x=s+n.pos,t.result.width=p-s,t.result.y=o.len+o.pos-l,t.result.height=l-h)}function onPointerGetSelectionMarkerAttrs(t){var r=this.chart;if(r.polar&&r.hoverPane&&r.hoverPane.axis){t.preventDefault();const s=r.hoverPane.center,a=r.mouseDownX||0,l=r.mouseDownY||0,p=t.args.chartY,h=t.args.chartX,c=2*Math.PI,d=r.hoverPane.axis.startAngleRad,f=r.hoverPane.axis.endAngleRad,g=(r.inverted?r.xAxis:r.yAxis)[0],x={};let i="arc";if(x.x=s[0]+r.plotLeft,x.y=s[1]+r.plotTop,this.zoomHor){var n=0<d?f-d:Math.abs(d)+Math.abs(f);let t=Math.atan2(l-r.plotTop-s[1],a-r.plotLeft-s[0])-d,e=Math.atan2(p-r.plotTop-s[1],h-r.plotLeft-s[0])-d;x.r=s[2]/2,x.innerR=s[3]/2,t<=0&&(t+=c),e<=0&&(e+=c),e<t&&(e=[t,t=e][0]),n<c&&d+e>f+(c-n)/2&&(e=t,t=d<=0?d:0);var n=x.start=Math.max(t+d,d),o=x.end=Math.min(e+d,f);if("polygon"===g.options.gridLineInterpolation){const m=r.hoverPane.axis,u=n-m.startAngleRad+m.pos,A=o-n;let t=g.getPlotLinePath({value:g.max}),e=m.toValue(u),a=m.toValue(u+A);e<m.getExtremes().min&&({min:o,max:n}=m.getExtremes(),e=n-(o-e)),a<m.getExtremes().min&&({min:n,max:o}=m.getExtremes(),a=o-(n-a)),a<e&&(a=[e,e=a][0]),(t=trimPath(t,e,a,m)).push(["L",s[0]+r.plotLeft,r.plotTop+s[1]]),x.d=t,i="path"}}if(this.zoomVert){const P=(r.inverted?r.xAxis:r.yAxis)[0];let t=Math.sqrt(Math.pow(a-r.plotLeft-s[0],2)+Math.pow(l-r.plotTop-s[1],2)),e=Math.sqrt(Math.pow(h-r.plotLeft-s[0],2)+Math.pow(p-r.plotTop-s[1],2));e<t&&(t=[e,e=t][0]),e>s[2]/2&&(e=s[2]/2),t<s[3]/2&&(t=s[3]/2),this.zoomHor||(x.start=d,x.end=f),x.r=e,x.innerR=t,"polygon"===P.options.gridLineInterpolation&&(o=P.toValue(P.len+P.pos-t),n=P.toValue(P.len+P.pos-e),n=P.getPlotLinePath({value:n}).concat(P.getPlotLinePath({value:o,reverse:!0})),x.d=n,i="path")}if(this.zoomHor&&this.zoomVert&&"polygon"===g.options.gridLineInterpolation){const e=r.hoverPane.axis,v=x.start||0,y=x.end||0,C=v-e.startAngleRad+e.pos,M=y-v,w=e.toValue(C),X=e.toValue(C+M);if(x.d instanceof Array){let t=x.d.slice(0,x.d.length/2),e=x.d.slice(x.d.length/2,x.d.length);e=[...e].reverse();o=r.hoverPane.axis;t=trimPath(t,w,X,o),(e=trimPath(e,w,X,o))&&(e[0][0]="L"),e=[...e].reverse(),x.d=t.concat(e),i="path"}}t.attrs=x,t.shapeType=i}}function onSeriesAfterInit(){var t=this.chart;t.polar&&(this.polar=new PolarAdditions(this),t.inverted&&(this.isRadialSeries=!0,this.is("column")&&(this.isRadialBar=!0)))}function onSeriesAfterTranslate(){if(this.chart.polar&&this.xAxis){const e=this,{xAxis:a,yAxis:i}=e,r=e.chart,n=(e.kdByAngle=r.tooltip&&r.tooltip.shared,e.kdByAngle||r.inverted?e.searchPoint=searchPointByAngleOrInverted:e.options.findNearestPointBy="xy",e.points);let t=n.length;for(;t--;)e.is("column")||e.is("columnrange")||e.polar.toXY(n[t]),r.hasParallelCoordinates||e.yAxis.reversed||(pick(n[t].y,Number.MIN_VALUE)<i.min||n[t].x<a.min||n[t].x>a.max?(n[t].isNull=!0,n[t].plotY=NaN):n[t].isNull=n[t].isValid&&!n[t].isValid());this.hasClipCircleSetter||(this.hasClipCircleSetter=!!e.eventsToUnbind.push(addEvent(e,"afterRender",function(){var t;r.polar&&!1!==this.options.clip&&(t=this.yAxis.pane.center,this.clipCircle?this.clipCircle.animate({x:t[0],y:t[1],r:t[2]/2,innerR:t[3]/2}):this.clipCircle=clipCircle(r.renderer,t[0],t[1],t[2]/2,t[3]/2),this.group.clip(this.clipCircle),this.setClip=H.noop)})))}}function searchPointByAngleOrInverted(t){var e=this.chart,a=this.xAxis,i=this.yAxis,r=a.pane&&a.pane.center,n=t.chartX-(r&&r[0]||0)-e.plotLeft,r=t.chartY-(r&&r[1]||0)-e.plotTop,e=e.inverted?{clientX:t.chartX-i.pos,plotY:t.chartY-a.pos}:{clientX:180+Math.atan2(n,r)*(-180/Math.PI)};return this.searchKDTree(e)}function trimPath(t,e,a,i){const r=i.tickInterval,n=i.tickPositions;let o=find(n,t=>a<=t),s=find([...n].reverse(),t=>t<=e);return defined(o)||(o=n[n.length-1]),defined(s)||(s=n[0],o+=r,t[0][0]="L",t.unshift(t[t.length-3])),(t=t.slice(n.indexOf(s),n.indexOf(o)+1))[0][0]="M",t}function wrapChartGet(t,e){return find(this.pane||[],t=>t.options.id===e)||t.call(this,e)}function wrapColumnSeriesAlignDataLabel(t,e,a,i,r,n){const o=this.chart,s=pick(i.inside,!!this.options.stacking);var l,p;o.polar?(l=e.rectPlotX/Math.PI*180,o.inverted?(this.forceDL=o.isInsidePlot(e.plotX,e.plotY),s&&e.shapeArgs?(p=e.shapeArgs,p=this.yAxis.postTranslate(((p.start||0)+(p.end||0))/2-this.xAxis.startAngleRad,e.barX+e.pointWidth/2),r=merge(r,{x:p.x-o.plotLeft,y:p.y-o.plotTop})):e.tooltipPos&&(r=merge(r,{x:e.tooltipPos[0],y:e.tooltipPos[1]})),i.align=pick(i.align,"center"),i.verticalAlign=pick(i.verticalAlign,"middle")):i=findAlignments(l,i),Series.prototype.alignDataLabel.call(this,e,a,i,r,n),this.isRadialBar&&e.shapeArgs&&e.shapeArgs.start===e.shapeArgs.end?a.hide():a.show()):t.call(this,e,a,i,r,n)}function onAfterColumnTranslate(){const t=this,e=t.options,a=e.stacking,i=t.chart,r=t.xAxis,n=t.yAxis,o=n.reversed,s=n.center,l=r.startAngleRad,p=r.endAngleRad,h=p-l;e.threshold;let c,d=0,f,g,x,m,u,A=0,P=0,v,y,C,M,w,X,Y,T;if(r.isRadial)for(f=t.points,x=f.length,m=n.translate(n.min),u=n.translate(n.max),c=e.threshold||0,i.inverted&&isNumber(c)&&(d=n.translate(c),defined(d)&&(d<0?d=0:d>h&&(d=h),t.translatedThreshold=d+l));x--;){var L;g=f[x],X=g.barX,y=g.x,C=g.y,g.shapeType="arc",i.inverted?(g.plotY=n.translate(C),a&&n.stacking?(w=n.stacking.stacks[(C<0?"-":"")+t.stackKey],t.visible&&w&&w[y]&&(g.isNull||(M=w[y].points[t.getStackIndicator(void 0,y,t.index).key],A=n.translate(M[0]),P=n.translate(M[1]),defined(A)&&(A=U.clamp(A,0,h))))):(A=d,P=g.plotY),A>P&&(P=[A,A=P][0]),o?P>m?P=m:A<u?A=u:(A>m||P<u)&&(A=P=h):A<m?A=m:P>u?P=u:(P<m||A>u)&&(A=P=0),n.min>n.max&&(A=P=o?h:0),A+=l,P+=l,s&&(g.barX=X+=s[3]/2),Y=Math.max(X,0),T=Math.max(X+g.pointWidth,0),L="object"==typeof(L=e.borderRadius)?L.radius:L,L=relativeLength(L||0,T-Y),g.shapeArgs={x:s[0],y:s[1],r:T,innerR:Y,start:A,end:P,borderRadius:L},g.opacity=A===P?0:void 0,g.plotY=(defined(t.translatedThreshold)&&(A<t.translatedThreshold?A:P))-l):(A=X+l,g.shapeArgs=t.polar.arc(g.yBottom,g.plotY,A,A+g.pointWidth),g.shapeArgs.borderRadius=0),t.polar.toXY(g),i.inverted?(v=n.postTranslate(g.rectPlotY,X+g.pointWidth/2),g.tooltipPos=[v.x-i.plotLeft,v.y-i.plotTop]):g.tooltipPos=[g.plotX,g.plotY],s&&(g.ttBelow=g.plotY>s[1])}}function wrapLineSeriesGetGraphPath(t,e){const a=this;let i,r;if(this.chart.polar){e=e||this.points;for(let t=0;t<e.length;t++)if(!e[t].isNull){i=t;break}!1!==this.options.connectEnds&&void 0!==i&&(this.connectEnds=!0,e.splice(e.length,0,e[i]),r=!0),e.forEach(t=>{void 0===t.polarPlotY&&a.polar.toXY(t)})}t=t.apply(this,[].slice.call(arguments,1));return r&&e.pop(),t}function wrapPointerGetCoordinates(t,r){const n=this.chart;let o={xAxis:[],yAxis:[]};return n.polar?n.axes.forEach(t=>{var e,a,i;"colorAxis"!==t.coll&&(e=t.isXAxis,i=t.center,a=r.chartX-i[0]-n.plotLeft,i=r.chartY-i[1]-n.plotTop,o[e?"xAxis":"yAxis"].push({axis:t,value:t.translate(e?Math.PI-Math.atan2(a,i):Math.sqrt(Math.pow(a,2)+Math.pow(i,2)),!0)}))}):o=t.call(this,r),o}function wrapPointerPinch(t,e){this.chart.polar||t.call(this,e)}function wrapSeriesAnimate(t,e){const a=this,i=this.chart,r=this.group,n=this.markerGroup,o=this.xAxis&&this.xAxis.center,s=i.plotLeft,l=i.plotTop;let p=this.options.animation,h,c,d,f,g,x;i.polar?a.isRadialBar?e||(a.startAngleRad=pick(a.translatedThreshold,a.xAxis.startAngleRad),H.seriesTypes.pie.prototype.animate.call(a,e)):(p=animObject(p),a.is("column")?e||(c=o[3]/2,a.points.forEach(t=>{d=t.graphic,f=t.shapeArgs,g=f&&f.r,x=f&&f.innerR,d&&f&&(d.attr({r:c,innerR:c}),d.animate({r:g,innerR:x},a.options.animation))})):e?(h={translateX:o[0]+s,translateY:o[1]+l,scaleX:.001,scaleY:.001},r.attr(h),n&&n.attr(h)):(h={translateX:s,translateY:l,scaleX:1,scaleY:1},r.animate(h,p),n&&n.animate(h,p))):t.call(this,e)}function wrapSplineSeriesGetPointSpline(t,e,a,i){let r,n;var o,s;return r=this.chart.polar?i?(o=(n=getConnectors(e,i,!0,this.connectEnds)).prevPointCont&&n.prevPointCont.rightContX,s=n.prevPointCont&&n.prevPointCont.rightContY,["C",isNumber(o)?o:n.plotX,isNumber(s)?s:n.plotY,isNumber(n.leftContX)?n.leftContX:n.plotX,isNumber(n.leftContY)?n.leftContY:n.plotY,n.plotX,n.plotY]):["M",a.plotX,a.plotY]:t.call(this,e,a,i)}function wrapPointPos(t,e,a=this.plotY){var i,r;if(!this.destroyed)return{plotX:i,series:r}=this,r=r["chart"],r.polar&&isNumber(i)&&isNumber(a)?[i+(e?r.plotLeft:0),a+(e?r.plotTop:0)]:t.call(this,e,a)}class PolarAdditions{static compose(t,e,a,i,r,n,o,s,l,p){if(Pane.compose(e,a),RadialAxis.compose(t,r),pushUnique(composed,"Polar")){var t=e.prototype,r=n.prototype,n=a.prototype,h=i.prototype;if(addEvent(e,"afterDrawChartBox",onChartAfterDrawChartBox),addEvent(e,"createAxes",onChartCreateAxes),addEvent(e,"init",onChartAfterInit),wrap(t,"get",wrapChartGet),wrap(n,"getCoordinates",wrapPointerGetCoordinates),wrap(n,"pinch",wrapPointerPinch),addEvent(a,"getSelectionMarkerAttrs",onPointerGetSelectionMarkerAttrs),addEvent(a,"getSelectionBox",onPointerGetSelectionBox),addEvent(i,"afterInit",onSeriesAfterInit),addEvent(i,"afterTranslate",onSeriesAfterTranslate,{order:2}),addEvent(i,"afterColumnTranslate",onAfterColumnTranslate,{order:4}),wrap(h,"animate",wrapSeriesAnimate),wrap(r,"pos",wrapPointPos),s&&(e=s.prototype,wrap(e,"alignDataLabel",wrapColumnSeriesAlignDataLabel),wrap(e,"animate",wrapSeriesAnimate)),l&&(t=l.prototype,wrap(t,"getGraphPath",wrapLineSeriesGetGraphPath)),p){n=p.prototype;if(wrap(n,"getPointSpline",wrapSplineSeriesGetPointSpline),o){const c=o.prototype;c.getPointSpline=n.getPointSpline}}}}constructor(t){this.series=t}arc(t,e,a,i){var r=this.series,n=r.xAxis.center,o=r.yAxis.len,s=n[3]/2;let l=o-e+s,p=o-pick(t,o)+s;return r.yAxis.reversed&&(l<0&&(l=s),p<0&&(p=s)),{x:n[0],y:n[1],r:l,innerR:p,start:a,end:i}}toXY(t){const e=this.series,a=e.chart,i=e.xAxis,r=e.yAxis,n=t.plotX,o=a.inverted,s=t.y;let l=t.plotY,p=o?n:r.len-l,h;var c;o&&e&&!e.isRadialBar&&(t.plotY=l=isNumber(s)?r.translate(s):0),t.rectPlotX=n,t.rectPlotY=l,r.center&&(p+=r.center[3]/2),isNumber(l)&&(c=o?r.postTranslate(l,p):i.postTranslate(n,p),t.plotX=t.polarPlotX=c.x-a.plotLeft,t.plotY=t.polarPlotY=c.y-a.plotTop),e.kdByAngle?((h=(n/Math.PI*180+i.pane.options.startAngle)%360)<0&&(h+=360),t.clientX=h):t.clientX=t.plotX}}export default PolarAdditions;