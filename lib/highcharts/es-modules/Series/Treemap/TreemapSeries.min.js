"use strict";import Breadcrumbs from"../../Extensions/Breadcrumbs/Breadcrumbs.js";import Color from"../../Core/Color/Color.js";const color=Color["parse"];import ColorMapComposition from"../ColorMapComposition.js";import H from"../../Core/Globals.js";const{composed,noop}=H;import Series from"../../Core/Series/Series.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,scatter:ScatterSeries}=SeriesRegistry.seriesTypes;import TreemapAlgorithmGroup from"./TreemapAlgorithmGroup.js";import TreemapNode from"./TreemapNode.js";import TreemapPoint from"./TreemapPoint.js";import TreemapSeriesDefaults from"./TreemapSeriesDefaults.js";import TreemapUtilities from"./TreemapUtilities.js";import TU from"../TreeUtilities.js";const{getColor,getLevelOptions,updateRootId}=TU;import U from"../../Core/Utilities.js";const{addEvent,arrayMax,clamp,correctFloat,crisp,defined,error,extend,fireEvent,isArray,isNumber,isObject,isString,merge,pick,pushUnique,splat,stableSort}=U,axisMax=(Series.keepProps.push("simulation","hadOutsideDataLabels"),100);let treemapAxisDefaultValues=!1;function onSeriesAfterBindAxes(){const e=this,t=e.xAxis,i=e.yAxis;var o;t&&i&&(e.is("treemap")?(o={endOnTick:!1,gridLineWidth:0,lineWidth:0,min:0,minPadding:0,max:axisMax,maxPadding:0,startOnTick:!1,title:void 0,tickPositions:[]},extend(i.options,o),extend(t.options,o),treemapAxisDefaultValues=!0):treemapAxisDefaultValues&&(i.setOptions(i.userOptions),t.setOptions(t.userOptions),treemapAxisDefaultValues=!1))}class TreemapSeries extends ScatterSeries{constructor(){super(...arguments),this.simulation=0}static compose(e){pushUnique(composed,"TreemapSeries")&&addEvent(e,"afterBindAxes",onSeriesAfterBindAxes)}algorithmCalcPoints(e,t,i,o){const r=i.plot,s=i.elArr.length-1;let a,n,l,d,p=i.lW,h=i.lH,c,u=0;t?(p=i.nW,h=i.nH):c=i.elArr[s];for(const m of i.elArr)(t||u<s)&&(0===i.direction?(a=r.x,n=r.y,l=p,d=m/l):(a=r.x,n=r.y,d=h,l=m/d),o.push({x:a,y:n,width:l,height:correctFloat(d)}),0===i.direction?r.y=r.y+d:r.x=r.x+l),u+=1;i.reset(),0===i.direction?i.width=i.width-p:i.height=i.height-h,r.y=r.parent.y+(r.parent.height-i.height),r.x=r.parent.x+(r.parent.width-i.width),e&&(i.direction=1-i.direction),t||i.addElement(c)}algorithmFill(e,t,i){const o=[];let r,s=t.direction,a=t.x,n=t.y,l=t.width,d=t.height,p,h,c,u;for(const m of i)r=t.width*t.height*(m.val/t.val),p=a,h=n,0===s?(u=d,c=r/u,l-=c,a+=c):(c=l,u=r/c,d-=u,n+=u),o.push({x:p,y:h,width:c,height:u,direction:0,val:0}),e&&(s=1-s);return o}algorithmLowAspectRatio(e,t,i){const o=[],r={x:t.x,y:t.y,parent:t},s=t.direction,a=i.length-1,n=new TreemapAlgorithmGroup(t.height,t.width,s,r);let l,d=0;for(const p of i)l=t.width*t.height*(p.val/t.val),n.addElement(l),n.lP.nR>n.lP.lR&&this.algorithmCalcPoints(e,!1,n,o,r),d===a&&this.algorithmCalcPoints(e,!0,n,o,r),++d;return o}alignDataLabel(e,t,i){ColumnSeries.prototype.alignDataLabel.apply(this,arguments),e.dataLabel&&e.dataLabel.attr({zIndex:(e.node.zIndex||0)+1})}applyTreeGrouping(){const l=this,d=l.parentList||{},p=l.options["cluster"],e=p?.minimumClusterSize||5;if(p?.enabled){const n={},h=e=>{var t,i,o,r,s,a;e?.point?.shapeArgs&&({width:t=0,height:i=0}=e.point.shapeArgs,o=t*i,{pixelWidth:r=0,pixelHeight:s=0}=p,a=defined(s),(t<r||i<(a?s:r)||o<(s?r*s:r*r))&&!e.isGroup&&defined(e.parent)&&(n[e.parent]||(n[e.parent]=[]),n[e.parent].push(e))),e?.children.forEach(e=>{h(e)})};h(l.tree);for(const c in n)n[c]&&n[c].length>e&&n[c].forEach(t=>{var i=d[c].indexOf(t.i);if(-1!==i){d[c].splice(i,1);const s="highcharts-grouped-treemap-points-"+(t.parent||"root");let e=l.points.find(e=>e.id===s);if(!e){const a=l.pointClass,n=l.points.length;e=new a(l,{className:p.className,color:p.color,id:s,index:n,isGroup:!0,value:0}),extend(e,{formatPrefix:"cluster"}),l.points.push(e),d[c].push(n),d[s]=[]}var i=e.groupedPointsAmount+1,o=l.points[e.index].options.value||0,r=p.name||"+ "+i;l.points[e.index].groupedPointsAmount=i,l.points[e.index].options.value=o+(t.point.value||0),l.points[e.index].name=r,d[s].push(t.point.index)}});l.nodeMap={},l.nodeList=[],l.parentList=d;var t=l.buildTree("",-1,0,l.parentList);l.translate(t)}}calculateChildrenAreas(a,n){var r=this,s=r.options,l=r.mapOptionsToLevel[a.level+1],d=pick(l?.layoutAlgorithm&&r[l?.layoutAlgorithm]&&l.layoutAlgorithm,s.layoutAlgorithm),p=s.alternateStartingDirection,h=a.children.filter(e=>a.isGroup||!e.ignore),c=l?.groupPadding??s.groupPadding??0,u=r.nodeMap[r.rootNode];if(d){let e,t=u.pointValues?.width||0,i=u.pointValues?.height||0,o=(l?.layoutStartingDirection&&(n.direction="vertical"===l.layoutStartingDirection?0:1),e=r[d](n,h),-1);for(const b of h){var m,v=e[++o],g=(b===u&&(t=t||v.width,i=v.height),c/(r.xAxis.len/i)),f=c/(r.yAxis.len/i);b.values=merge(v,{val:b.childrenTotal,direction:p?1-n.direction:n.direction}),b.children.length&&b.point.dataLabels?.length&&((m=arrayMax(b.point.dataLabels.map(e=>e.options?.headers&&e.height||0))/(r.yAxis.len/i))<b.values.height/2&&(b.values.y+=m,b.values.height-=m)),c&&(m=Math.min(g,b.values.width/4),g=Math.min(f,b.values.height/4),b.values.x+=m,b.values.width-=2*m,b.values.y+=g,b.values.height-=2*g),b.pointValues=merge(v,{x:v.x/r.axisRatio,y:axisMax-v.y-v.height,width:v.width/r.axisRatio}),b.children.length&&r.calculateChildrenAreas(b,b.values)}const x=(e,t=[],i=!0)=>(e.children.forEach(e=>{(i&&e.isLeaf||!i&&!e.isLeaf)&&t.push(e.point),e.children.length&&x(e,t,i)}),t);if("leaf"===s.nodeSizeBy&&a===u&&this.hasOutsideDataLabels&&!x(u,void 0,!1).some(e=>isNumber(e.options.value))&&!isNumber(u.point?.options.value)){const y=x(u),T=y.map(e=>e.options.value||0),A=y.map(({node:{pointValues:e}})=>e?e.width*e.height:0),w=T.reduce((e,t)=>e+t,0),L=A.reduce((e,t)=>e+t,0),C=L/w;let r=0,s=0;y.forEach((e,t)=>{var i=T[t]?A[t]/T[t]:1,i=clamp(i/C,.8,1.4);let o=1-i;e.value&&(A[t]<20&&(o*=A[t]/20),o>s&&(s=o),o<r&&(r=o),e.simulatedValue=(e.simulatedValue||e.value)/i)}),(r<-.05||.05<s)&&this.simulation<10?(this.simulation++,this.setTreeValues(a),n.val=a.val,this.calculateChildrenAreas(a,n)):(y.forEach(e=>{delete e.simulatedValue}),this.setTreeValues(a),this.simulation=0)}}}createList(i){const o=this.chart,e=o.breadcrumbs,r=[];if(e){let e=0,t=(r.push({level:e,levelOptions:o.series[0]}),i.target.nodeMap[i.newRootId]);const s=[];for(;t.parent||""===t.parent;)s.push(t),t=i.target.nodeMap[t.parent];for(const a of s.reverse())r.push({level:++e,levelOptions:a});r.length<=1&&(r.length=0)}return r}drawDataLabels(){const e=this,t=e.mapOptionsToLevel,i=e.points.filter(function(e){return e.node.visible||defined(e.dataLabel)}),o=splat(e.options.dataLabels||{})[0]?.padding,r=i.some(e=>isNumber(e.plotY));for(const l of i){const d={},p={style:d},h=t[l.node.level];var s,a,n;(!l.node.isLeaf&&!l.node.isGroup||l.node.isGroup&&l.node.level<=e.nodeMap[e.rootNode].level)&&(p.enabled=!1),h?.dataLabels&&(merge(!0,p,splat(h.dataLabels)[0]),e.hasDataLabels=()=>!0),l.node.isLeaf?p.inside=!0:p.headers&&(p.verticalAlign="top"),l.shapeArgs&&r&&({height:s=0,width:a=0}=l.shapeArgs,32<a&&16<s&&l.shouldDraw()?(n=a-2*(p.padding||o||0),d.width=n+"px",d.lineClamp??(d.lineClamp=Math.floor(s/16)),d.visibility="inherit",p.headers&&l.dataLabel?.attr({width:n})):(d.width=a+"px",d.visibility="hidden")),l.dlOptions=merge(p,l.options.dataLabels)}super.drawDataLabels(i)}drawPoints(e=this.points){const t=this,i=t.chart,o=i.renderer,r=i.styledMode,s=t.options,a=r?{}:s.shadow,n=s.borderRadius,l=i.pointCount<s.animationLimit,d=s.allowTraversingTree;for(const p of e){const h=p.node.levelDynamic,c={},u={},m={},v="level-group-"+p.node.level,g=!!p.graphic,f=l&&g,x=p.shapeArgs;p.shouldDraw()&&(p.isInside=!0,n&&(u.r=n),merge(!0,f?c:u,g?x:{},r?{}:t.pointAttribs(p,p.selected?"select":void 0)),t.colorAttribs&&r&&extend(m,t.colorAttribs(p)),t[v]||(t[v]=o.g(v).attr({zIndex:1e3-(h||0)}).add(t.group),t[v].survive=!0)),p.draw({animatableAttribs:c,attribs:u,css:m,group:t[v],imageUrl:p.imageUrl,renderer:o,shadow:a,shapeArgs:x,shapeType:p.shapeType}),d&&p.graphic&&(p.drillId=s.interactByLeaf?t.drillToByLeaf(p):t.drillToByGroup(p))}}drillToByGroup(e){return!(e.node.isLeaf&&!e.node.isGroup)&&e.id}drillToByLeaf(e){var t=e.series.options["traverseToLeaf"];let i=!1,o;if(e.node.parent!==this.rootNode&&e.node.isLeaf)if(t)i=e.id;else for(o=e.node;!i;)(o=void 0!==o.parent?this.nodeMap[o.parent]:o).parent===this.rootNode&&(i=o.id);return i}drillToNode(e,t){error(32,!1,void 0,{"treemap.drillToNode":"use treemap.setRootNode"}),this.setRootNode(e,t)}drillUp(){var e=this.nodeMap[this.rootNode];e&&isString(e.parent)&&this.setRootNode(e.parent,!0,{trigger:"traverseUpButton"})}getExtremes(){var{dataMin:e,dataMax:t}=super.getExtremes(this.colorValueData);return this.valueMin=e,this.valueMax=t,super.getExtremes()}getListOfParents(e,t){const i=isArray(e)?e:[],o=isArray(t)?t:[],r=i.reduce(function(e,t,i){t=pick(t.parent,"");return void 0===e[t]&&(e[t]=[]),e[t].push(i),e},{"":[]});for(const a of Object.keys(r)){var s=r[a];if(""!==a&&-1===o.indexOf(a)){for(const n of s)r[""].push(n);delete r[a]}}return r}getTree(){var e=this,t=this.data.map(function(e){return e.id});return e.parentList=e.getListOfParents(this.data,t),e.nodeMap={},e.nodeList=[],e.buildTree("",-1,0,e.parentList||{})}buildTree(e,t,i,o,r){const s=this,a=[],n=s.points[t];let l=0,d;for(const h of o[e]||[])d=s.buildTree(s.points[h].id,h,i+1,o,e),l=Math.max(d.height+1,l),a.push(d);const p=(new s.NodeClass).init(e,t,a,l,i,s,r);for(const d of a)d.parentNode=p;return s.nodeMap[p.id]=p,s.nodeList.push(p),n&&((n.node=p).point=n),p}hasData(){return!!this.dataTable.rowCount}init(e,t){const i=this,o=merge(t.drillUpButton,t.breadcrumbs),r=addEvent(i,"setOptions",e=>{const t=e.userOptions,i=(defined(t.allowDrillToNode)&&!defined(t.allowTraversingTree)&&(t.allowTraversingTree=t.allowDrillToNode,delete t.allowDrillToNode),defined(t.drillUpButton)&&!defined(t.traverseUpButton)&&(t.traverseUpButton=t.drillUpButton,delete t.drillUpButton),splat(t.dataLabels||{}));t.levels?.forEach(e=>{i.push.apply(i,splat(e.dataLabels||{}))}),this.hasOutsideDataLabels=i.some(e=>e.headers)});super.init(e,t),delete i.opacity,i.eventsToUnbind.push(r),i.options.allowTraversingTree&&(i.eventsToUnbind.push(addEvent(i,"click",i.onClickDrillToNode)),i.eventsToUnbind.push(addEvent(i,"setRootNode",function(e){const t=i.chart;t.breadcrumbs&&t.breadcrumbs.updateProperties(i.createList(e))})),i.eventsToUnbind.push(addEvent(i,"update",function(e,t){const i=this.chart.breadcrumbs;i&&e.options.breadcrumbs&&i.update(e.options.breadcrumbs),this.hadOutsideDataLabels=this.hasOutsideDataLabels})),i.eventsToUnbind.push(addEvent(i,"destroy",function(e){const t=this.chart;t.breadcrumbs&&!e.keepEventsForUpdate&&(t.breadcrumbs.destroy(),t.breadcrumbs=void 0)}))),e.breadcrumbs||(e.breadcrumbs=new Breadcrumbs(e,o)),i.eventsToUnbind.push(addEvent(e.breadcrumbs,"up",function(e){var t=this.level-e.newLevel;for(let e=0;e<t;e++)i.drillUp()}))}onClickDrillToNode(e){const t=e.point,i=t?.drillId;isString(i)&&(t.setState(""),this.setRootNode(i,!0,{trigger:"click"}))}pointAttribs(e,t){const i=isObject(this.mapOptionsToLevel)?this.mapOptionsToLevel:{},o=e&&i[e.node.level]||{},r=this.options,s=t&&r.states&&r.states[t]||{},a=e?.getClassName()||"",n={stroke:e&&e.borderColor||o.borderColor||s.borderColor||r.borderColor,"stroke-width":pick(e&&e.borderWidth,o.borderWidth,s.borderWidth,r.borderWidth),dashstyle:e?.borderDashStyle||o.borderDashStyle||s.borderDashStyle||r.borderDashStyle,fill:e?.color||this.color};return-1!==a.indexOf("highcharts-above-level")?(n.fill="none",n["stroke-width"]=0):-1!==a.indexOf("highcharts-internal-node-interactive")?(n["fill-opacity"]=s.opacity??r.opacity??1,n.cursor="pointer"):-1!==a.indexOf("highcharts-internal-node")?n.fill="none":t&&s.brightness&&(n.fill=color(n.fill).brighten(s.brightness).get()),n}setColorRecursive(t,i,o,r,s){var a=this,n=(a?.chart)?.options?.colors;if(t){const l=getColor(t,{colors:n,index:r,mapOptionsToLevel:a.mapOptionsToLevel,parentColor:i,parentColorIndex:o,series:a,siblings:s}),d=a.points[t.i];d&&(d.color=l.color,d.colorIndex=l.colorIndex);let e=-1;for(const p of t.children||[])a.setColorRecursive(p,l.color,l.colorIndex,++e,t.children.length)}}setPointValues(){const e=this,{points:t,xAxis:i,yAxis:o}=e,r=e.chart.styledMode;for(const m of t){var s,a,n,l,d,p,h,{pointValues:c,visible:u}=m.node;c&&u?({height:u,width:c,x:p,y:s}=c,a=m,a=!r&&e.pointAttribs(a)["stroke-width"]||0,l=i.toPixels(p,!0),d=i.toPixels(p+c,!0),h=o.toPixels(s,!0),n=o.toPixels(s+u,!0),l=0===l?a/2:crisp(i.toPixels(p,!0),a,!0),d=d===i.len?i.len-a/2:crisp(i.toPixels(p+c,!0),a,!0),p=h===o.len?o.len-a/2:crisp(o.toPixels(s,!0),a,!0),c=0===n?a/2:crisp(o.toPixels(s+u,!0),a,!0),h={x:Math.min(l,d),y:Math.min(p,c),width:Math.abs(d-l),height:Math.abs(c-p)},m.plotX=h.x+h.width/2,m.plotY=h.y+h.height/2,m.shapeArgs=h):(delete m.plotX,delete m.plotY)}}setRootNode(e,t,i){e=extend({newRootId:e,previousRootId:this.rootNode,redraw:pick(t,!0),series:this},i);fireEvent(this,"setRootNode",e,function(e){const t=e.series;t.idPreviousRoot=e.previousRootId,t.rootNode=e.newRootId,t.isDirty=!0,e.redraw&&t.chart.redraw()})}setState(e){this.options.inactiveOtherPoints=!0,super.setState(e,!1),this.options.inactiveOtherPoints=!1}setTreeValues(e){const t=this,i=t.options,o=t.rootNode,r=t.nodeMap,s=r[o],a="boolean"!=typeof i.levelIsConstant||i.levelIsConstant,n=[],l=t.points[e.i];let d=0;for(var p of e.children)p=t.setTreeValues(p),n.push(p),p.ignore||(d+=p.val);stableSort(n,(e,t)=>(e.sortIndex||0)-(t.sortIndex||0));let h=pick(l?.simulatedValue,l?.options.value,d);return l&&(l.value=h),l?.isGroup&&i.cluster?.reductionFactor&&(h/=i.cluster.reductionFactor),e.parentNode?.point?.isGroup&&t.rootNode!==e.parent&&(e.visible=!1),extend(e,{children:n,childrenTotal:d,ignore:!(pick(l?.visible,!0)&&0<h),isLeaf:e.visible&&!d,isGroup:l?.isGroup,levelDynamic:e.level-(a?0:s.level),name:pick(l?.name,""),sortIndex:pick(l?.sortIndex,-h),val:h}),e}sliceAndDice(e,t){return this.algorithmFill(!0,e,t)}squarified(e,t){return this.algorithmLowAspectRatio(!0,e,t)}strip(e,t){return this.algorithmLowAspectRatio(!1,e,t)}stripes(e,t){return this.algorithmFill(!1,e,t)}translate(e){const o=this,t=o.options,i=!e;let r=updateRootId(o),s,a,n,l;e||r.startsWith("highcharts-grouped-treemap-points-")||((this.points||[]).forEach(e=>{e.isGroup&&e.destroy()}),super.translate(),e=o.getTree()),o.tree=e=e||o.tree,s=o.nodeMap[r],""===r||s||(o.setRootNode("",!1),r=o.rootNode,s=o.nodeMap[r]),s.point?.isGroup||(o.mapOptionsToLevel=getLevelOptions({from:s.level+1,levels:t.levels,to:e.height,defaults:{levelIsConstant:o.options.levelIsConstant,colorByPoint:t.colorByPoint}})),TreemapUtilities.recursive(o.nodeMap[o.rootNode],e=>{var t=e.parent;let i=!1;return e.visible=!0,i=!t&&""!==t?i:o.nodeMap[t]}),TreemapUtilities.recursive(o.nodeMap[o.rootNode].children,e=>{let t=!1;for(const i of e)i.visible=!0,i.children.length&&(t=(t||[]).concat(i.children));return t}),o.setTreeValues(e),o.axisRatio=o.xAxis.len/o.yAxis.len,o.nodeMap[""].pointValues=a={x:0,y:0,width:axisMax,height:axisMax},o.nodeMap[""].values=n=merge(a,{width:a.width*o.axisRatio,direction:"vertical"===t.layoutStartingDirection?0:1,val:e.val}),(this.hasOutsideDataLabels||this.hadOutsideDataLabels)&&this.drawDataLabels(),o.calculateChildrenAreas(e,n),o.colorAxis||t.colorByPoint||o.setColorRecursive(o.tree),t.allowTraversingTree&&s.pointValues&&(l=s.pointValues,o.xAxis.setExtremes(l.x,l.x+l.width,!1),o.yAxis.setExtremes(l.y,l.y+l.height,!1),o.xAxis.setScale(),o.yAxis.setScale()),o.setPointValues(),i&&o.applyTreeGrouping()}}TreemapSeries.defaultOptions=merge(ScatterSeries.defaultOptions,TreemapSeriesDefaults),extend(TreemapSeries.prototype,{buildKDTree:noop,colorAttribs:ColorMapComposition.seriesMembers.colorAttribs,colorKey:"colorValue",directTouch:!0,getExtremesFromAll:!0,getSymbol:noop,optionalAxis:"colorAxis",parallelArrays:["x","y","value","colorValue"],pointArrayMap:["value","colorValue"],pointClass:TreemapPoint,NodeClass:TreemapNode,trackerGroups:["group","dataLabelsGroup"],utils:TreemapUtilities}),ColorMapComposition.compose(TreemapSeries),SeriesRegistry.registerSeriesType("treemap",TreemapSeries);export default TreemapSeries;