"use strict";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{column:ColumnSeries,line:LineSeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{addEvent,arrayMax,arrayMin,correctFloat,crisp,extend,isNumber,merge,objectEach,pick}=U;import WaterfallAxis from"../../Core/Axis/WaterfallAxis.js";import WaterfallPoint from"./WaterfallPoint.js";import WaterfallSeriesDefaults from"./WaterfallSeriesDefaults.js";function ownProp(t,e){return Object.hasOwnProperty.call(t,e)}class WaterfallSeries extends ColumnSeries{generatePoints(){ColumnSeries.prototype.generatePoints.apply(this);var s=this.getColumn("y",!0);for(let t=0,e=this.points.length;t<e;t++){const a=this.points[t],o=s[t];isNumber(o)&&(a.isIntermediateSum||a.isSum)&&(a.y=correctFloat(o))}}processData(t){const e=this,s=e.options,a=e.getColumn("y"),o=s.data,i=a.length,r=s.threshold||0;let l,n,h,c,d,p;for(let t=h=n=c=d=0;t<i;t++)p=a[t],l=o?.[t]||{},"sum"===p||l.isSum?a[t]=correctFloat(h):"intermediateSum"===p||l.isIntermediateSum?(a[t]=correctFloat(n),n=0):(h+=p,n+=p),c=Math.min(h,c),d=Math.max(h,d);super.processData.call(this,t),s.stacking||(e.dataMin=c+r,e.dataMax=d)}toYData(t){return t.isSum?"sum":t.isIntermediateSum?"intermediateSum":t.y}pointAttribs(t,e){var s=this.options.upColor;s&&!t.options.color&&isNumber(t.y)&&(t.color=0<t.y?s:void 0);const a=ColumnSeries.prototype.pointAttribs.call(this,t,e);return delete a.dashstyle,a}getGraphPath(){return[["M",0,0]]}getCrispPath(){const t=this.data.filter(t=>isNumber(t.y)),s=this.yAxis,a=t.length,o=this.graph?.strokeWidth()||0,i=this.xAxis.reversed,r=this.yAxis.reversed,l=this.options.stacking,n=[];for(let e=1;e<a;e++)if(this.options.connectNulls||isNumber(this.data[t[e].index-1].y)){var h=t[e].box,c=t[e-1],d=c.y||0,p=t[e-1].box;if(h&&p){var g=s.waterfall?.stacks[this.stackKey],u=0<d?-p.height:0;if(g&&p&&h){var g=g[e-1];let t;t=l?(g=g.connectorThreshold,crisp(s.translate(g,!1,!0,!1,!0)+(r?u:0),o)):crisp(p.y+(c.minPointLengthOffset||0),o),n.push(["M",(p.x||0)+(!i&&p.width||0),t],["L",(h.x||0)+(i&&h.width||0),t])}if(p&&n.length&&(!l&&d<0&&!r||0<d&&r)){const m=n[n.length-2],y=(m&&"number"==typeof m[2]&&(m[2]+=p.height||0),n[n.length-1]);y&&"number"==typeof y[2]&&(y[2]+=p.height||0)}}}return n}drawGraph(){LineSeries.prototype.drawGraph.call(this),this.graph&&this.graph.attr({d:this.getCrispPath()})}setStackedPoints(t){const e=this,s=e.options,a=t.waterfall?.stacks,o=s.threshold||0,i=e.stackKey,r=e.getColumn("x"),l=e.getColumn("y"),n=r.length;let h=o,c=h,d,p=0,g=0,u=0,m,y,f,S,b,x,k,P;var T=(t,e,s,a)=>{if(d){if(m)for(;s<m;s++)d.stackState[s]+=a;else d.stackState[0]=t,m=d.stackState.length;d.stackState.push(d.stackState[m-1]+e)}};if(t.stacking&&a&&e.reserveSpace()){P=a.changed,(k=a.alreadyChanged)&&k.indexOf(i)<0&&(P=!0),a[i]||(a[i]={});const w=a[i];if(w)for(let t=0;t<n;t++)x=r[t],w[x]&&!P||(w[x]={negTotal:0,posTotal:0,stackTotal:0,threshold:0,stateIndex:0,stackState:[],label:P&&w[x]?w[x].label:void 0}),d=w[x],0<=(b=l[t])?d.posTotal+=b:d.negTotal+=b,S=s.data[t],y=d.absolutePos=d.posTotal,f=d.absoluteNeg=d.negTotal,d.stackTotal=y+f,m=d.stackState.length,S?.isIntermediateSum?(T(u,g,0,u),u=g,g=o,h^=c,c^=h,h^=c):S?.isSum?(T(o,p,m,0),h=o):(T(h,b,0,p),S&&(p+=b,g+=b)),d.stateIndex++,d.threshold=h,h+=d.stackTotal;a.changed=!1,a.alreadyChanged||(a.alreadyChanged=[]),a.alreadyChanged.push(i)}}getExtremes(){var t=this.options.stacking,e=this.yAxis.waterfall?.stacks;let s,a;return t&&e?(s=this.stackedYNeg=[],a=this.stackedYPos=[],"overlap"===t?objectEach(e[this.stackKey],function(t){s.push(arrayMin(t.stackState)),a.push(arrayMax(t.stackState))}):objectEach(e[this.stackKey],function(t){s.push(t.negTotal+t.threshold),a.push(t.posTotal+t.threshold)}),{dataMin:arrayMin(s),dataMax:arrayMax(a)}):{dataMin:this.dataMin,dataMax:this.dataMax}}}WaterfallSeries.defaultOptions=merge(ColumnSeries.defaultOptions,WaterfallSeriesDefaults),WaterfallSeries.compose=WaterfallAxis.compose,extend(WaterfallSeries.prototype,{pointValKey:"y",showLine:!0,pointClass:WaterfallPoint}),addEvent(WaterfallSeries,"afterColumnTranslate",function(){const e=this,{options:t,points:s,yAxis:a}=e,o=pick(t.minPointLength,5),i=o/2,r=t.threshold||0,l=t.stacking,n=a.waterfall?.stacks[e.stackKey],h=e.getColumn("y",!0);let c=r,d=r,p,g,u,m;for(let t=0;t<s.length;t++){const S=s[t],b=h[t],x=S.shapeArgs,k=extend({x:0,y:0,width:0,height:0},x||{});S.box=k;var y=[0,b],f=S.y||0;if(l){if(n){const P=n[t],T=("overlap"===l?(g=P.stackState[P.stateIndex--],p=0<=f?g:g-f,ownProp(P,"absolutePos")&&delete P.absolutePos,ownProp(P,"absoluteNeg")&&delete P.absoluteNeg):(p=0<=f?(g=P.threshold+P.posTotal,P.posTotal-=f,g):(g=P.threshold+P.negTotal,P.negTotal-=f,g-f),P.posTotal||isNumber(P.absolutePos)&&ownProp(P,"absolutePos")&&(P.posTotal=P.absolutePos,delete P.absolutePos),P.negTotal||isNumber(P.absoluteNeg)&&ownProp(P,"absoluteNeg")&&(P.negTotal=P.absoluteNeg,delete P.absoluteNeg)),S.isSum||(P.connectorThreshold=P.threshold+P.stackTotal),m=a.reversed?(u=0<=f?p-f:p+f,p):(u=p)-f,S.below=u<=r,k.y=a.translate(u,!1,!0,!1,!0),k.height=Math.abs(k.y-a.translate(m,!1,!0,!1,!0)),a.waterfall?.dummyStackItem);T&&(T.x=t,T.label=n[t].label,T.setOffset(e.pointXOffset||0,e.barW||0,e.stackedYNeg[t],e.stackedYPos[t],void 0,this.xAxis))}}else p=Math.max(d,d+f)+y[0],k.y=a.translate(p,!1,!0,!1,!0),S.isSum?(k.y=a.translate(y[1],!1,!0,!1,!0),k.height=Math.min(a.translate(y[0],!1,!0,!1,!0),a.len)-k.y,S.below=y[1]<=r):S.isIntermediateSum?(m=0<=f?(u=y[1]+c,c):(u=c,y[1]+c),a.reversed&&(u^=m,m^=u,u^=m),k.y=a.translate(u,!1,!0,!1,!0),k.height=Math.abs(k.y-Math.min(a.translate(m,!1,!0,!1,!0),a.len)),c+=y[1],S.below=u<=r):(k.height=0<b?a.translate(d,!1,!0,!1,!0)-k.y:a.translate(d,!1,!0,!1,!0)-a.translate(d-b,!1,!0,!1,!0),d+=b,S.below=d<r),k.height<0&&(k.y+=k.height,k.height*=-1);S.plotY=k.y,S.yBottom=k.y+k.height,k.height<=o&&!S.isNull?(k.height=o,k.y-=i,S.yBottom=k.y+k.height,S.plotY=k.y,S.minPointLengthOffset=f<0?-i:i):(S.isNull&&(k.width=0),S.minPointLengthOffset=0);y=S.plotY+(S.negative?k.height:0),f=(S.below&&(S.plotY+=k.height),S.tooltipPos&&(e.chart.inverted?S.tooltipPos[0]=a.len-y:S.tooltipPos[1]=y),S.isInside=this.isPointInside(S),crisp(S.yBottom,e.borderWidth));k.y=crisp(k.y,e.borderWidth),k.height=f-k.y,merge(!0,S.shapeArgs,k)}},{order:2}),SeriesRegistry.registerSeriesType("waterfall",WaterfallSeries);export default WaterfallSeries;