"use strict";import H from"../../Core/Globals.js";const{composed,noop}=H;import Color from"../../Core/Color/Color.js";const color=Color["parse"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const ColumnSeries=SeriesRegistry.seriesTypes["column"];import U from"../../Core/Utilities.js";const{addEvent,clamp,crisp,defined,extend,find,isNumber,isObject,merge,pick,pushUnique,relativeLength}=U;import XRangeSeriesDefaults from"./XRangeSeriesDefaults.js";import XRangePoint from"./XRangePoint.js";function onAxisAfterGetSeriesExtremes(){let t,e;if(this.isXAxis){t=pick(this.dataMax,-Number.MAX_VALUE);for(const s of this.series){var i=s.dataTable.getColumn("x2",!0)||s.dataTable.getColumn("end",!0);if(i)for(const r of i)isNumber(r)&&r>t&&(t=r,e=!0)}e&&(this.dataMax=t)}}class XRangeSeries extends ColumnSeries{static compose(t){pushUnique(composed,"Series.XRange")&&addEvent(t,"afterGetSeriesExtremes",onAxisAfterGetSeriesExtremes)}init(){super.init.apply(this,arguments),this.options.stacking=void 0}getColumnMetrics(){var t=()=>{for(const e of this.chart.series){var t=e.xAxis;e.xAxis=e.yAxis,e.yAxis=t}},e=(t(),super.getColumnMetrics());return t(),e}cropData(t,e,i){const s=t.getColumn("x")||[],r=t.getColumn("x2");t.setColumn("x",r,void 0,{silent:!0});e=super.cropData(t,e,i);return t.setColumn("x",s.slice(e.start,e.end),void 0,{silent:!0}),e}findPointIndex(e){var t,{cropStart:i,points:s}=this;const r=e["id"];let o;return r&&(t=find(s,t=>t.id===r),o=t?t.index:void 0),void 0===o&&(t=find(s,t=>t.x===e.x&&t.x2===e.x2&&!t.touched),o=t?t.index:void 0),this.cropped&&isNumber(o)&&isNumber(i)&&o>=i&&(o-=i),o}alignDataLabel(t){var e=t.plotX;t.plotX=pick(t.dlBox?.centerX,t.plotX),t.dataLabel&&t.shapeArgs?.width&&t.dataLabel.css({width:t.shapeArgs.width+"px"}),super.alignDataLabel.apply(this,arguments),t.plotX=e}translatePoint(t){const e=this.xAxis,i=this.yAxis,s=this.columnMetrics,r=this.options,o=r.minPointLength||0,a=(t.shapeArgs?.width||0)/2,n=this.pointXOffset=s.offset,l=pick(t.x2,t.x+(t.len||0)),p=r.borderRadius,h=this.chart.plotTop,c=this.chart.plotLeft;let d=t.plotX,m=e.translate(l,0,0,0,1);var g=Math.abs(m-d),u=this.chart.inverted,x=pick(r.borderWidth,1);let f,y,A=s.offset,C=Math.round(s.width),b,R,v,S;o&&((f=o-g)<0&&(f=0),d-=f/2,m+=f/2),d=Math.max(d,-10),m=clamp(m,-10,e.len+10),defined(t.options.pointWidth)&&(A-=(Math.ceil(t.options.pointWidth)-C)/2,C=Math.ceil(t.options.pointWidth)),r.pointPlacement&&isNumber(t.plotY)&&i.categories&&(t.plotY=i.translate(t.y,0,1,0,1,r.pointPlacement));var X=crisp(Math.min(d,m),x),w=crisp(Math.max(d,m),x)-X,M=Math.min(relativeLength("object"==typeof p?p.radius:p||0,C),Math.min(w,C)/2),X={x:X,y:crisp((t.plotY||0)+A,x),width:w,height:C,r:M};t.shapeArgs=X,u?t.tooltipPos[1]+=n+a:t.tooltipPos[0]-=a+n-X.width/2,b=X.x,R=b+X.width,b<0||R>e.len?(b=clamp(b,0,e.len),v=(R=clamp(R,0,e.len))-b,t.dlBox=merge(X,{x:b,width:R-b,centerX:v?v/2:null})):t.dlBox=null;const P=t.tooltipPos;x=u?1:0,w=u?0:1,M=this.columnMetrics?this.columnMetrics.offset:-s.width/2;u?P[x]+=X.width/2:P[x]=clamp(P[x]+(e.reversed?-1:0)*X.width,e.left-c,e.left+e.len-c-1),P[w]=clamp(P[w]+(u?-1:1)*M,i.top-h,i.top+i.len-h-1),(y=t.partialFill)&&(isObject(y)&&(y=y.amount),isNumber(y)||(y=0),t.partShapeArgs=merge(X),S=Math.max(Math.round(g*y+t.plotX-d),0),t.clipRectArgs={x:e.reversed?X.x+g-S:X.x,y:X.y,width:S,height:X.height}),t.key=t.category||t.name,t.yCategory=i.categories?.[t.y??-1]}translate(){super.translate.apply(this,arguments);for(const t of this.points)this.translatePoint(t)}drawPoint(t,e){const i=this.options,s=this.chart.renderer,r=t.shapeType,o=t.shapeArgs,a=t.partShapeArgs,n=t.clipRectArgs,l=t.state,p=i.states[l||"normal"]||{},h=void 0===l?"attr":e,c=this.pointAttribs(t,l),d=pick(this.chart.options.chart.animation,p.animation);let m=t.graphic,g=t.partialFill;t.isNull||!1===t.visible?m&&(t.graphic=m.destroy()):(m?m.rect[e](o):(t.graphic=m=s.g("point").addClass(t.getClassName()).add(t.group||this.group),m.rect=s[r](merge(o)).addClass(t.getClassName()).addClass("highcharts-partfill-original").add(m)),a&&(m.partRect?(m.partRect[e](merge(a)),m.partialClipRect[e](merge(n))):(m.partialClipRect=s.clipRect(n.x,n.y,n.width,n.height),m.partRect=s[r](a).addClass("highcharts-partfill-overlay").add(m).clip(m.partialClipRect))),this.chart.styledMode||(m.rect[e](c,d).shadow(i.shadow),a&&(isObject(g)||(g={}),e=(g=isObject(i.partialFill)?merge(i.partialFill,g):g).fill||color(c.fill).brighten(-.3).get()||color(t.color||this.color).brighten(-.3).get(),c.fill=e,m.partRect[h](c,d).shadow(i.shadow))))}drawPoints(){var t=this.getAnimationVerb();for(const e of this.points)this.drawPoint(e,t)}getAnimationVerb(){return this.chart.pointCount<(this.options.animationLimit||250)?"animate":"attr"}isPointInside(t){var e=t.shapeArgs,i=t.plotX,t=t.plotY;return e?void 0!==i&&void 0!==t&&0<=t&&t<=this.yAxis.len&&0<=(e.x||0)+(e.width||0)&&i<=this.xAxis.len:super.isPointInside.apply(this,arguments)}}XRangeSeries.defaultOptions=merge(ColumnSeries.defaultOptions,XRangeSeriesDefaults),extend(XRangeSeries.prototype,{pointClass:XRangePoint,pointArrayMap:["x2","y"],getExtremesFromAll:!0,keysAffectYAxis:["y"],parallelArrays:["x","x2","y"],requireSorting:!1,type:"xrange",animate:SeriesRegistry.series.prototype.animate,autoIncrement:noop,buildKDTree:noop}),SeriesRegistry.registerSeriesType("xrange",XRangeSeries);export default XRangeSeries;