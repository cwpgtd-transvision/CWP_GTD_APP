"use strict";import F from"../../Core/Templating.js";import H from"../../Core/Globals.js";const noop=H["noop"];import U from"../../Core/Utilities.js";const{arrayMax,arrayMin,isNumber,merge,pick,stableSort}=U;class BubbleLegendItem{constructor(e,t){this.setState=noop,this.init(e,t)}init(e,t){this.options=e,this.visible=!0,this.chart=t.chart,this.legend=t}addToLegend(e){e.splice(this.options.legendIndex,0,this)}drawLegendSymbol(e){const t=pick(e.options.itemDistance,20),s=this.legendItem||{},i=this.options,o=i.ranges,n=i.connectorDistance;let l;var r,a,h;o&&o.length&&isNumber(o[0].value)?(stableSort(o,function(e,t){return t.value-e.value}),this.ranges=o,this.setOptions(),this.render(),r=this.getMaxLabelSize(),h=2*(a=this.ranges[0].radius),l=0<(l=n-a+r.width)?l:0,this.maxLabel=r,this.movementX="left"===i.labels.align?l:0,s.labelWidth=h+l+t,s.labelHeight=h+r.height/2):e.options.bubbleLegend.autoRanges=!0}setOptions(){const s=this.ranges,i=this.options,o=this.chart.series[i.seriesIndex],n=this.legend.baseline,l={zIndex:i.zIndex,"stroke-width":i.borderWidth},r={zIndex:i.zIndex,"stroke-width":i.connectorWidth},a={align:this.legend.options.rtl||"left"===i.labels.align?"right":"left",zIndex:i.zIndex},h=o.options.marker.fillOpacity,c=this.chart.styledMode;s.forEach(function(e,t){c||(l.stroke=pick(e.borderColor,i.borderColor,o.color),l.fill=e.color||i.color,l.fill||(l.fill=o.color,l["fill-opacity"]=h??1),r.stroke=pick(e.connectorColor,i.connectorColor,o.color)),s[t].radius=this.getRangeRadius(e.value),s[t]=merge(s[t],{center:s[0].radius-s[t].radius+n}),c||merge(!0,s[t],{bubbleAttribs:merge(l),connectorAttribs:merge(r),labelAttribs:a})},this)}getRangeRadius(e){const t=this.options,s=this.options.seriesIndex,i=this.chart.series[s],o=t.ranges[0].value,n=t.ranges[t.ranges.length-1].value,l=t.minSize,r=t.maxSize;return i.getRadius.call(this,n,o,l,r,e)}render(){const e=this.legendItem||{},t=this.chart.renderer,s=this.options.zThreshold;this.symbols||(this.symbols={connectors:[],bubbleItems:[],labels:[]}),e.symbol=t.g("bubble-legend"),e.label=t.g("bubble-legend-item").css(this.legend.itemStyle||{}),e.symbol.translateX=0,e.symbol.translateY=0,e.symbol.add(e.label),e.label.add(e.group);for(const i of this.ranges)i.value>=s&&this.renderRange(i);this.hideOverlappingLabels()}renderRange(e){const t=this.ranges[0],s=this.legend,i=this.options,o=i.labels,n=this.chart,l=n.series[i.seriesIndex],r=n.renderer,a=this.symbols,h=a.labels,c=e.center,b=Math.abs(e.radius),d=i.connectorDistance||0,g=o.align,m=s.options.rtl,p=i.borderWidth,u=i.connectorWidth,x=t.radius||0,f=c-b-p/2+u/2,y=(f%1?1:.5)-(u%2?0:.5),z=r.styledMode;let M=m||"left"===g?-d:d;"center"===g&&(M=0,i.connectorDistance=0,e.labelAttribs.align="center"),a.bubbleItems.push(r.circle(x,c+y,b).attr(z?{}:e.bubbleAttribs).addClass((z?"highcharts-color-"+l.colorIndex+" ":"")+"highcharts-bubble-legend-symbol "+(i.className||"")).add(this.legendItem.symbol)),a.connectors.push(r.path(r.crispLine([["M",x,f],["L",x+M,f]],i.connectorWidth)).attr(z?{}:e.connectorAttribs).addClass((z?"highcharts-color-"+this.options.seriesIndex+" ":"")+"highcharts-bubble-legend-connectors "+(i.connectorClassName||"")).add(this.legendItem.symbol));const I=r.text(this.formatLabel(e)).attr(z?{}:e.labelAttribs).css(z?{}:o.style).addClass("highcharts-bubble-legend-labels "+(i.labels.className||"")).add(this.legendItem.symbol);e={x:x+M+i.labels.x,y:f+i.labels.y+.4*I.getBBox().height};I.attr(e),h.push(I),I.placed=!0,I.alignAttr=e}getMaxLabelSize(){const e=this.symbols.labels;let t,s;return e.forEach(function(e){s=e.getBBox(!0),t=!t||s.width>t.width?s:t}),t||{}}formatLabel(e){const t=this.options,s=t.labels.formatter,i=t.labels.format,o=this.chart["numberFormatter"];return i?F.format(i,e,this.chart):s?s.call(e):o(e.value,1)}hideOverlappingLabels(){const e=this.chart,t=this.options.labels.allowOverlap,s=this.symbols;!t&&s&&(e.hideOverlappingLabels(s.labels),s.labels.forEach(function(e,t){e.newOpacity?e.newOpacity!==e.oldOpacity&&s.connectors[t].show():s.connectors[t].hide()}))}getRanges(){const e=this.legend.bubbleLegend,t=e.chart.series,s=e.options.ranges;let i,o,n=Number.MAX_VALUE,l=-Number.MAX_VALUE;return t.forEach(function(e){e.isBubble&&!e.ignoreSeries&&(o=e.getColumn("z").filter(isNumber)).length&&(n=pick(e.options.zMin,Math.min(n,Math.max(arrayMin(o),!1===e.options.displayNegative?e.options.zThreshold:-Number.MAX_VALUE))),l=pick(e.options.zMax,Math.max(l,arrayMax(o))))}),i=n===l?[{value:l}]:[{value:n},{value:(n+l)/2},{value:l,autoRanges:!0}],s.length&&s[0].radius&&i.reverse(),i.forEach(function(e,t){s&&s[t]&&(i[t]=merge(s[t],e))}),i}predictBubbleSizes(){const e=this.chart,t=e.legend.options,s=t.floating,i="horizontal"===t.layout,o=i?e.legend.lastLineHeight:0,n=e.plotSizeX,l=e.plotSizeY,r=e.series[this.options.seriesIndex],a=r.getPxExtremes(),h=Math.ceil(a.minPxSize),c=Math.ceil(a.maxPxSize),b=Math.min(l,n);let d,g=r.options.maxSize;return s||!/%$/.test(g)?d=c:(g=parseFloat(g),d=(b+o)*g/100/(g/100+1),(i&&l-d>=n||!i&&n-d>=l)&&(d=c)),[h,Math.ceil(d)]}updateRanges(e,t){const s=this.legend.options.bubbleLegend;s.minSize=e,s.maxSize=t,s.ranges=this.getRanges()}correctSizes(){const e=this.legend,t=this.chart,s=t.series[this.options.seriesIndex],i=s.getPxExtremes(),o=i.maxPxSize,n=this.options.maxSize;1<Math.abs(Math.ceil(o)-n)&&(this.updateRanges(this.options.minSize,i.maxPxSize),e.render())}}export default BubbleLegendItem;