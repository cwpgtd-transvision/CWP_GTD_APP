"use strict";import DataTable from"../../Data/DataTable.js";import H from"../Globals.js";const composed=H["composed"];import U from"../Utilities.js";const{addEvent,fireEvent,isNumber,merge,pushUnique,wrap}=U;function wrapSeriesGeneratePoints(t){if(this.hasGroupedData)return t.call(this);const s=this.pointClass,n=this.cropStart||0,i=this.data||[],a=[],o=this.getColumn("x",!0),r=this.getColumn("y",!0);let l,h;for(let t=0,e=o.length;t<e;++t)l=n+t,(h=(h=i[l])||(i[l]=new s(this,r[l],o[t]))).index=l,a[t]=h;this.data=i,this.points=a,fireEvent(this,"afterGeneratePoints")}function wrapSeriesSetData(t,s=[],e=!0,n){const i=this.datas;if(this.hasGroupedData||!this.options.dataAsColumns)return t.call(this,s,e,n);s=this.options.data=this.userOptions.data=this.chart.options.chart.allowMutatingData?s||[]:merge(!0,s);const a={},o=(this.options.keys||this.parallelArrays).slice();if(isNumber(s[0])||1===o.length){const r=a.x=[];for(let t=0,e=s.length;t<e;++t)r.push(this.autoIncrement());a[o[1]||"y"]=s}else{if(-1===o.indexOf("x")&&o.length>s.length){const l=a.x=[];for(let t=0,e=s.length;t<e;++t)l.push(this.autoIncrement())}for(let t=0,e=Math.min(s.length,o.length);t<e;++t)s[t]instanceof Array&&(a[o[t]]=s[t])}i.setTable(new DataTable({columns:a,id:this.name}))}class DataSeriesAdditions{static compose(t){var e;pushUnique(composed,"Core.DataSeries")&&(e=t.prototype,addEvent(t,"init",function(){this.datas=new DataSeriesAdditions(this)}),wrap(e,"generatePoints",wrapSeriesGeneratePoints),wrap(e,"setData",wrapSeriesSetData))}constructor(t){this.unlisteners=[];const s={},n=t.parallelArrays;for(let t=0,e=n.length;t<e;++t)s[n[t]]=[];this.series=t,this.table=new DataTable}processTable(t,e){const s=this.series;if("point"===s.options.legendType&&(s.processData(),s.generatePoints()),t){const n=s.chart;s.isDirty=n.isDirtyBox=!0,s.isDirtyData=!0,n.redraw(e)}}setTable(n,t=!0,e){const s=this.series,i=s,a=s.points,o=s.parallelArrays,r=n.getRowCount();let l;if(a){const p=s.xAxis;s.colorCounter=0,s.data=[],delete i.points,delete i.processedXData,delete i.processedYData,delete i.xIncrement;for(let t=0,e=o.length;t<e;++t)l=o[t],i[l+"Data"]=[];for(let t=0,e=a.length;t<e;++t)a[t]&&a[t].destroy&&a[t].destroy();p&&(p.minRange=p.userMinRange)}let h,f=!1,c=!1;for(let t=0,e=o.length;t<e;++t){if(l=o[t],!(h=n.getColumn(l,!0))){if("x"===l){c=!0;continue}f=!0;break}i[l+"Data"]=h}if(f){const d=n.getColumnNames(),u=[];u.length=r;let s=0;d.length===o.length-1&&(s=1,c=!0);for(let t=s,e=o.length;t<e;++t)h=n.getColumn(d[t],!0),l=o[t],i[l+"Data"]=h||u.slice()}if((this.indexAsX=c)&&-1!==o.indexOf("x")){h=[];for(let t=0;t<r;++t)h.push(s.autoIncrement());i.xData=h}this.syncOff(),this.table=n,t&&this.syncOn(),this.processTable(t,a&&e)}syncOff(){const s=this.unlisteners;for(let t=0,e=s.length;t<e;++t)s[t]();s.length=0}syncOn(){if(!this.unlisteners.length){const n=this.series,t=this.table,i=n,e=s=>{if("afterDeleteColumns"===s.type)this.setTable(t,!0);else{if("afterDeleteRows"===s.type){if(0<s.rowIndex&&s.rowIndex+s.rowCount<n.points.length)return void this.setTable(t,!0);for(let t=s.rowIndex,e=t+s.rowCount;t<e;++t)n.removePoint(t,!1)}if(this.indexAsX)if("afterSetCell"===s.type)i.xData[s.rowIndex]=s.rowIndex;else if("afterSetRows"===s.type)for(let t=s.rowIndex,e=t+s.rowCount;t<e;++t)i.xData[t]=n.autoIncrement();this.processTable(!0)}};this.unlisteners.push(t.on("afterDeleteColumns",e),t.on("afterDeleteRows",e),t.on("afterSetCell",e),t.on("afterSetRows",e))}}}export default DataSeriesAdditions;