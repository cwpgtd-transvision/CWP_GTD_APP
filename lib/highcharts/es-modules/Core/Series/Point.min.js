"use strict";import AST from"../Renderer/HTML/AST.js";import A from"../Animation/AnimationUtilities.js";const animObject=A["animObject"];import D from"../Defaults.js";const defaultOptions=D["defaultOptions"];import F from"../Templating.js";const format=F["format"];import U from"../Utilities.js";const{addEvent,crisp,erase,extend,fireEvent,getNestedProperty,isArray,isFunction,isNumber,isObject,merge,pick,syncTimeout,removeEvent,uniqueKey}=U;class Point{animateBeforeDestroy(){const s=this,o={x:s.startXPos,opacity:0},t=s.getGraphicalProps();t.singular.forEach(function(t){var e="dataLabel"===t;s[t]=s[t].animate(e?{x:s[t].startXPos,y:s[t].startYPos,opacity:0}:o)}),t.plural.forEach(function(t){s[t].forEach(function(t){t.element&&t.animate(extend({x:s.startXPos},t.startYPos?{x:t.startXPos,y:t.startYPos}:{}))})})}applyOptions(t,e){const s=this,o=s.series,i=o.options.pointValKey||o.pointValKey;return t=Point.prototype.optionsToObject.call(this,t),extend(s,t),s.options=s.options?extend(s.options,t):t,t.group&&delete s.group,t.dataLabels&&delete s.dataLabels,i&&(s.y=Point.prototype.getNestedProperty.call(s,i)),s.selected&&(s.state="select"),"name"in s&&void 0===e&&o.xAxis&&o.xAxis.hasNames&&(s.x=o.xAxis.nameToX(s)),void 0===s.x&&o?s.x=e??o.autoIncrement():isNumber(t.x)&&o.options.relativeXValue?s.x=o.autoIncrement(t.x):"string"==typeof s.x&&(e=e??o.chart.time.parse(s.x),isNumber(e)&&(s.x=e)),s.isNull=this.isValid&&!this.isValid(),s.formatPrefix=s.isNull?"null":"point",s}destroy(){if(!this.destroyed){const e=this,s=e.series,o=s.chart,i=s.options.dataSorting,a=o.hoverPoints,r=e.series.chart.renderer.globalAnimation,n=animObject(r);var t=()=>{(e.graphic||e.graphics||e.dataLabel||e.dataLabels)&&(removeEvent(e),e.destroyElements());for(const t in e)delete e[t]};e.legendItem&&o.legend.destroyItem(e),a&&(e.setState(),erase(a,e),a.length||(o.hoverPoints=null)),e===o.hoverPoint&&e.onMouseOut(),i?.enabled?(this.animateBeforeDestroy(),syncTimeout(t,n.duration)):t(),o.pointCount--}this.destroyed=!0}destroyElements(t){const e=this,s=e.getGraphicalProps(t);s.singular.forEach(function(t){e[t]=e[t].destroy()}),s.plural.forEach(function(t){e[t].forEach(function(t){t?.element&&t.destroy()}),delete e[t]})}firePointEvent(t,e,s){const o=this,i=this.series,a=i.options;o.manageEvent(t),"click"===t&&a.allowPointSelect&&(s=function(t){!o.destroyed&&o.select&&o.select(null,t.ctrlKey||t.metaKey||t.shiftKey)}),fireEvent(o,t,e,s)}getClassName(){var t=this;return"highcharts-point"+(t.selected?" highcharts-point-select":"")+(t.negative?" highcharts-negative":"")+(t.isNull?" highcharts-null-point":"")+(void 0!==t.colorIndex?" highcharts-color-"+t.colorIndex:"")+(t.options.className?" "+t.options.className:"")+(t.zone?.className?" "+t.zone.className.replace("highcharts-negative",""):"")}getGraphicalProps(s){const o=this,t=[],i={singular:[],plural:[]};let e,a;for((s=s||{graphic:1,dataLabel:1}).graphic&&t.push("graphic","connector"),s.dataLabel&&t.push("dataLabel","dataLabelPath","dataLabelUpper"),a=t.length;a--;)e=t[a],o[e]&&i.singular.push(e);return["graphic","dataLabel"].forEach(function(t){var e=t+"s";s[t]&&o[e]&&i.plural.push(e)}),i}getNestedProperty(t){if(t)return 0===t.indexOf("custom.")?getNestedProperty(t,this.options):this[t]}getZone(){var t=this.series,e=t.zones,s=t.zoneAxis||"y";let o,i=0;for(o=e[i];this[s]>=o.value;)o=e[++i];return this.nonZonedColor||(this.nonZonedColor=this.color),o?.color&&!this.options.color?this.color=o.color:this.color=this.nonZonedColor,o}hasNewShapeType(){var t=this;return(t.graphic&&(t.graphic.symbolName||t.graphic.element.nodeName))!==this.shapeType}constructor(t,e,s){this.formatPrefix="point",this.visible=!0,(this.point=this).series=t,this.applyOptions(e,s),this.id??(this.id=uniqueKey()),this.resolveColor(),this.dataLabelOnNull??(this.dataLabelOnNull=t.options.nullInteraction),t.chart.pointCount++,fireEvent(this,"afterInit")}isValid(){return(isNumber(this.x)||this.x instanceof Date)&&isNumber(this.y)}optionsToObject(t){const e=this.series,s=e.options.keys,o=s||e.pointArrayMap||["y"],i=o.length;let a={},r,n=0,l=0;if(isNumber(t)||null===t)a[o[0]]=t;else if(isArray(t))for(!s&&t.length>i&&("string"==(r=typeof t[0])?e.xAxis?.dateTime?a.x=e.chart.time.parse(t[0]):a.name=t[0]:"number"==r&&(a.x=t[0]),n++);l<i;)s&&void 0===t[n]||(0<o[l].indexOf(".")?Point.prototype.setNestedProperty(a,t[n],o[l]):a[o[l]]=t[n]),n++,l++;else"object"==typeof t&&((a=t).dataLabels&&(e.hasDataLabels=()=>!0),t.marker&&(e._hasPointMarkers=!0));return a}pos(s,o=this.plotY){if(!this.destroyed){var{plotX:i,series:a}=this,{chart:a,xAxis:r,yAxis:n}=a;let t=0,e=0;if(isNumber(i)&&isNumber(o))return s&&(t=r?r.pos:a.plotLeft,e=n?n.pos:a.plotTop),a.inverted&&r&&n?[n.len-o+e,r.len-i+t]:[i+t,o+e]}}resolveColor(){const t=this.series,e=t.chart.options.chart,s=t.chart.styledMode;let o,i,a=e.colorCount,r;delete this.nonZonedColor,t.options.colorByPoint?(s||(i=t.options.colors||t.chart.options.colors,o=i[t.colorCounter],a=i.length),r=t.colorCounter,t.colorCounter++,t.colorCounter===a&&(t.colorCounter=0)):(s||(o=t.color),r=t.colorIndex),this.colorIndex=pick(this.options.colorIndex,r),this.color=pick(this.options.color,o)}setNestedProperty(t,i,e){const s=e.split(".");return s.reduce(function(t,e,s,o){o=o.length-1===s;return t[e]=o?i:isObject(t[e],!0)?t[e]:{},t[e]},t),t}shouldDraw(){return!this.isNull}tooltipFormatter(e){const{chart:t,pointArrayMap:s=["y"],tooltipOptions:o}=this.series,{valueDecimals:i="",valuePrefix:a="",valueSuffix:r=""}=o;return t.styledMode&&(e=t.tooltip?.styledModeFormat(e)||e),s.forEach(t=>{t="{point."+t,e=(e=a||r?e.replace(RegExp(t+"}","g"),a+t+"}"+r):e).replace(RegExp(t+"}","g"),t+":,."+i+"f}")}),format(e,this,t)}update(o,i,a,t){const r=this,n=r.series,l=r.graphic,c=n.chart,h=n.options;let p;function e(){r.applyOptions(o);var t=l&&r.hasMockGraphic,t=null===r.y?!t:t;l&&t&&(r.graphic=l.destroy(),delete r.hasMockGraphic),isObject(o,!0)&&(l?.element&&o&&o.marker&&void 0!==o.marker.symbol&&(r.graphic=l.destroy()),o?.dataLabels&&r.dataLabel&&(r.dataLabel=r.dataLabel.destroy())),p=r.index;const e={};for(const s of n.dataColumnKeys())e[s]=r[s];n.dataTable.setRow(e,p),h.data[p]=isObject(h.data[p],!0)||isObject(o,!0)?r.options:pick(o,h.data[p]),n.isDirty=n.isDirtyData=!0,!n.fixedBox&&n.hasCartesianSeries&&(c.isDirtyBox=!0),"point"===h.legendType&&(c.isDirtyLegend=!0),i&&c.redraw(a)}i=pick(i,!0),!1===t?e():r.firePointEvent("update",{options:o},e)}remove(t,e){this.series.removePoint(this.series.data.indexOf(this),t,e)}select(t,e){const s=this,o=s.series,i=o.chart;t=pick(t,!s.selected),this.selectedStaging=t,s.firePointEvent(t?"select":"unselect",{accumulate:e},function(){s.selected=s.options.selected=t,o.options.data[o.data.indexOf(s)]=s.options,s.setState(t&&"select"),e||i.getSelectedPoints().forEach(function(t){const e=t.series;t.selected&&t!==s&&(t.selected=t.options.selected=!1,e.options.data[e.data.indexOf(t)]=t.options,t.setState(i.hoverPoints&&e.options.inactiveOtherPoints?"inactive":""),t.firePointEvent("unselect"))})}),delete this.selectedStaging}onMouseOver(t){const e=this.series,{inverted:s,pointer:o}=e.chart;o&&(t=t?o.normalize(t):o.getChartCoordinatesFromPoint(this,s),o.runPointActions(t,this))}onMouseOut(){const t=this.series.chart;this.firePointEvent("mouseOut"),this.series.options.inactiveOtherPoints||(t.hoverPoints||[]).forEach(function(t){t.setState()}),t.hoverPoints=t.hoverPoint=null}manageEvent(t){var e=this,s=merge(e.series.options.point,e.options).events?.[t];!isFunction(s)||e.hcEvents?.[t]&&-1!==e.hcEvents?.[t]?.map(t=>t.fn).indexOf(s)?e.importedUserEvent&&!s&&e.hcEvents?.[t]&&e.hcEvents?.[t].userEvent&&(removeEvent(e,t),delete e.hcEvents[t],Object.keys(e.hcEvents)||delete e.importedUserEvent):(e.importedUserEvent?.(),e.importedUserEvent=addEvent(e,t,s),e.hcEvents&&(e.hcEvents[t].userEvent=!0))}setState(t,e){const s=this,o=s.series,i=s.state,a=o.options.states[t||"normal"]||{},r=defaultOptions.plotOptions[o.type].marker&&o.options.marker,n=r&&!1===r.enabled,l=r?.states?.[t||"normal"]||{},c=!1===l.enabled,h=s.marker||{},p=o.chart,d=r&&o.markerAttribs;let u=o.halo,m,y,f,v=o.stateMarkerGraphic,g;if(!((t=t||"")===s.state&&!e||s.selected&&"select"!==t||!1===a.enabled||t&&(c||n&&!1===l.enabled)||t&&h.states&&h.states[t]&&!1===h.states[t].enabled)){if(s.state=t,d&&(m=o.markerAttribs(s,t)),s.graphic&&!s.hasMockGraphic){if(i&&s.graphic.removeClass("highcharts-point-"+i),t&&s.graphic.addClass("highcharts-point-"+t),!p.styledMode){y=o.pointAttribs(s,t),f=pick(p.options.chart.animation,a.animation);const E=y.opacity;o.options.inactiveOtherPoints&&isNumber(E)&&(s.dataLabels||[]).forEach(function(t){t&&!t.hasClass("highcharts-data-label-hidden")&&(t.animate({opacity:E},f),t.connector&&t.connector.animate({opacity:E},f))}),s.graphic.animate(y,f)}m&&s.graphic.animate(m,pick(p.options.chart.animation,l.animation,r.animation)),v&&v.hide()}else t&&l&&(g=h.symbol||o.symbol,v&&v.currentSymbol!==g&&(v=v.destroy()),m&&(v?v[e?"animate":"attr"]({x:m.x,y:m.y}):g&&(o.stateMarkerGraphic=v=p.renderer.symbol(g,m.x,m.y,m.width,m.height,merge(r,l)).add(o.markerGroup),v.currentSymbol=g)),!p.styledMode&&v&&"inactive"!==s.state&&v.attr(o.pointAttribs(s,t))),v&&(v[t&&s.isInside?"show":"hide"](),v.element.point=s,v.addClass(s.getClassName(),!0));var b=a.halo,x=s.graphic||v,P=x?.visibility||"inherit";b?.size&&x&&"hidden"!==P&&!s.isCluster?(u||(o.halo=u=p.renderer.path().add(x.parentGroup)),u.show()[e?"animate":"attr"]({d:s.haloPath(b.size)}),u.attr({class:"highcharts-halo highcharts-color-"+pick(s.colorIndex,o.colorIndex)+(s.className?" "+s.className:""),visibility:P,zIndex:-1}),u.point=s,p.styledMode||u.attr(extend({fill:s.color||o.color,"fill-opacity":b.opacity},AST.filterUserAttributes(b.attributes||{})))):u?.point?.haloPath&&!u.point.destroyed&&u.animate({d:u.point.haloPath(0)},null,u.hide),fireEvent(s,"afterSetState",{state:t})}}haloPath(t){var e=this.pos();return e?this.series.chart.renderer.symbols.circle(crisp(e[0],1)-t,e[1]-t,2*t,2*t):[]}}export default Point;