"use strict";import A from"../../Animation/AnimationUtilities.js";const getDeferredAnimation=A["getDeferredAnimation"];import Axis from"../Axis.js";import SeriesRegistry from"../../Series/SeriesRegistry.js";const{prototype:seriesProto}=SeriesRegistry["series"];import StackItem from"./StackItem.js";import U from"../../Utilities.js";const{addEvent,correctFloat,defined,destroyObjectProperties,fireEvent,isNumber,objectEach,pick}=U;function chartGetStacks(){const t=this,s=t.inverted;t.axes.forEach(t=>{t.stacking?.stacks&&t.hasVisibleSeries&&(t.stacking.oldStacks=t.stacking.stacks)}),t.series.forEach(t=>{const e=t.xAxis?.options||{};t.options.stacking&&t.reserveSpace()&&(t.stackKey=[t.type,pick(t.options.stack,""),s?e.top:e.left,s?e.height:e.width].join(","))})}function onAxisDestroy(){const t=this.stacking;if(t){const s=t.stacks;objectEach(s,(t,e)=>{destroyObjectProperties(t),delete s[e]}),t.stackTotalGroup?.destroy()}}function onAxisInit(){this.stacking||(this.stacking=new AxisAdditions(this))}function seriesGetStackIndicator(t,e,s,i){return!defined(t)||t.x!==e||i&&t.stackKey!==i?t={x:e,index:0,key:i,stackKey:i}:t.index++,t.key=[s,e,t.index].join(","),t}function seriesModifyStacks(){const c=this,t=c.yAxis,e=c.stackKey||"",a=t.stacking.stacks,n=c.getColumn("x",!0),s=c.options.stacking,r=c[s+"Stacker"];let k;r&&[e,"-"+e].forEach(t=>{let e=n.length,s,i,o;for(;e--;)s=n[e],k=c.getStackIndicator(k,s,c.index,t),(o=(i=a[t]?.[s])?.points[k.key||""])&&r.call(c,o,i,e)})}function seriesPercentStacker(t,e,s){e=e.total?100/e.total:0;t[0]=correctFloat(t[0]*e),t[1]=correctFloat(t[1]*e),this.stackedYData[s]=t[1]}function seriesSetGroupedPoints(t){(this.is("column")||this.is("columnrange"))&&(this.options.centerInCategory&&1<this.chart.series.length?seriesProto.setStackedPoints.call(this,t,"group"):t.stacking.resetStacks())}function seriesSetStackedPoints(r,t){var k=t||this.options.stacking;if(k&&this.reserveSpace()&&({group:"xAxis"}[k]||"yAxis")===r.coll){const u=this,p=u.getColumn("x",!0),S=u.getColumn(u.pointValKey||"y",!0),g=[],m=S.length,f=u.options,x=f.threshold||0,y=f.startFromThreshold?x:0,A=f.stack,b=t?u.type+","+k:u.stackKey||"",v="-"+b,P=u.negStacks,j=r.stacking,E=j.stacks,I=j.oldStacks;let e,s,i,o,c,a,n;for(j.stacksTouched+=1,n=0;n<m;n++){var l=p[n]||0,d=S[n],h=isNumber(d)&&d||0;a=(e=u.getStackIndicator(e,l,u.index)).key||"",c=(s=P&&h<(y?0:x))?v:b,E[c]||(E[c]={}),E[c][l]||(I[c]?.[l]?(E[c][l]=I[c][l],E[c][l].total=null):E[c][l]=new StackItem(r,r.options.stackLabels,!!s,l,A)),i=E[c][l],null!==d?(i.points[a]=i.points[u.index]=[pick(i.cumulative,y)],defined(i.cumulative)||(i.base=a),i.touched=j.stacksTouched,0<e.index&&!1===u.singleStacks&&(i.points[a][0]=i.points[u.index+","+l+",0"][0])):(delete i.points[a],delete i.points[u.index]);let t=i.total||0;"percent"===k?(o=s?b:v,t=P&&E[o]?.[l]?(o=E[o][l]).total=Math.max(o.total||0,t)+Math.abs(h):correctFloat(t+Math.abs(h))):"group"===k?isNumber(d)&&t++:t=correctFloat(t+h),i.cumulative="group"===k?(t||1)-1:correctFloat(pick(i.cumulative,y)+h),i.total=t,null!==d&&(i.points[a].push(i.cumulative),g[n]=i.cumulative,i.hasValidPoints=!0)}"percent"===k&&(j.usePercentage=!0),"group"!==k&&(this.stackedYData=g),j.oldStacks={}}}class AxisAdditions{constructor(t){this.oldStacks={},this.stacks={},this.stacksTouched=0,this.axis=t}buildStacks(){const t=this.axis,e=t.series,s="xAxis"===t.coll,i=t.options.reversedStacks,o=e.length;let c,a;for(this.resetStacks(),this.usePercentage=!1,a=o;a--;)c=e[i?a:o-a-1],s&&c.setGroupedPoints(t),c.setStackedPoints(t);if(!s)for(a=0;a<o;a++)e[a].modifyStacks();fireEvent(t,"afterBuildStacks")}cleanStacks(){this.oldStacks&&(this.stacks=this.oldStacks,objectEach(this.stacks,t=>{objectEach(t,t=>{t.cumulative=t.total})}))}resetStacks(){objectEach(this.stacks,s=>{objectEach(s,(t,e)=>{isNumber(t.touched)&&t.touched<this.stacksTouched?(t.destroy(),delete s[e]):(t.total=null,t.cumulative=null)})})}renderStackTotals(){const t=this.axis,e=t.chart,s=e.renderer,i=this.stacks,o=t.options.stackLabels?.animation,c=getDeferredAnimation(e,o||!1),a=this.stackTotalGroup=this.stackTotalGroup||s.g("stack-labels").attr({zIndex:6,opacity:0}).add();a.translate(e.plotLeft,e.plotTop),objectEach(i,t=>{objectEach(t,t=>{t.render(a)})}),a.animate({opacity:1},c)}}var StackingAxis;(StackingAxis||(StackingAxis={})).compose=function(t,e,s){const i=e.prototype,o=s.prototype;i.getStacks||(addEvent(t,"init",onAxisInit),addEvent(t,"destroy",onAxisDestroy),i.getStacks=chartGetStacks,o.getStackIndicator=seriesGetStackIndicator,o.modifyStacks=seriesModifyStacks,o.percentStacker=seriesPercentStacker,o.setGroupedPoints=seriesSetGroupedPoints,o.setStackedPoints=seriesSetStackedPoints)};export default StackingAxis;