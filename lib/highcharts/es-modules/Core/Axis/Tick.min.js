"use strict";import F from"../Templating.js";import H from"../Globals.js";const deg2rad=H["deg2rad"];import U from"../Utilities.js";const{clamp,correctFloat,defined,destroyObjectProperties,extend,fireEvent,getAlignFactor,isNumber,merge,objectEach,pick}=U;class Tick{constructor(t,e,i,a,s){this.isNew=!0,this.isNewLabel=!0,this.axis=t,this.pos=e,this.type=i||"",this.parameters=s||{},this.tickmarkOffset=this.parameters.tickmarkOffset,this.options=this.parameters.options,fireEvent(this,"init"),i||a||this.addLabel()}addLabel(){const t=this,e=t.axis,i=e.options,a=e.chart,s=e.categories,r=e.logarithmic,o=e.names,l=t.pos,d=pick(t.options?.labels,i.labels),n=e.tickPositions,h=l===n[0],c=l===n[n.length-1],m=(!d.step||1===d.step)&&1===e.tickInterval,b=n.info;let p=t.label,f,g,L,k=this.parameters.category||(s?pick(s[l],o[l],l):l);r&&isNumber(k)&&(k=correctFloat(r.lin2log(k))),e.dateTime&&(b?(g=a.time.resolveDTLFormat(i.dateTimeLabelFormats[!i.grid?.enabled&&b.higherRanks[l]||b.unitName]),f=g.main):isNumber(k)&&(f=e.dateTime.getXDateFormat(k,i.dateTimeLabelFormats||{}))),t.isFirst=h,t.isLast=c;const x={axis:e,chart:a,dateTimeLabelFormat:f,isFirst:h,isLast:c,pos:l,tick:t,tickPositionInfo:b,value:k},y=(fireEvent(this,"labelFormat",x),t=>d.formatter?d.formatter.call(t,t):d.format?(t.text=e.defaultLabelFormatter.call(t),F.format(d.format,t,a)):e.defaultLabelFormatter.call(t));var v=y.call(x,x);const u=g?.list;u?t.shortenLabel=function(){for(L=0;L<u.length;L++)if(extend(x,{dateTimeLabelFormat:u[L]}),p.attr({text:y.call(x,x)}),p.getBBox().width<e.getSlotWidth(t)-2*(d.padding||0))return;p.attr({text:""})}:t.shortenLabel=void 0,m&&e._addedPlotLB&&t.moveLabel(v,d),defined(p)||t.movedLabel?p&&p.textStr!==v&&!m&&(!p.textWidth||d.style.width||p.styles.width||p.css({width:null}),p.attr({text:v}),p.textPxLength=p.getBBox().width):(t.label=p=t.createLabel(v,d),t.rotation=0)}createLabel(t,e,i){const a=this.axis,{renderer:s,styledMode:r}=a.chart,o=e.style.whiteSpace,l=defined(t)&&e.enabled?s.text(t,i?.x,i?.y,e.useHTML).add(a.labelGroup):void 0;return l&&(r||l.css(merge(e.style)),l.textPxLength=l.getBBox().width,!r&&o&&l.css({whiteSpace:o})),l}destroy(){destroyObjectProperties(this,this.axis)}getPosition(t,e,i,a){const s=this.axis,r=s.chart,o=a&&r.oldChartHeight||r.chartHeight,l={x:t?correctFloat(s.translate(e+i,void 0,void 0,a)+s.transB):s.left+s.offset+(s.opposite?(a&&r.oldChartWidth||r.chartWidth)-s.right-s.left:0),y:t?o-s.bottom+s.offset-(s.opposite?s.height:0):correctFloat(o-s.translate(e+i,void 0,void 0,a)-s.transB)};return l.y=clamp(l.y,-1e9,1e9),fireEvent(this,"afterGetPosition",{pos:l}),l}getLabelPosition(t,e,i,a,s,r,o,l){const d=this.axis,n=d.transA,h=(d.isLinked&&d.linkedParent?d.linkedParent:d).reversed,c=d.staggerLines,m=d.tickRotCorr||{x:0,y:0},b=a||d.reserveSpaceDefault?0:-d.labelOffset*("center"===d.labelAlign?.5:1),p=s.distance,f={};let g,L;return g=0===d.side?i.rotation?-p:-i.getBBox().height:2===d.side?m.y+p:Math.cos(i.rotation*deg2rad)*(m.y-i.getBBox(!1,0).height/2),defined(s.y)&&(g=0===d.side&&d.horiz?s.y+g:s.y),t=t+pick(s.x,[0,1,0,-1][d.side]*p)+b+m.x-(r&&a?r*n*(h?-1:1):0),e=e+g-(r&&!a?r*n*(h?1:-1):0),c&&(L=o/(l||1)%c,e+=(L=d.opposite?c-L-1:L)*(d.labelOffset/c)),f.x=t,f.y=Math.round(e),fireEvent(this,"afterGetLabelPosition",{pos:f,tickmarkOffset:r,index:o}),f}getLabelSize(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0}getMarkPath(t,e,i,a,s=!1,r){return r.crispLine([["M",t,e],["L",t+(s?0:-i),e+(s?i:0)]],a)}handleOverflow(t){const e=this.axis,i=e.options.labels,a=t.x,s=e.chart.chartWidth,r=e.chart.spacing,o=pick(e.labelLeft,Math.min(e.pos,r[3])),l=pick(e.labelRight,Math.max(e.isRadial?0:e.pos+e.len,s-r[1])),d=this.label,n=this.rotation,h=getAlignFactor(e.labelAlign||d.attr("align")),c=d.getBBox().width,m=e.getSlotWidth(this),b=h;let p=m,f=1,g;n||"justify"!==i.overflow?n<0&&a-h*c<o?g=Math.round(a/Math.cos(n*deg2rad)-o):0<n&&l<a+h*c&&(g=Math.round((s-a)/Math.cos(n*deg2rad))):(a-h*c<o?p=t.x+p*(1-h)-o:l<a+(1-h)*c&&(p=l-t.x+p*h,f=-1),(p=Math.min(m,p))<m&&"center"===e.labelAlign&&(t.x+=f*(m-p-b*(m-Math.min(c,p)))),(c>p||e.autoRotation&&d?.styles?.width)&&(g=p)),g&&d&&(this.shortenLabel?this.shortenLabel():d.css(extend({},{width:Math.floor(g)+"px",lineClamp:e.isRadial?0:1})))}moveLabel(e,t){const i=this,a=i.label,s=i.axis;let r=!1,o;a&&a.textStr===e?(i.movedLabel=a,r=!0,delete i.label):objectEach(s.ticks,function(t){r||t.isNew||t===i||!t.label||t.label.textStr!==e||(i.movedLabel=t.label,r=!0,t.labelPos=i.movedLabel.xy,delete t.label)}),r||!i.labelPos&&!a||(o=i.labelPos||a.xy,i.movedLabel=i.createLabel(e,t,o),i.movedLabel&&i.movedLabel.attr({opacity:0}))}render(t,e,i){var a=this,s=a.axis,r=s.horiz,o=a.pos,l=pick(a.tickmarkOffset,s.tickmarkOffset),o=a.getPosition(r,o,l,e),l=o.x,d=o.y,n=s.pos,h=n+s.len,r=r?l:d,l=pick(i,a.label?.newOpacity,1);i=(i=!s.chart.polar&&(correctFloat(r)<n||h<r)?0:i)??1,this.isActive=!0,this.renderGridLine(e,i),this.renderMark(o,i),this.renderLabel(o,e,l,t),a.isNew=!1,fireEvent(this,"afterRender")}renderGridLine(t,e){const i=this,a=i.axis,s=a.options,r={},o=i.pos,l=i.type,d=pick(i.tickmarkOffset,a.tickmarkOffset),n=a.chart.renderer;let h=i.gridLine,c,m=s.gridLineWidth,b=s.gridLineColor,p=s.gridLineDashStyle;"minor"===i.type&&(m=s.minorGridLineWidth,b=s.minorGridLineColor,p=s.minorGridLineDashStyle),h||(a.chart.styledMode||(r.stroke=b,r["stroke-width"]=m||0,r.dashstyle=p),l||(r.zIndex=1),t&&(e=0),i.gridLine=h=n.path().attr(r).addClass("highcharts-"+(l?l+"-":"")+"grid-line").add(a.gridGroup)),h&&(c=a.getPlotLinePath({value:o+d,lineWidth:h.strokeWidth(),force:"pass",old:t,acrossPanes:!1}))&&h[t||i.isNew?"attr":"animate"]({d:c,opacity:e})}renderMark(t,e){const i=this,a=i.axis,s=a.options,r=a.chart.renderer,o=i.type,l=a.tickSize(o?o+"Tick":"tick"),d=t.x,n=t.y,h=pick(s["minor"!==o?"tickWidth":"minorTickWidth"],!o&&a.isXAxis?1:0),c=s["minor"!==o?"tickColor":"minorTickColor"];let m=i.mark;t=!m;l&&(a.opposite&&(l[0]=-l[0]),m||(i.mark=m=r.path().addClass("highcharts-"+(o?o+"-":"")+"tick").add(a.axisGroup),a.chart.styledMode||m.attr({stroke:c,"stroke-width":h})),m[t?"attr":"animate"]({d:i.getMarkPath(d,n,l[0],m.strokeWidth(),a.horiz,r),opacity:e}))}renderLabel(t,e,i,a){const s=this,r=s.axis,o=r.horiz,l=r.options,d=s.label,n=l.labels,h=n.step,c=pick(s.tickmarkOffset,r.tickmarkOffset),m=t.x,b=t.y;let p=!0;d&&isNumber(m)&&(d.xy=t=s.getLabelPosition(m,b,d,o,n,c,a,h),s.isFirst&&!s.isLast&&!l.showFirstLabel||s.isLast&&!s.isFirst&&!l.showLastLabel?p=!1:!o||n.step||n.rotation||e||0===i||s.handleOverflow(t),(p=h&&a%h?!1:p)&&isNumber(t.y)?(t.opacity=i,d[s.isNewLabel?"attr":"animate"](t).show(!0),s.isNewLabel=!1):(d.hide(),s.isNewLabel=!0))}replaceMovedLabel(){const t=this,e=t.label,i=t.axis;e&&!t.isNew&&(e.animate({opacity:0},void 0,e.destroy),delete t.label),i.isDirty=!0,t.label=t.movedLabel,delete t.movedLabel}}export default Tick;