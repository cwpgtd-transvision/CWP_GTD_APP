"use strict";import BrokenAxis from"../BrokenAxis.js";import GridAxis from"../GridAxis.js";import Tree from"../../../Gantt/Tree.js";import TreeGridTick from"./TreeGridTick.js";import TU from"../../../Series/TreeUtilities.js";const getLevelOptions=TU["getLevelOptions"];import U from"../../Utilities.js";const{addEvent,isArray,splat,find,fireEvent,isObject,isString,merge,pick,removeEvent,wrap}=U;let TickConstructor;function getBreakFromNode(e,t){var r=e.collapseEnd||0;let o=e.collapseStart||0;return t<=r&&(o-=.5),{from:o,to:r,showPoints:!1}}function getTreeGridFromData(e,t,r){const n=[],s=[],d={},c=t||!1;let l={},p=-1;var f,t=Tree.getTree(e,{after:function(e){const t=l[e.pos];let r=0,o=0;t.children.forEach(function(e){o+=(e.descendants||0)+1,r=Math.max((e.height||0)+1,r)}),t.descendants=o,t.height=r,t.collapsed&&s.push(t)},before:function(e){const t=isObject(e.data,!0)?e.data:{},r=isString(t.name)?t.name:"",o=d[e.parent],s=isObject(o,!0)?l[o.pos]:null;let i,a;c&&isObject(s,!0)&&(i=find(s.children,function(e){return e.name===r}))?(a=i.pos,i.nodes.push(e)):a=p++,l[a]||(l[a]=i={depth:s?s.depth+1:0,name:r,id:t.id,nodes:[e],children:[],pos:a},-1!==a&&n.push(r),isObject(s,!0)&&s.children.push(i)),isString(e.id)&&(d[e.id]=e),i&&!0===t.collapsed&&(i.collapsed=!0),e.pos=a}});function m(e,r,t){const o=e.nodes;let s=r+(-1===r?0:f-1);const i=(s-r)/2,a=r+i;return o.forEach(function(e){const t=e.data;isObject(t,!0)&&(t.y=r+(t.seriesIndex||0),delete t.seriesIndex),e.pos=a}),(t[a]=e).pos=a,e.tickmarkOffset=.5+i,e.collapseStart=s+.5,e.children.forEach(function(e){m(e,s+1,t),s=(e.collapseEnd||0)-.5}),e.collapseEnd=s+.5,t}return l=(e=l,f=r,m(e[-1],-1,{})),{categories:n,mapOfIdToNode:d,mapOfPosToGridNode:l,collapsedNodes:s,tree:t}}function onBeforeRender(l){const p=l.target,e=p.axes;e.filter(e=>"treegrid"===e.type).forEach(function(e){const t=e.options||{},r=t.labels,i=e.uniqueNames,o=p.time.parse(t.max),s=!e.treeGrid.mapOfPosToGridNode||e.series.some(function(e){return!e.hasRendered||e.isDirtyData||e.isDirty});let a=0,n,d;if(s){const c=[];if(n=e.series.reduce(function(t,r){const e=r.options.data||[],o=e[0],s=Array.isArray(o)&&!o.find(e=>"object"==typeof e);return c.push(s),r.visible&&(e.forEach(function(e){(s||r.options.keys?.length)&&(e=r.pointClass.prototype.optionsToObject.call({series:r},e),r.pointClass.setGanttPointAliases(e,p)),isObject(e,!0)&&(e.seriesIndex=a,t.push(e))}),!0===i&&a++),t},[]),o&&n.length<o)for(let e=n.length;e<=o;e++)n.push({name:e+"â€‹"});d=getTreeGridFromData(n,i||!1,!0===i?a:1),e.categories=d.categories,e.treeGrid.mapOfPosToGridNode=d.mapOfPosToGridNode,e.hasNames=!0,e.treeGrid.tree=d.tree,e.series.forEach(function(e,t){var r=(e.options.data||[]).map(function(r){return(c[t]||isArray(r)&&e.options.keys&&e.options.keys.length)&&n.forEach(function(e){const t=splat(r);0<=t.indexOf(e.x||0)&&0<=t.indexOf(e.x2||0)&&(r=e)}),isObject(r,!0)?merge(r):r});e.visible&&e.setData(r,!1)}),e.treeGrid.mapOptionsToLevel=getLevelOptions({defaults:r,from:1,levels:r?.levels,to:e.treeGrid.tree?.height}),"beforeRender"===l.type&&(e.treeGrid.collapsedNodes=d.collapsedNodes)}})}function wrapGenerateTick(e,t){const r=this,o=r.treeGrid.mapOptionsToLevel||{},s="treegrid"===r.type,i=r.ticks;let a=i[t],n,d,c;s&&r.treeGrid.mapOfPosToGridNode?((n=o[(c=r.treeGrid.mapOfPosToGridNode[t]).depth])&&(d={labels:n}),!a&&TickConstructor?i[t]=a=new TickConstructor(r,t,void 0,void 0,{category:c.name,tickmarkOffset:c.tickmarkOffset,options:d}):(a.parameters.category=c.name,a.options=d,a.addLabel())):e.apply(r,Array.prototype.slice.call(arguments,1))}function wrapInit(e,t,r,o){const s=this,i="treegrid"===r.type;s.treeGrid||(s.treeGrid=new TreeGridAxisAdditions(s)),i&&(addEvent(t,"beforeRender",onBeforeRender),addEvent(t,"beforeRedraw",onBeforeRender),addEvent(t,"addSeries",function(e){e.options.data&&(e=getTreeGridFromData(e.options.data,r.uniqueNames||!1,1),s.treeGrid.collapsedNodes=(s.treeGrid.collapsedNodes||[]).concat(e.collapsedNodes))}),addEvent(s,"foundExtremes",function(){s.treeGrid.collapsedNodes&&s.treeGrid.collapsedNodes.forEach(function(t){var e=s.treeGrid.collapse(t);s.brokenAxis&&(s.brokenAxis.setBreaks(e,!1),s.treeGrid.collapsedNodes&&(s.treeGrid.collapsedNodes=s.treeGrid.collapsedNodes.filter(e=>t.collapseStart!==e.collapseStart||t.collapseEnd!==e.collapseEnd)))})}),addEvent(s,"afterBreaks",function(){"yAxis"===s.coll&&!s.staticScale&&s.chart.options.chart.height&&(s.isDirty=!0)}),r=merge({grid:{enabled:!0},labels:{align:"left",levels:[{level:void 0},{level:1,style:{fontWeight:"bold"}}],symbol:{type:"triangle",x:-5,y:-5,height:10,width:10}},uniqueNames:!1},r,{reversed:!0})),e.apply(s,[t,r,o]),i&&(s.hasNames=!0,s.options.showLastLabel=!0)}function wrapSetTickInterval(e){const t=this,r=t.options,o=t.chart.time,s="number"==typeof r.linkedTo?this.chart[t.coll]?.[r.linkedTo]:void 0,i="treegrid"===t.type;var a;i?(t.min=t.userMin??o.parse(r.min)??t.dataMin,t.max=t.userMax??o.parse(r.max)??t.dataMax,fireEvent(t,"foundExtremes"),t.setAxisTranslation(),t.tickInterval=1,t.tickmarkOffset=.5,t.tickPositions=t.treeGrid.mapOfPosToGridNode?t.treeGrid.getTickPositions():[],s&&(a=s.getExtremes(),t.min=pick(a.min,a.dataMin),t.max=pick(a.max,a.dataMax),t.tickPositions=s.tickPositions),t.linkedParent=s):e.apply(t,Array.prototype.slice.call(arguments,1))}function wrapRedraw(e){const r=this,t="treegrid"===this.type;t&&r.visible&&r.tickPositions.forEach(function(e){const t=r.ticks[e];t.label?.attachedTreeGridEvents&&(removeEvent(t.label.element),t.label.attachedTreeGridEvents=!1)}),e.apply(r,Array.prototype.slice.call(arguments,1))}class TreeGridAxisAdditions{static compose(e,t,r,o){if(!e.keepProps.includes("treeGrid")){const s=e.prototype;e.keepProps.push("treeGrid"),wrap(s,"generateTick",wrapGenerateTick),wrap(s,"init",wrapInit),wrap(s,"setTickInterval",wrapSetTickInterval),wrap(s,"redraw",wrapRedraw),s.utils={getNode:Tree.getNode},TickConstructor=TickConstructor||o}return GridAxis.compose(e,t,o),BrokenAxis.compose(e,r),TreeGridTick.compose(o),e}constructor(e){this.axis=e}setCollapsedStatus(s){const e=this.axis,i=e.chart;e.series.forEach(function(e){var t=e.options.data;if(s.id&&t){const r=i.get(s.id),o=t[e.data.indexOf(r)];r&&o&&(r.collapsed=s.collapsed,o.collapsed=s.collapsed)}})}collapse(e){const t=this.axis,r=t.options.breaks||[],o=getBreakFromNode(e,t.max);return r.push(o),e.collapsed=!0,t.treeGrid.setCollapsedStatus(e),r}expand(e){const t=this.axis,r=t.options.breaks||[],o=getBreakFromNode(e,t.max);return e.collapsed=!1,t.treeGrid.setCollapsedStatus(e),r.reduce(function(e,t){return t.to===o.to&&t.from===o.from||e.push(t),e},[])}getTickPositions(){const r=this.axis,o=Math.floor(r.min/r.tickInterval)*r.tickInterval,s=Math.ceil(r.max/r.tickInterval)*r.tickInterval;return Object.keys(r.treeGrid.mapOfPosToGridNode||{}).reduce(function(e,t){t=+t;return t>=o&&t<=s&&!r.brokenAxis?.isInAnyBreak(t)&&e.push(t),e},[])}isCollapsed(e){const t=this.axis,r=t.options.breaks||[],o=getBreakFromNode(e,t.max);return r.some(function(e){return e.from===o.from&&e.to===o.to})}toggleCollapse(e){return this.isCollapsed(e)?this.expand(e):this.collapse(e)}}export default TreeGridAxisAdditions;