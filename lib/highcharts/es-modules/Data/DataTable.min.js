"use strict";import CU from"./ColumnUtils.js";import DataTableCore from"./DataTableCore.js";import U from"../Core/Utilities.js";const{addEvent,defined,extend,fireEvent,isNumber,uniqueKey}=U;class DataTable extends DataTableCore{static isNull(o){if(o===DataTable.NULL)return!0;if(o instanceof Array){if(!o.length)return!1;for(let e=0,t=o.length;e<t;++e)if(null!==o[e])return!1}else{var r=Object.keys(o);if(!r.length)return!1;for(let e=0,t=r.length;e<t;++e)if(null!==o[r[e]])return!1}return!0}constructor(e={}){super(e),this.modified=this}clone(e,t){const o=this,r={},n=(o.emit({type:"cloneTable",detail:t}),e||(r.columns=o.columns),o.autoId||(r.id=o.id),new DataTable(r));return e||(n.versionTag=o.versionTag,n.originalRowIndexes=o.originalRowIndexes,n.localRowIndexes=o.localRowIndexes),o.emit({type:"afterCloneTable",detail:t,tableClone:n}),n}deleteColumns(n,e){const t=this,s=t.columns,i={},l={},o=t.modifier,u=t.rowCount;if((n=n||Object.keys(s)).length){t.emit({type:"deleteColumns",columnNames:n,detail:e});for(let e=0,t=n.length,o,r;e<t;++e)r=n[e],(o=s[r])&&(i[r]=o,l[r]=new Array(u)),delete s[r];return Object.keys(s).length||(t.rowCount=0,this.deleteRowIndexReferences()),o&&o.modifyColumns(t,l,0,e),t.emit({type:"afterDeleteColumns",columns:i,columnNames:n,detail:e}),i}}deleteRowIndexReferences(){delete this.originalRowIndexes,delete this.localRowIndexes}deleteRows(s,i=1,e){const l=this,u=[],a=[],t=l.modifier;if(l.emit({type:"deleteRows",detail:e,rowCount:i,rowIndex:s||0}),void 0===s&&(s=0,i=l.rowCount),0<i&&s<l.rowCount){const d=l.columns,f=Object.keys(d);for(let o=0,e=f.length,t,r,n;o<e;++o){n=f[o],t=d[n];var m=CU.splice(t,s,i);r=m.removed,d[n]=t=m.array,o||(l.rowCount=t.length);for(let e=0,t=r.length;e<t;++e)u[e]=u[e]||[],u[e][o]=r[e];a.push(new Array(e))}}return t&&t.modifyRows(l,a,s||0,e),l.emit({type:"afterDeleteRows",detail:e,rowCount:i,rowIndex:s||0,rows:u}),u}emit(e){["afterDeleteColumns","afterDeleteRows","afterSetCell","afterSetColumns","afterSetRows"].includes(e.type)&&(this.versionTag=uniqueKey()),fireEvent(this,e.type,e)}getCell(e,t){e=this.columns[e];if(e)return e[t]}getCellAsBoolean(e,t){e=this.columns[e];return!(!e||!e[t])}getCellAsNumber(e,t,o){e=this.columns[e];let r=e&&e[t];switch(typeof r){case"boolean":return r?1:0;case"number":return isNaN(r)&&!o?null:r}return r=parseFloat(""+(r??"")),isNaN(r)&&!o?null:r}getCellAsString(e,t){e=this.columns[e];return""+(e&&e[t])}getColumn(e,t){return this.getColumns([e],t)[e]}getColumnAsNumbers(t,e){const o=this.columns[t],r=[];if(o){var n=o.length;if(e)for(let e=0;e<n;++e)r.push(this.getCellAsNumber(t,e,!0));else{for(let e=0,t;e<n;++e){if("number"==typeof(t=o[e]))return o.slice();if(null!=t)break}for(let e=0;e<n;++e)r.push(this.getCellAsNumber(t,e))}}return r}getColumnNames(){return Object.keys(this.columns)}getColumns(n,s,i){const l=this.columns,u={};for(let e=0,t=(n=n||Object.keys(l)).length,o,r;e<t;++e)r=n[e],(o=l[r])&&(s?u[r]=o:i&&!Array.isArray(o)?u[r]=Array.from(o):u[r]=o.slice());return u}getLocalRowIndex(e){var t=this["localRowIndexes"];return t?t[e]:e}getModifier(){return this.modifier}getOriginalRowIndex(e){var t=this["originalRowIndexes"];return t?t[e]:e}getRow(e,t){return this.getRows(e,1,t)[0]}getRowCount(){return this.rowCount}getRowIndexBy(e,t,o){const r=this.columns[e];if(r){let e=-1;if(-1!==(e=Array.isArray(r)||isNumber(t)?r.indexOf(t,o):e))return e}}getRowObject(e,t){return this.getRowObjects(e,1,t)[0]}getRowObjects(s=0,i=this.rowCount-s,l){const u=this.columns,a=new Array(i);l=l||Object.keys(u);for(let e=s,t=0,o=Math.min(this.rowCount,s+i),r,n;e<o;++e,++t){n=a[t]={};for(const m of l)r=u[m],n[m]=r?r[e]:void 0}return a}getRows(s=0,i=this.rowCount-s,l){const u=this.columns,a=new Array(i);l=l||Object.keys(u);for(let e=s,t=0,o=Math.min(this.rowCount,s+i),r,n;e<o;++e,++t){n=a[t]=[];for(const m of l)r=u[m],n.push(r?r[e]:void 0)}return a}getVersionTag(){return this.versionTag}hasColumns(o){var r=this.columns;for(let e=0,t=o.length;e<t;++e)if(!r[o[e]])return!1;return!0}hasRowWith(e,t){const o=this.columns[e];return Array.isArray(o)?-1!==o.indexOf(t):!(!defined(t)||!Number.isFinite(t))&&-1!==o.indexOf(+t)}on(e,t){return addEvent(this,e,t)}renameColumn(e,t){const o=this.columns;return!!o[e]&&(e!==t&&(o[t]=o[e],delete o[e]),!0)}setCell(e,t,o,r){const n=this,s=n.columns,i=n.modifier;let l=s[e];l&&l[t]===o||(n.emit({type:"setCell",cellValue:o,columnName:e,detail:r,rowIndex:t}),l=l||(s[e]=new Array(n.rowCount)),t>=n.rowCount&&(n.rowCount=t+1),l[t]=o,i&&i.modifyCell(n,e,t,o),n.emit({type:"afterSetCell",cellValue:o,columnName:e,detail:r,rowIndex:t}))}setColumns(i,l,e,u){const t=this,a=t.columns,o=t.modifier,m=Object.keys(i);let d=t.rowCount;if(t.emit({type:"setColumns",columns:i,columnNames:m,detail:e,rowIndex:l}),defined(l)||u){for(let e=0,t=m.length,o,r,n,s;e<t;++e){o=i[n=m[e]],r=a[n],s=Object.getPrototypeOf(r&&u?r:o).constructor,r?s===Array?Array.isArray(r)||(r=Array.from(r)):r.length<d&&(r=new s(d)).set(a[n]):r=new s(d),a[n]=r;for(let e=l||0,t=o.length;e<t;++e)r[e]=o[e];d=Math.max(d,o.length)}this.applyRowCount(d)}else super.setColumns(i,l,extend(e,{silent:!0}));o&&o.modifyColumns(t,i,l||0),t.emit({type:"afterSetColumns",columns:i,columnNames:m,detail:e,rowIndex:l})}setModifier(t,o){const r=this;let e;return r.emit({type:"setModifier",detail:o,modifier:t,modified:r.modified}),(r.modified=r).modifier=t,(e=t?t.modify(r):Promise.resolve(r)).then(e=>(e.emit({type:"afterSetModifier",detail:o,modifier:t,modified:e.modified}),e)).catch(e=>{throw r.emit({type:"setModifierError",error:e,modifier:t,modified:r.modified}),e})}setOriginalRowIndexes(r,e=!1){if(this.originalRowIndexes=r,!e){const n=this.localRowIndexes=[];for(let e=0,t=r.length,o;e<t;++e)o=r[e],defined(o)&&(n[o]=e)}}setRow(e,t,o,r){this.setRows([e],t,o,r)}setRows(t,n=this.rowCount,s,e){const o=this,i=o.columns,l=Object.keys(i),r=o.modifier,u=t.length;o.emit({type:"setRows",detail:e,rowCount:u,rowIndex:n,rows:t});for(let e=0,o=n,r;e<u;++e,++o)if((r=t[e])===DataTable.NULL)for(let e=0,t=l.length;e<t;++e){const d=i[l[e]];s?i[l[e]]=CU.splice(d,o,0,!0,[null]).array:d[o]=null}else if(r instanceof Array)for(let e=0,t=l.length;e<t;++e)i[l[e]][o]=r[e];else super.setRow(r,o,void 0,{silent:!0});var a=s?u+t.length:n+u;if(a>o.rowCount){o.rowCount=a;for(let e=0,t=l.length;e<t;++e){var m=l[e];i[m]=CU.setLength(i[m],a)}}r&&r.modifyRows(o,t,n),o.emit({type:"afterSetRows",detail:e,rowCount:u,rowIndex:n,rows:t})}}DataTable.NULL={},DataTable.version="1.0.0";export default DataTable;