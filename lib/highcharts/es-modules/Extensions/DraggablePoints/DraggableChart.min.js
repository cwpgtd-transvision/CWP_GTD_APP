"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import DDU from"./DragDropUtilities.js";const{addEvents,countProps,getFirstProp,getNormalizedEvent}=DDU;import DragDropDefaults from"./DragDropDefaults.js";import H from"../../Core/Globals.js";const doc=H["doc"];import U from"../../Core/Utilities.js";const{addEvent,isArray,merge,pick}=U;function addDragDropEvents(t){var e=t.container;isChartDraggable(t)&&(addEvents(e,["mousedown","touchstart"],e=>{mouseDown(getNormalizedEvent(e,t),t)}),addEvents(e,["mousemove","touchmove"],e=>{mouseMove(getNormalizedEvent(e,t),t)},{passive:!1}),addEvent(e,"mouseleave",e=>{mouseUp(getNormalizedEvent(e,t),t)}),t.unbindDragDropMouseUp=addEvents(doc,["mouseup","touchend"],e=>{mouseUp(getNormalizedEvent(e,t),t)},{passive:!1}),t.hasAddedDragDropEvents=!0,addEvent(t,"destroy",()=>{t.unbindDragDropMouseUp&&t.unbindDragDropMouseUp()}))}function chartHideDragHandles(){const e=this.dragHandles||{};if(e){for(const t of Object.keys(e))e[t].destroy&&e[t].destroy();delete this.dragHandles}}function chartSetGuideBoxState(e,t){const r=this.dragGuideBox,o=merge(DragDropDefaults.guideBox,t),i=merge(o.default,o[e]);return r.attr({class:i.className,stroke:i.lineColor,strokeWidth:i.lineWidth,fill:i.color,cursor:i.cursor,zIndex:i.zIndex}).css({pointerEvents:"none"})}function chartZoomOrPanKeyPressed(e){var t=this,r=t.options.chart||{},r=r.panKey&&r.panKey+"Key";return e[t.zooming.key&&t.zooming.key+"Key"]||e[r]}function compose(e){const t=e.prototype;t.hideDragHandles||(t.hideDragHandles=chartHideDragHandles,t.setGuideBoxState=chartSetGuideBoxState,t.zoomOrPanKeyPressed=chartZoomOrPanKeyPressed,addEvent(e,"render",onChartRender))}function dragMove(e,t){const r=t.series,o=r.chart,i=o.dragDropData,a=merge(r.options.dragDrop,t.options.dragDrop),n=a.draggableX,s=a.draggableY,d=i.origin,g=i.updateProp;let p=e.chartX-d.chartX,c=e.chartY-d.chartY;e=p;o.inverted&&(p=-c,c=-e),pick(a.liveRedraw,!0)?(updatePoints(o,!1),t.showDragHandles()):g?resizeGuideBox(t,p,c):o.dragGuideBox.translate(n?p:0,s?c:0),d.prevdX=p,d.prevdY=c}function flipResizeSide(e){return{left:"right",right:"left",top:"bottom",bottom:"top"}[e]}function getGroupedPoints(t){const r=t.series,o=r.options.data||[],i=r.options.dragDrop.groupBy;let a=[];if(r.boosted&&isArray(o))for(let e=0,t=o.length;e<t;++e)a.push(new r.pointClass(r,o[e])),a[a.length-1].index=e;else a=r.points;return t.options[i]?a.filter(e=>e.options[i]===t.options[i]):[t]}function getNewPoints(e,t){const r=e.point,o=r.series,i=o.chart,a=merge(o.options.dragDrop,r.options.dragDrop),n={},s=e.updateProp,d={},g=r.series.dragDropProps;for(const c in g){var p=g[c];s&&(s!==c||!p.resize||p.optionName&&!1===a[p.optionName])||(s||p.move&&("x"===p.axis&&a.draggableX||"y"===p.axis&&a.draggableY))&&(i.mapView?n["x"===c?"lon":"lat"]=p:n[c]=p)}for(const u of s?[r]:e.groupedPoints)d[u.id]={point:u,newValues:u.getDropValues(e.origin,t,n)};return d}function getPositionSnapshot(e,t,r){const o={chartX:e.chartX,chartY:e.chartY,guideBox:r&&{x:r.attr("x"),y:r.attr("y"),width:r.attr("width"),height:r.attr("height")},points:{}};for(const i of t){const a=i.series.dragDropProps||{},n={};for(const s of Object.keys(a)){const d=a[s],g=i.series[d.axis+"Axis"];n[s]=i[s],i.series.chart.mapView&&i.plotX&&i.plotY?n[s+"Offset"]="x"===s?i.plotX:i.plotY:n[s+"Offset"]=g.toPixels(i[s])-(g.horiz?e.chartX:e.chartY)}n.point=i,o.points[i.id]=n}return o}function hasDraggedPastSensitivity(e,t,r){var t=t.dragDropData.origin,o=t.chartX,t=t.chartY,i=e.chartX,e=e.chartY;return r<Math.sqrt((i-o)*(i-o)+(e-t)*(e-t))}function initDragDrop(e,t){const r=getGroupedPoints(t),o=t.series,i=o.chart;let a;pick(o.options.dragDrop&&o.options.dragDrop.liveRedraw,!0)||(i.dragGuideBox=a=o.getGuideBox(r),i.setGuideBoxState("default",o.options.dragDrop.guideBox).add(o.group)),i.dragDropData={origin:getPositionSnapshot(e,r,a),point:t,groupedPoints:r,isDragging:!0}}function isChartDraggable(e){let t=e.series?e.series.length:0;if(e.hasCartesianSeries&&!e.polar||e.mapView)for(;t--;)if(e.series[t].options.dragDrop&&isSeriesDraggable(e.series[t]))return!0;return!1}function isPointMovable(e){var t=e.series,r=t.chart,o=t.options.dragDrop||{},e=e.options&&e.options.dragDrop,i=t.dragDropProps;let a,n,s;for(const d in i)"x"===(a=i[d]).axis&&a.move?n=!0:"y"===a.axis&&a.move&&(s=!0);return(o.draggableX&&n||o.draggableY&&s)&&!(e&&!1===e.draggableX&&!1===e.draggableY)&&(!(!t.yAxis||!t.xAxis)||r.mapView)}function isSeriesDraggable(e){const t=["draggableX","draggableY"],r=e.dragDropProps||{};var o;for(const a of Object.keys(r))(o=r[a]).optionName&&t.push(o.optionName);let i=t.length;for(;i--;)if(e.options.dragDrop[t[i]])return!0}function mouseDown(e,t){const r=t.hoverPoint,o=merge(r&&r.series.options.dragDrop,r&&r.options.dragDrop),i=o.draggableX||!1,a=o.draggableY||!1;t.cancelClick=!1,!i&&!a||t.zoomOrPanKeyPressed(e)||t.hasDraggedAnnotation||(t.dragDropData&&t.dragDropData.isDragging?mouseUp(e,t):r&&isPointMovable(r)&&(t.mouseIsDown=!1,initDragDrop(e,r),r.firePointEvent("dragStart",e)))}function mouseMove(a,n){if(!n.zoomOrPanKeyPressed(a)){const s=n.dragDropData;let e,t,r,o,i;s&&s.isDragging&&s.point.series&&(t=(e=s.point).series.options.dragDrop,a.preventDefault(),s.draggedPastSensitivity||(s.draggedPastSensitivity=hasDraggedPastSensitivity(a,n,pick(e.options.dragDrop&&e.options.dragDrop.dragSensitivity,t&&t.dragSensitivity,DragDropDefaults.dragSensitivity))),s.draggedPastSensitivity&&(s.newPoints=getNewPoints(s,a),r=s.newPoints,i=1===(o=countProps(r))?getFirstProp(r):null,e.firePointEvent("drag",{origin:s.origin,newPoints:s.newPoints,newPoint:i&&i.newValues,newPointId:i&&i.point.id,numNewPoints:o,chartX:a.chartX,chartY:a.chartY},function(){dragMove(a,e)})))}}function mouseUp(e,t){var r=t.dragDropData;if(r&&r.isDragging&&r.draggedPastSensitivity&&r.point.series){const o=r.point,i=r.newPoints,a=countProps(i),n=1===a?getFirstProp(i):null;t.dragHandles&&t.hideDragHandles(),e.preventDefault(),t.cancelClick=!0,o.firePointEvent("drop",{origin:r.origin,chartX:e.chartX,chartY:e.chartY,newPoints:i,numNewPoints:a,newPoint:n&&n.newValues,newPointId:n&&n.point.id},function(){updatePoints(t)})}delete t.dragDropData,t.dragGuideBox&&(t.dragGuideBox.destroy(),delete t.dragGuideBox)}function onChartRender(){this.hasAddedDragDropEvents||addDragDropEvents(this)}function resizeGuideBox(e,t,r){const o=e.series,i=o.chart,a=i.dragDropData,n=o.dragDropProps[a.updateProp],s=a.newPoints[e.id].newValues,d="function"==typeof n.resizeSide?n.resizeSide(s,e):n.resizeSide;n.beforeResize&&n.beforeResize(i.dragGuideBox,s,e),resizeRect(i.dragGuideBox,"x"===n.axis&&o.xAxis.reversed||"y"===n.axis&&o.yAxis.reversed?flipResizeSide(d):d,{x:"x"===n.axis?t-(a.origin.prevdX||0):0,y:"y"===n.axis?r-(a.origin.prevdY||0):0})}function resizeRect(e,t,r){let o;switch(t){case"left":o={x:e.attr("x")+r.x,width:Math.max(1,e.attr("width")-r.x)};break;case"right":o={width:Math.max(1,e.attr("width")+r.x)};break;case"top":o={y:e.attr("y")+r.y,height:Math.max(1,e.attr("height")-r.y)};break;case"bottom":o={height:Math.max(1,e.attr("height")+r.y)}}e.attr(o)}function updatePoints(e,t){var r=e.dragDropData.newPoints,t=animObject(t);e.isDragDropAnimating=!0;let o;for(const i of Object.keys(r))(o=r[i]).point.update(o.newValues,!1);e.redraw(t),setTimeout(()=>{delete e.isDragDropAnimating,e.hoverPoint&&!e.dragHandles&&e.hoverPoint.showDragHandles()},t.duration)}const DraggableChart={compose:compose,flipResizeSide:flipResizeSide,initDragDrop:initDragDrop};export default DraggableChart;