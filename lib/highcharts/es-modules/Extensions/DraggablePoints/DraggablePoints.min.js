"use strict";import DDU from"./DragDropUtilities.js";const{addEvents,getNormalizedEvent}=DDU;import DraggableChart from"./DraggableChart.js";const initDragDrop=DraggableChart["initDragDrop"];import DragDropDefaults from"./DragDropDefaults.js";import DragDropProps from"./DragDropProps.js";import U from"../../Core/Utilities.js";const{addEvent,clamp,isNumber,merge}=U;function compose(e,o){DraggableChart.compose(e);const r=o.prototype;if(!r.dragDropProps){const t=o.prototype.pointClass,a=o.types,s=t.prototype;s.getDropValues=pointGetDropValues,s.showDragHandles=pointShowDragHandles,addEvent(t,"mouseOut",onPointMouseOut),addEvent(t,"mouseOver",onPointMouseOver),addEvent(t,"remove",onPointRemove),r.dragDropProps=DragDropProps.line,r.getGuideBox=seriesGetGuideBox;for(const i of["arearange","boxplot","bullet","column","columnrange","errorbar","flags","gantt","ohlc","waterfall","xrange"])a[i]&&(a[i].prototype.dragDropProps=DragDropProps[i]);for(const n of["bellcurve","gauge","histogram","map","mapline","pareto","pie","sankey","sma","sunburst","treemap","vector","windbarb","wordcloud"])a[n]&&(a[n].prototype.dragDropProps=null)}}function mouseOut(e){const o=e.series&&e.series.chart,r=o&&o.dragDropData;!o||!o.dragHandles||r&&(r.isDragging&&r.draggedPastSensitivity||r.isHoveringHandle===e.id)||o.hideDragHandles()}function mouseOver(e){const o=e.series,r=o&&o.chart,t=r&&r.dragDropData,a=r&&r.is3d&&r.is3d();!r||t&&t.isDragging&&t.draggedPastSensitivity||r.isDragDropAnimating||!o.options.dragDrop||a||(r.dragHandles&&r.hideDragHandles(),e.showDragHandles())}function onPointMouseOut(){const e=this;setTimeout(()=>{e.series&&mouseOut(e)},10)}function onPointMouseOver(){const e=this;setTimeout(()=>mouseOver(e),12)}function onPointRemove(){const e=this.series.chart,o=e.dragHandles;o&&o.point===this.id&&e.hideDragHandles()}function onResizeHandleMouseOut(e){const o=e.series.chart;o.dragDropData&&e.id===o.dragDropData.isHoveringHandle&&delete o.dragDropData.isHoveringHandle,o.hoverPoint||mouseOut(e)}function onResizeHandleMouseDown(e,o,r){const t=o.series.chart;t.zoomOrPanKeyPressed(e)||(t.mouseIsDown=!1,initDragDrop(e,o),t.dragDropData.updateProp=e.updateProp=r,o.firePointEvent("dragStart",e),e.stopPropagation(),e.preventDefault())}function pointGetDropValues(e,o,r){const t=this,d=t.series,g=d.chart,l=g.mapView,u=merge(d.options.dragDrop,t.options.dragDrop),a={},s=e.points[t.id],i=1===Object.keys(r).length;for(const n of Object.keys(r)){const p=r[n],c=s.point[n],D=d[p.axis+"Axis"],m=l?((t,a,s)=>{if(l){var a=a.toUpperCase(),i=u["dragPrecision"+a]??0,n=l.pixelsToLonLat({x:0,y:0}),p=l.pixelsToLonLat({x:g.plotBox.width,y:g.plotBox.height});let e=u["dragMin"+a]??n?.[s]??-1/0,o=u["dragMax"+a]??p?.[s]??1/0,r=t[s];return"Orthographic"===l.projection.options.name?r:("lat"===s&&((isNaN(e)||e>l.projection.maxLatitude)&&(e=l.projection.maxLatitude),n=o=isNaN(o)||o<-1*l.projection.maxLatitude?-1*l.projection.maxLatitude:o,o=e,e=n),l.projection.hasCoordinates||(a=l.pixelsToLonLat({x:t.chartX-g.plotLeft,y:g.plotHeight-t.chartY+g.plotTop}))&&(r=a[s]),i&&(r=Math.round(r/i)*i),clamp(r,e,o))}})(o,p.axis,n):((e,o)=>{const r=o.toUpperCase(),t=d.chart.time,a=d[o+"Axis"].categories?1:0,s=u["dragPrecision"+r]??a,i=t.parse(u["dragMin"+r])??-1/0,n=t.parse(u["dragMax"+r])??1/0;let p=e;return s&&(p=Math.round(p/s)*s),clamp(p,i,n)})(D.toValue((D.horiz?o.chartX:o.chartY)+s[n+"Offset"]),p.axis);!isNumber(m)||i&&p.propValidate&&!p.propValidate(m,t)||void 0===c||(a[n]=m)}return a}function pointShowDragHandles(){const t=this,a=t.series,s=a.chart,{inverted:i,renderer:n}=s,p=merge(a.options.dragDrop,t.options.dragDrop),d=a.dragDropProps||{};let g=s.dragHandles;for(const u of Object.keys(d)){const c=d[u],D=merge(DragDropDefaults.dragHandle,c.handleOptions,p.dragHandle),m={class:D.className,"stroke-width":D.lineWidth,fill:D.color,stroke:D.lineColor},h=D.pathFormatter||c.handleFormatter,x=c.handlePositioner,f=!c.validateIndividualDrag||c.validateIndividualDrag(t);let e,o,r;if(c.resize&&f&&c.resizeSide&&h&&(p["draggable"+c.axis.toUpperCase()]||p[c.optionName])&&!1!==p[c.optionName]){g?g.point=t.id:g=s.dragHandles={group:n.g("drag-drop-handles").add(a.markerGroup||a.group),point:t.id},e=x(t),m.d=r=h(t);var l=t.series.xAxis.categories?-.5:0;if(!r||e.x<l||e.y<0)return;m.cursor=D.cursor||("x"===c.axis!=!!i?"ew-resize":"ns-resize"),o=(o=g[c.optionName])||(g[c.optionName]=n.path().add(g.group)),m.translateX=i?a.yAxis.len-e.y:e.x,m.translateY=i?a.xAxis.len-e.x:e.y,i&&(m.rotation=-90),o.attr(m),addEvents(o.element,["touchstart","mousedown"],e=>{onResizeHandleMouseDown(getNormalizedEvent(e,s),t,u)},{passive:!1}),addEvent(g.group.element,"mouseover",()=>{s.dragDropData=s.dragDropData||{},s.dragDropData.isHoveringHandle=t.id}),addEvents(g.group.element,["touchend","mouseout"],()=>{onResizeHandleMouseOut(t)})}}}function seriesGetGuideBox(e){const o=this.chart;let r=1/0,t=-1/0,a=1/0,s=-1/0,i;for(const d of e){var n=d.graphic&&d.graphic.getBBox()||d.shapeArgs;if(n){let e;var p=d.x2,p=(isNumber(p)&&(e=d.series.xAxis.translate(p,!1,!1,!1,!0)),!(n.width||n.height||n.x||n.y));i=!0,r=Math.min(d.plotX||0,e||0,p?1/0:n.x||0,r),t=Math.max(d.plotX||0,e||0,(n.x||0)+(n.width||0),t),a=Math.min(d.plotY||0,p?1/0:n.y||0,a),s=Math.max((n.y||0)+(n.height||0),s)}}return i?o.renderer.rect(r,a,t-r,s-a):o.renderer.g()}const DraggablePoints={compose:compose};export default DraggablePoints;