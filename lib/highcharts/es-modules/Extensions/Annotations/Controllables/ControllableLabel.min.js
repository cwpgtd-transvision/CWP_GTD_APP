"use strict";import Controllable from"./Controllable.js";import F from"../../../Core/Templating.js";const format=F["format"];import MockPoint from"../MockPoint.js";import U from"../../../Core/Utilities.js";const{extend,getAlignFactor,isNumber,pick}=U;function symbolConnector(t,o,i,n,e){var s=e&&e.anchorX,e=e&&e.anchorY;let a,r,l=i/2;return isNumber(s)&&isNumber(e)&&(a=[["M",s,e]],(r=(r=o-e)<0?-n-r:r)<i&&(l=s<t+i/2?r:i-r),o+n<e?a.push(["L",t+l,o+n]):e<o?a.push(["L",t+l,o]):s<t?a.push(["L",t,o+n/2]):t+i<s&&a.push(["L",t+i,o+n/2])),a||[]}class ControllableLabel extends Controllable{static alignedPosition(t,o){return{x:Math.round((o.x||0)+(t.x||0)+(o.width-(t.width||0))*getAlignFactor(t.align)),y:Math.round((o.y||0)+(t.y||0)+(o.height-(t.height||0))*getAlignFactor(t.verticalAlign))}}static compose(t){const o=t.prototype.symbols;o.connector=symbolConnector}static justifiedOptions(t,o,i,n){const e=i.align,s=i.verticalAlign,a=!o.box&&o.padding||0,r=o.getBBox(),l={align:e,verticalAlign:s,x:i.x,y:i.y,width:o.width,height:o.height},h=(n.x||0)-t.plotLeft,c=(n.y||0)-t.plotTop;let p;return(p=h+a)<0&&("right"===e?l.align="left":l.x=(l.x||0)-p),(p=h+r.width-a)>t.plotWidth&&("left"===e?l.align="right":l.x=(l.x||0)+t.plotWidth-p),(p=c+a)<0&&("bottom"===s?l.verticalAlign="top":l.y=(l.y||0)-p),(p=c+r.height-a)>t.plotHeight&&("top"===s?l.verticalAlign="bottom":l.y=(l.y||0)+t.plotHeight-p),l}constructor(t,o,i){super(t,o,i,"label")}translatePoint(t,o){super.translatePoint(t,o,0)}translate(t,o){const i=this.annotation.chart,n=this.annotation.userOptions,e=i.annotations.indexOf(this.annotation),s=i.options.annotations,a=s[e];var r;i.inverted&&(r=t,t=o,o=r),this.options.x+=t,this.options.y+=o,a[this.collection][this.index].x=this.options.x,a[this.collection][this.index].y=this.options.y,n[this.collection][this.index].x=this.options.x,n[this.collection][this.index].y=this.options.y}render(t){const o=this.options,i=this.attrsFromOptions(o),n=o.style,e=this.annotation.chart.options.chart,s=e.plotBackgroundColor||e.backgroundColor;this.graphic=this.annotation.chart.renderer.label("",0,-9999,o.shape,void 0,void 0,o.useHTML,void 0,"annotation-label").attr(i).add(t),this.annotation.chart.styledMode||("contrast"===n.color&&(t=-1<ControllableLabel.shapesWithoutBackground.indexOf(o.shape)||"none"===o.backgroundColor?s:o.backgroundColor,n.color=this.annotation.chart.renderer.getContrast("string"==typeof t?t:"string"==typeof s?s:"#ffffff")),this.graphic.css(o.style).shadow(o.shadow)),this.graphic.labelrank=o.labelrank,super.render()}redraw(t){const o=this.options,i=this.text||o.format||o.text,n=this.graphic,e=this.points[0];if(n){n.attr({text:i?format(String(i),e,this.annotation.chart):o.formatter.call(e,this)});var s=this.anchor(e);const a=this.position(s);a?((n.alignAttr=a).anchorX=s.absolutePosition.x,a.anchorY=s.absolutePosition.y,n[t?"animate":"attr"](a)):n.attr({x:0,y:-9999}),n.placed=!!a,super.redraw(t)}else this.redraw(t)}anchor(t){const o=super.anchor.apply(this,arguments),i=this.options.x||0,n=this.options.y||0;return o.absolutePosition.x-=i,o.absolutePosition.y-=n,o.relativePosition.x-=i,o.relativePosition.y-=n,o}position(t){const o=this.graphic,i=this.annotation.chart,n=i.tooltip,e=this.points[0],s=this.options,a=t.absolutePosition,r=t.relativePosition;let l,h,c,p,d=e.series.visible&&MockPoint.prototype.isInsidePlot.call(e);var g;return o&&d&&({width:t=0,height:g=0}=o,s.distance&&n?l=n.getPosition.call({chart:i,distance:pick(s.distance,16),getPlayingField:n.getPlayingField,pointer:n.pointer},t,g,{plotX:r.x,plotY:r.y,negative:e.negative,ttBelow:e.ttBelow,h:r.height||r.width}):s.positioner?l=s.positioner.call(this):(h={x:a.x,y:a.y,width:0,height:0},l=ControllableLabel.alignedPosition(extend(s,{width:t,height:g}),h),"justify"===this.options.overflow&&(l=ControllableLabel.alignedPosition(ControllableLabel.justifiedOptions(i,o,s,l),h))),s.crop&&(c=l.x-i.plotLeft,p=l.y-i.plotTop,d=i.isInsidePlot(c,p)&&i.isInsidePlot(c+t,p+g))),d?l:null}}ControllableLabel.attrsMap={backgroundColor:"fill",borderColor:"stroke",borderWidth:"stroke-width",zIndex:"zIndex",borderRadius:"r",padding:"padding"},ControllableLabel.shapesWithoutBackground=["connector"];export default ControllableLabel;