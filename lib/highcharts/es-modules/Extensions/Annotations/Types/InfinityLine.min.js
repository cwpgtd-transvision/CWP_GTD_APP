"use strict";import Annotation from"../Annotation.js";import CrookedLine from"./CrookedLine.js";import D from"../../../Core/Defaults.js";const defaultOptions=D["defaultOptions"];import MockPoint from"../MockPoint.js";import U from"../../../Core/Utilities.js";const merge=U["merge"];defaultOptions.annotations&&(defaultOptions.annotations.types.infinityLine=merge(defaultOptions.annotations.types.crookedLine));class InfinityLine extends CrookedLine{static edgePoint(e,o){return function(i){var i=i.annotation,t=i.options.typeOptions.type;let n=i.points;return"horizontalLine"!==t&&"verticalLine"!==t||(n=[n[0],new MockPoint(i.chart,n[0].target,{x:n[0].x+ +("horizontalLine"===t),y:n[0].y+ +("verticalLine"===t),xAxis:n[0].options.xAxis,yAxis:n[0].options.yAxis})]),InfinityLine.findEdgePoint(n[e],n[o])}}static findEdgeCoordinate(i,t,n,e){var o="x"===n?"y":"x";return(t[n]-i[n])*(e-i[o])/(t[o]-i[o])+i[n]}static findEdgePoint(i,t){const n=i.series.chart,e=i.series.xAxis,o=t.series.yAxis,s=MockPoint.pointToPixels(i),r=MockPoint.pointToPixels(t),a=r.x-s.x,p=r.y-s.y,y=e.left,d=y+e.width,f=o.top,x=f+o.height,c=a<0?y:d,l=p<0?f:x,L={x:0==a?s.x:c,y:0==p?s.y:l};var g;return 0!=a&&0!=p&&(t=InfinityLine.findEdgeCoordinate(s,r,"y",c),g=InfinityLine.findEdgeCoordinate(s,r,"x",l),f<=t&&t<=x?(L.x=c,L.y=t):(L.x=g,L.y=l)),L.x-=n.plotLeft,L.y-=n.plotTop,i.series.chart.inverted&&(t=L.x,L.x=L.y,L.y=t),L}addShapes(){const i=this.options.typeOptions,t=[this.points[0],InfinityLine.endEdgePoint];i.type.match(/line/gi)&&(t[0]=InfinityLine.startEdgePoint);var n=this.initShape(merge(i.line,{type:"path",points:t,className:"highcharts-infinity-lines"}),0);i.line=n.options}}InfinityLine.endEdgePoint=InfinityLine.edgePoint(0,1),InfinityLine.startEdgePoint=InfinityLine.edgePoint(1,0);export default Annotation.types.infinityLine=InfinityLine;