"use strict";import H from"../../Core/Globals.js";const composed=H["composed"];import T from"../../Core/Templating.js";const format=T["format"];import U from"../../Core/Utilities.js";const{addEvent,defined,erase,extend,insertItem,isArray,isNumber,pushUnique}=U;var ParallelSeries;!function(){function i(){const e=this.chart,i=this.points,o=i&&i.length;let s=Number.MAX_VALUE,a,r;if(this.chart.hasParallelCoordinates){for(let t=0;t<o;t++)r=i[t],defined(r.y)?(e.polar?r.plotX=e.yAxis[t].angleRad||0:e.inverted?r.plotX=e.plotHeight-e.yAxis[t].top+e.plotTop:r.plotX=e.yAxis[t].left-e.plotLeft,r.clientX=r.plotX,r.plotY=e.yAxis[t].translate(r.y,!1,!0,void 0,!0),isNumber(r.high)&&(r.plotHigh=e.yAxis[t].translate(r.high,!1,!0,void 0,!0)),void 0!==a&&(s=Math.min(s,Math.abs(r.plotX-a))),a=r.plotX,r.isInside=e.isInsidePlot(r.plotX,r.plotY,{inverted:e.inverted})):r.isNull=!0;this.closestPointRangePx=s}}function o(t){const e=this,i=e.chart;if(i.hasParallelCoordinates){const e=this;for(const o of i.axes)insertItem(e,o.series),o.isDirty=!0;e.xAxis=i.xAxis[0],e.yAxis=i.yAxis[0],t.preventDefault()}}function s(){var t=this.chart;if(t.hasParallelCoordinates)for(const e of t.axes||[])e&&e.series&&(erase(e.series,this),e.isDirty=e.forceRedraw=!0)}function a(){const e=this.chart;if(e?.hasParallelCoordinates)for(const a of this.points){var i=e.yAxis[a.x||0],o=i.options,s=o.tooltipValueFormat??o.labels.format;let t;t=s?format(s,extend(a,{value:a.y}),e):i.dateTime?e.time.dateFormat(e.time.resolveDTLFormat(o.dateTimeLabelFormats?.[i.tickPositions.info?.unitName||"year"]||"").main,a.y??void 0):isArray(o.categories)?o.categories[a.y??-1]:String(a.y??""),a.formattedValue=t}}(ParallelSeries||(ParallelSeries={})).compose=function(t){var e;pushUnique(composed,"ParallelSeries")&&(e=t,addEvent(e,"afterTranslate",i,{order:1}),addEvent(e,"bindAxes",o),addEvent(e,"destroy",s),addEvent(t,"afterGeneratePoints",a))}}();export default ParallelSeries;