"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import DataTableCore from"../../Data/DataTableCore.js";import MarkerClusterDefaults from"./MarkerClusterDefaults.js";const clusterDefaults=MarkerClusterDefaults["cluster"];import U from"../../Core/Utilities.js";const{addEvent,defined,error,isArray,isFunction,isObject,isNumber,merge,objectEach,relativeLength,syncTimeout}=U,markerClusterAlgorithms={grid:function(t,e,a,s){const i=this,o={},r=i.getGridOffset(),n=i.getScaledGridSize(s);let l,d,u,p,c;for(c=0;c<t.length;c++){var h=valuesToPixels(i,{x:t[c],y:e[c]});l=h.x-r.plotLeft,d=h.y-r.plotTop,u=Math.floor(l/n),p=Math.floor(d/n)+":"+u,o[p]??(o[p]=[]),o[p].push({dataIndex:a[c],x:t[c],y:e[c]})}return o},kmeans:function(e,a,s,t){const i=this,o=[],r=[],n={},l=t.processedDistance||clusterDefaults.layoutAlgorithm.distance,d=t.iterations;let u=0,p=!0,c,h,m,f=[];t.processedGridSize=t.processedDistance;var x=i.markerClusterAlgorithms?i.markerClusterAlgorithms.grid.call(i,e,a,s,t):{};for(const g in x)1<x[g].length&&(m=getClusterPosition(x[g]),o.push({posX:m.x,posY:m.y,oldX:0,oldY:0,startPointsLen:x[g].length,points:[]}));for(;p;){for(const y of o)y.points.length=0;for(let t=r.length=0;t<e.length;t++)c=e[t],h=a[t],((f=i.getClusterDistancesFromPoint(o,c,h)).length&&f[0].distance<l?o[f[0].clusterIndex].points:r).push({x:c,y:h,dataIndex:s[t]});for(let t=0;t<o.length;t++)1===o[t].points.length&&(f=i.getClusterDistancesFromPoint(o,o[t].points[0].x,o[t].points[0].y))[1].distance<l&&(o[f[1].clusterIndex].points.push(o[t].points[0]),o[f[0].clusterIndex].points.length=0);p=!1;for(let t=0;t<o.length;t++)m=getClusterPosition(o[t].points),o[t].oldX=o[t].posX,o[t].oldY=o[t].posY,o[t].posX=m.x,o[t].posY=m.y,(o[t].posX>o[t].oldX+1||o[t].posX<o[t].oldX-1||o[t].posY>o[t].oldY+1||o[t].posY<o[t].oldY-1)&&(p=!0);d&&(p=u<d-1),u++}for(let t=0,e=o.length;t<e;++t)n["cluster"+t]=o[t].points;for(let t=0,e=r.length;t<e;++t)n["noise"+t]=[r[t]];return n},optimizedKmeans:function(t,e,a,s){var i=this,o=s.processedDistance||clusterDefaults.layoutAlgorithm.gridSize,r=i.getRealExtremes(),n=(i.options.cluster||{}).marker;let l,d={},u,p;if(!i.markerClusterInfo||i.initMaxX&&i.initMaxX<r.maxX||i.initMinX&&i.initMinX>r.minX||i.initMaxY&&i.initMaxY<r.maxY||i.initMinY&&i.initMinY>r.minY)i.initMaxX=r.maxX,i.initMinX=r.minX,i.initMaxY=r.maxY,i.initMinY=r.minY,d=i.markerClusterAlgorithms?i.markerClusterAlgorithms.kmeans.call(i,t,e,a,s):{},i.baseClusters=null;else{i.baseClusters??(i.baseClusters={clusters:i.markerClusterInfo.clusters,noise:i.markerClusterInfo.noise});for(const m of i.baseClusters.clusters){m.pointsOutside=[],m.pointsInside=[];for(const f of m.data){var c=valuesToPixels(i,f),h=valuesToPixels(i,m);l=Math.sqrt(Math.pow(c.x-h.x,2)+Math.pow(c.y-h.y,2)),u=0<=o-(p=(m.clusterZone?.marker?.radius?m.clusterZone.marker:n?.radius?n:clusterDefaults.marker).radius)?o-p:p,l>p+u&&defined(m.pointsOutside)?m.pointsOutside.push(f):defined(m.pointsInside)&&m.pointsInside.push(f)}m.pointsInside.length&&(d[m.id]=m.pointsInside);let t=0;for(const x of m.pointsOutside)d[m.id+"_noise"+t++]=[x]}for(const g of i.baseClusters.noise)d[g.id]=g.data}return d}};let baseGeneratePoints,oldPointsStateId=[],stateIdCounter=0;function compose(t,e){const a=e.prototype;a.markerClusterAlgorithms||(baseGeneratePoints=a.generatePoints,a.markerClusterAlgorithms=markerClusterAlgorithms,a.animateClusterPoint=seriesAnimateClusterPoint,a.destroyClusteredData=seriesDestroyClusteredData,a.generatePoints=seriesGeneratePoints,a.getClusterDistancesFromPoint=seriesGetClusterDistancesFromPoint,a.getClusteredData=seriesGetClusteredData,a.getGridOffset=seriesGetGridOffset,a.getPointsState=seriesGetPointsState,a.getRealExtremes=seriesGetRealExtremes,a.getScaledGridSize=seriesGetScaledGridSize,a.hideClusteredData=seriesHideClusteredData,a.isValidGroupedDataObject=seriesIsValidGroupedDataObject,a.preventClusterCollisions=seriesPreventClusterCollisions,addEvent(e,"destroy",a.destroyClusteredData),t.plotOptions&&(t.plotOptions.series=merge(t.plotOptions.series,MarkerClusterDefaults)))}function destroyOldPoints(t){for(const e of Object.keys(t))t[e].point?.destroy?.()}function fadeInElement(t,e,a){t.attr({opacity:e}).animate({opacity:1},a)}function fadeInNewPointAndDestoryOld(t,e,a,s){fadeInStatePoint(t,s,a,!0,!0);for(const i of e)i.point?.destroy?.()}function fadeInStatePoint(t,e,a,s,i){t.point&&(s&&t.point.graphic&&(t.point.graphic.show(),fadeInElement(t.point.graphic,e,a)),i&&t.point.dataLabel&&(t.point.dataLabel.show(),fadeInElement(t.point.dataLabel,e,a)))}function getClusterPosition(e){var a=e.length;let s=0,i=0;for(let t=0;t<a;t++)s+=e[t].x,i+=e[t].y;return{x:s/a,y:i/a}}function getDataState(t,e){const a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function getStateId(){return Math.random().toString(36).substring(2,7)+"-"+stateIdCounter++}function hideStatePoint(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function onPointDrillToCluster(t){const e=t.point||t.target;e.firePointEvent("drillToCluster",t,function(i){const t=i.point||i.target,e=t.series,{xAxis:o,yAxis:r,chart:n}=e,{inverted:l,mapView:a,pointer:d}=n,s=e.options.cluster?.drillToCluster;if(s&&t.clusteredData){var i=t.clusteredData.map(t=>t.x).sort((t,e)=>t-e),u=t.clusteredData.map(t=>t.y).sort((t,e)=>t-e),p=i[0],i=i[i.length-1],c=u[0],u=u[u.length-1],h=Math.abs(.1*(i-p)),m=Math.abs(.1*(u-c)),f=Math.min(p,i)-h,p=Math.max(p,i)+h,i=Math.min(c,u)-m,h=Math.max(c,u)+m;if(a)a.fitToBounds({x1:f,x2:p,y1:i,y2:h});else if(o&&r){let t=o.toPixels(f),e=o.toPixels(p),a=r.toPixels(i),s=r.toPixels(h);l&&([t,e,a,s]=[a,s,t,e]),t>e&&([t,e]=[e,t]),a>s&&([a,s]=[s,a]),d&&(d.zoomX=!0,d.zoomY=!0),n.transform({from:{x:t,y:a,width:e-t,height:s-a}})}}})}function pixelsToValues(t,e){const{chart:a,xAxis:s,yAxis:i}=t;return a.mapView?a.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:i?i.toValue(e.y):0}}function seriesAnimateClusterPoint(t){const e=this.chart,a=e.mapView,s=animObject(this.options.cluster?.animation),i=s.duration||500,o=this.markerClusterInfo?.pointsState,r=o?.newState,n=o?.oldState,l=[];let d,u,p,c,h,m,f,x=!1,g=!1;var y;n&&r&&(y=valuesToPixels(this,p=r[t.stateId]),m=y.x-(a?0:e.plotLeft),f=y.y-(a?0:e.plotTop),1===p.parentsId.length?(d=r?.[t.stateId].parentsId[0],u=n[d],p.point?.graphic&&u.point?.plotX&&u.point.plotY&&(u.point.plotX!==p.point.plotX||u.point.plotY!==p.point.plotY)&&(c=p.point.graphic.getBBox(),h=p.point.graphic?.isImg?0:c.width/2,p.point.graphic.attr({x:u.point.plotX-h,y:u.point.plotY-h}),p.point.graphic.animate({x:m-(p.point.graphic.radius||0),y:f-(p.point.graphic.radius||0)},s,function(){g=!0,u.point?.destroy?.()}),p.point.dataLabel?.alignAttr&&u.point.dataLabel?.alignAttr&&(p.point.dataLabel.attr({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y}),p.point.dataLabel.animate({x:p.point.dataLabel.alignAttr.x,y:p.point.dataLabel.alignAttr.y},s)))):0===p.parentsId.length?(hideStatePoint(p,!0,!0),syncTimeout(function(){fadeInStatePoint(p,.1,s,!0,!0)},i/2)):(hideStatePoint(p,!0,!0),p.parentsId.forEach(function(t){n?.[t]&&(u=n[t],l.push(u),u.point?.graphic&&(x=!0,u.point.graphic.show(),u.point.graphic.animate({x:m-(u.point.graphic.radius||0),y:f-(u.point.graphic.radius||0),opacity:.4},s,function(){g=!0,fadeInNewPointAndDestoryOld(p,l,s,.7)}),u.point.dataLabel&&-9999!==u.point.dataLabel.y&&p.point?.dataLabel?.alignAttr&&(u.point.dataLabel.show(),u.point.dataLabel.animate({x:p.point.dataLabel.alignAttr.x,y:p.point.dataLabel.alignAttr.y,opacity:.4},s))))}),syncTimeout(function(){g||fadeInNewPointAndDestoryOld(p,l,s,.85)},i),x||syncTimeout(function(){fadeInNewPointAndDestoryOld(p,l,s,.1)},i/2)))}function seriesDestroyClusteredData(){this.markerClusterSeriesData?.forEach(t=>{t?.destroy?.()}),this.markerClusterSeriesData=null}function seriesGeneratePoints(){const a=this,t=a["chart"],e=t.mapView,s=a.getColumn("x"),i=a.getColumn("y"),o=a.options.cluster,r=a.getRealExtremes(),n=[],l=[],d=[];let u,p,c,h,m,f,x,g,y,C,I,S,P,D,b,M;if(e&&a.is("mappoint")&&s&&i&&a.options.data?.forEach((t,e)=>{t=a.projectPoint(t);t&&(s[e]=t.x,i[e]=t.y)}),o?.enabled&&s?.length&&i?.length&&!t.polar){I=o.layoutAlgorithm.type,(b=o.layoutAlgorithm).processedGridSize=relativeLength(b.gridSize||clusterDefaults.layoutAlgorithm.gridSize,t.plotWidth),b.processedDistance=relativeLength(b.distance||clusterDefaults.layoutAlgorithm.distance,t.plotWidth),h=b.kmeansThreshold||clusterDefaults.layoutAlgorithm.kmeansThreshold;var k=b.processedGridSize/2,A=pixelsToValues(a,{x:0,y:0}),k=pixelsToValues(a,{x:k,y:k});m=Math.abs(A.x-k.x),f=Math.abs(A.y-k.y);for(let t=0;t<s.length;t++)a.dataMaxX||(defined(g)&&defined(x)&&defined(C)&&defined(y)?isNumber(i[t])&&isNumber(C)&&isNumber(y)&&(g=Math.max(s[t],g),x=Math.min(s[t],x),C=Math.max(i[t]||C,C),y=Math.min(i[t]||y,y)):(g=x=s[t],C=y=i[t])),s[t]>=r.minX-m&&s[t]<=r.maxX+m&&(i[t]||r.minY)>=r.minY-f&&(i[t]||r.maxY)<=r.maxY+f&&(n.push(s[t]),l.push(i[t]),d.push(t));defined(g)&&defined(x)&&isNumber(C)&&isNumber(y)&&(a.dataMaxX=g,a.dataMinX=x,a.dataMaxY=C,a.dataMinY=y),P=(D=(S=isFunction(I)?I:a.markerClusterAlgorithms?I&&a.markerClusterAlgorithms[I]?a.markerClusterAlgorithms[I]:n.length<h?a.markerClusterAlgorithms.kmeans:a.markerClusterAlgorithms.grid:()=>!1).call(this,n,l,d,b))&&a.getClusteredData(D,o),u=o.animation&&a.markerClusterInfo?.pointsState?.oldState?(destroyOldPoints(a.markerClusterInfo.pointsState.oldState),a.markerClusterInfo.pointsState.newState):{},p=s.length,c=a.markerClusterInfo,P&&(a.dataTable.modified=new DataTableCore({columns:{x:P.groupedXData,y:P.groupedYData}}),a.hasGroupedData=!0,a.markerClusterInfo=P,a.groupMap=P.groupMap),baseGeneratePoints.apply(this),P&&a.markerClusterInfo&&(a.markerClusterInfo.clusters?.forEach(t=>{(M=a.points[t.index]).isCluster=!0,M.clusteredData=t.data,M.clusterPointsAmount=t.data.length,t.point=M,addEvent(M,"click",onPointDrillToCluster)}),a.markerClusterInfo.noise?.forEach(t=>{t.point=a.points[t.index]}),o.animation&&a.markerClusterInfo&&(a.markerClusterInfo.pointsState={oldState:u,newState:a.getPointsState(P,c,p)}),o.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else baseGeneratePoints.apply(this)}function seriesGetClusterDistancesFromPoint(e,a,s){const i=[];for(let t=0;t<e.length;t++){var o=valuesToPixels(this,{x:a,y:s}),r=valuesToPixels(this,{x:e[t].posX,y:e[t].posY}),o=Math.sqrt(Math.pow(o.x-r.x,2)+Math.pow(o.y-r.y,2));i.push({clusterIndex:t,distance:o})}return i.sort((t,e)=>t.distance-e.distance)}function seriesGetClusteredData(e,a){const t=this,s=t.options.data,i=[],o=[],r=[],n=[],l=[],d=Math.max(2,a.minimumClusterSize||2);let u=0,p,c,h,m,f,x,g,y,C,I,S,P;if(isFunction(a.layoutAlgorithm.type)&&!t.isValidGroupedDataObject(e))return error("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,t.chart),!1;for(const D in e)if(e[D].length>=d){if(h=e[D],p=getStateId(),f=h.length,a.zones)for(let t=0;t<a.zones.length;t++)f>=a.zones[t].from&&f<=a.zones[t].to&&((S=a.zones[t]).zoneIndex=t,I=a.zones[t].marker,P=a.zones[t].className);C=getClusterPosition(h),g="grid"!==a.layoutAlgorithm.type||a.allowOverlap?{x:C.x,y:C.y}:(x=t.options.marker||{},t.preventClusterCollisions({x:C.x,y:C.y,key:D,groupedData:e,gridSize:t.getScaledGridSize(a.layoutAlgorithm),defaultRadius:x.radius||3+(x.lineWidth||0),clusterRadius:I&&I.radius?I.radius:(a.marker||{}).radius||clusterDefaults.marker.radius}));for(let t=0;t<f;t++)h[t].parentStateId=p;if(r.push({x:g.x,y:g.y,id:D,stateId:p,index:u,data:h,clusterZone:S,clusterZoneClassName:P}),i.push(g.x),o.push(g.y),l.push({options:{formatPrefix:"cluster",dataLabels:a.dataLabels,marker:merge(a.marker,{states:a.states},I||{})}}),s?.length)for(let t=0;t<f;t++)isObject(s[h[t].dataIndex])&&(h[t].options=s[h[t].dataIndex]);u++,I=null}else for(let t=0;t<e[D].length;t++)c=e[D][t],p=getStateId(),y=null,m=s?.[c.dataIndex],i.push(c.x),o.push(c.y),c.parentStateId=p,n.push({x:c.x,y:c.y,id:D,stateId:p,index:u,data:e[D]}),y=m&&"object"==typeof m&&!isArray(m)?merge(m,{x:c.x,y:c.y}):{userOptions:m,x:c.x,y:c.y},l.push({options:y}),u++;return{clusters:r,noise:n,groupedXData:i,groupedYData:o,groupMap:l}}function seriesGetGridOffset(){const t=this,{chart:e,xAxis:a,yAxis:s}=t;let i=0,o=0;return i=a&&t.dataMinX&&t.dataMaxX?a.reversed?a.toPixels(t.dataMaxX):a.toPixels(t.dataMinX):e.plotLeft,o=s&&t.dataMinY&&t.dataMaxY?s.reversed?s.toPixels(t.dataMinY):s.toPixels(t.dataMaxY):e.plotTop,{plotLeft:i,plotTop:o}}function seriesGetPointsState(t,e,a){const s=e?getDataState(e,a):[],i=getDataState(t,a),o={};var r,n;oldPointsStateId=[],t.clusters.forEach(t=>{o[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(t=>{o[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<i.length;t++)r=i[t],n=s[t],r?.parentStateId&&n?.parentStateId&&-1===o[r.parentStateId]?.parentsId.indexOf(n.parentStateId)&&(o[r.parentStateId].parentsId.push(n.parentStateId),-1===oldPointsStateId.indexOf(n.parentStateId)&&oldPointsStateId.push(n.parentStateId));return o}function seriesGetRealExtremes(){var t=this.chart,e=t.mapView?0:t.plotLeft,a=pixelsToValues(this,{x:e,y:t.mapView?0:t.plotTop}),e=pixelsToValues(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=a.x,s=e.x,a=a.y,e=e.y;return{minX:Math.min(t,s),maxX:Math.max(t,s),minY:Math.min(a,e),maxY:Math.max(a,e)}}function seriesGetScaledGridSize(t){const e=this,a=e.xAxis,s=e.chart.mapView,i=t.processedGridSize||clusterDefaults.layoutAlgorithm.gridSize;let o=!0,r=1,n=1;e.gridValueSize||(s?e.gridValueSize=i/s.getScale():e.gridValueSize=Math.abs(a.toValue(i)-a.toValue(0)));for(var l=+(i/(s?e.gridValueSize*s.getScale():a.toPixels(e.gridValueSize)-a.toPixels(0))).toFixed(14);o&&1!=l;){var d=Math.pow(2,r);.75<l&&l<1.25?o=!1:1/d<=l&&l<1/d*2?(o=!1,n=d):l<=d&&d/2<l&&(o=!1,n=1/d),r++}return i/n/l}function seriesHideClusteredData(){const t=this.markerClusterSeriesData,e=this.markerClusterInfo?.pointsState?.oldState,a=oldPointsStateId.map(t=>e?.[t].point?.id||"");t?.forEach(t=>{t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t?.destroy?.()})}function seriesIsValidGroupedDataObject(t){let a=!1;return!!isObject(t)&&(objectEach(t,e=>{if(a=!0,isArray(e)&&e.length){for(let t=0;t<e.length;t++)if(!isObject(e[t])||!e[t].x||!e[t].y)return void(a=!1)}else a=!1}),a)}function seriesPreventClusterCollisions(e){const t=this,[a,s]=e.key.split(":").map(parseFloat),i=e.gridSize,o=e.groupedData,r=e.defaultRadius,n=e.clusterRadius,l=s*i,d=a*i,u=valuesToPixels(t,e),p=[],c=t.options.cluster?.marker,h=t.options.cluster?.zones,m=t.getGridOffset();let f=u.x,x=u.y,g,y=0,C,I,S,P,D,b,M,k,A,X,Y,T;f-=m.plotLeft,x-=m.plotTop;for(let t=1;t<5;t++)for(S=t%2?-1:1,P=t<3?-1:1,D=Math.floor((f+S*n)/i),T=[(b=Math.floor((x+P*n)/i))+":"+D,b+":"+s,a+":"+D],M=0;M<T.length;M++)-1===p.indexOf(T[M])&&T[M]!==e.key&&p.push(T[M]);for(const G of p)if(o[G]){o[G].posX||(X=getClusterPosition(o[G]),o[G].posX=X.x,o[G].posY=X.y);const v=valuesToPixels(t,{x:o[G].posX||0,y:o[G].posY||0});if(C=v.x-m.plotLeft,I=v.y-m.plotTop,[A,k]=G.split(":").map(parseFloat),h){g=o[G].length;for(let t=0;t<h.length;t++)g>=h[t].from&&g<=h[t].to&&(y=defined(h[t].marker?.radius)?h[t].marker.radius||0:(c?.radius?c:clusterDefaults.marker).radius)}1<o[G].length&&0===y&&c?.radius?y=c.radius:1===o[G].length&&(y=r),Y=n+y,y=0,k!==s&&Math.abs(f-C)<Y&&(f=k-s<0?l+n:l+i-n),A!==a&&Math.abs(x-I)<Y&&(x=A-a<0?d+n:d+i-n)}const v=pixelsToValues(t,{x:f+m.plotLeft,y:x+m.plotTop});return o[e.key].posX=v.x,o[e.key].posY=v.y,v}function valuesToPixels(t,e){const{chart:a,xAxis:s,yAxis:i}=t;return a.mapView?a.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:i?i.toPixels(e.y):0}}const MarkerClusterScatter={compose:compose};export default MarkerClusterScatter;