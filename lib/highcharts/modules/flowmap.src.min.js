!function(t,o){"object"==typeof exports&&"object"==typeof module?module.exports=o(t._Highcharts,t._Highcharts.SeriesRegistry):"function"==typeof define&&define.amd?define("highcharts/modules/flowmap",["highcharts/highcharts"],function(t){return o(t,t.SeriesRegistry)}):"object"==typeof exports?exports["highcharts/modules/flowmap"]=o(t._Highcharts,t._Highcharts.SeriesRegistry):t.Highcharts=o(t.Highcharts,t.Highcharts.SeriesRegistry)}("undefined"==typeof window?this:window,(P,b)=>(()=>{"use strict";var i={512:t=>{t.exports=b},944:t=>{t.exports=P}},e={};function s(t){var o=e[t];if(void 0!==o)return o.exports;o=e[t]={exports:{}};return i[t](o,o.exports,s),o.exports}s.n=t=>{var o=t&&t.__esModule?()=>t.default:()=>t;return s.d(o,{a:o}),o},s.d=(t,o)=>{for(var i in o)s.o(o,i)&&!s.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:o[i]})},s.o=(t,o)=>Object.prototype.hasOwnProperty.call(t,o);var t={},o=(s.d(t,{default:()=>v}),s(944)),o=s.n(o),r=s(512),r=s.n(r),{prototype:{pointClass:n}}=r()["seriesTypes"]["mapline"];const{pick:a,isString:h,isNumber:p}=o();class l extends n{isValid(){let o=!(!this.options.to||!this.options.from);return[this.options.to,this.options.from].forEach(function(t){o=!!(o&&t&&(h(t)||p(a(t[0],t.lat))&&p(a(t[1],t.lon))))}),o}}n=l;const{series:{prototype:{pointClass:d}},seriesTypes:{column:c,map:f,mapline:g}}=r(),{addEvent:m,arrayMax:u,arrayMin:y,defined:W,extend:w,isArray:x,merge:k,pick:A,relativeLength:M}=o();class O extends g{static getLength(t,o){return Math.sqrt(t*t+o*o)}static normalize(t,o){var i=this.getLength(t,o);return[t/i,o/i]}static markerEndPath(t,o,i,e){var s,r,n=M(e.width||0,this.getLength(o[0]-t[0],o[1]-t[1])),e=e.markerType||"arrow",[a,h]=this.normalize(o[0]-t[0],o[1]-t[1]);const p=[];return"arrow"===e&&([s,r]=t,s-=a*n,r-=h*n,p.push(["L",s,r]),p.push(["L",i[0],i[1]]),[s,r]=o,s+=a*n,r+=h*n,p.push(["L",s,r])),"mushroom"===e&&([s,r]=t,[e,t]=o,[o,i]=i,o=2*(o-(o=(e-s)/2+s))+o,i=2*(i-(i=(t-r)/2+r))+i,s-=a*n,r-=h*n,p.push(["L",s,r]),e+=a*n,t+=h*n,p.push(["Q",o,i,e,t])),p}animate(t){const o=this.points;t||o.forEach(t=>{if(t.shapeArgs&&x(t.shapeArgs.d)&&t.shapeArgs.d.length){var i=t.shapeArgs.d,e=i[0][1],s=i[0][2];if(e&&s){const r=[];for(let o=0;o<i.length;o++){r.push([...i[o]]);for(let t=1;t<i[o].length;t++)r[o][t]=t%2?e:s}t.graphic&&(t.graphic.attr({d:r}),t.graphic.animate({d:i}))}}})}getLinkWidth(t){var o=this.options.width,i=t.options.weight||this.options.weight;if(t.options.weight=i,o&&!i)return o;t=this.smallestWeight,o=this.greatestWeight;if(!W(i)||!t||!o)return 0;var e=this.options.minWidth;return(i-t)*(this.options.maxWidth-e)/(o-t||1)+e}autoCurve(t,o,i,e,s,r){const n=i-t,a=e-o,h=(i-t)/2+t,p=(e-o)/2+o,l=h-s,c=p-r;i=n*l+a*c,t=n*c-a*l;let d=Math.atan2(t,i),f=180*d/Math.PI;return d=(f=f<0?360+f:f)*Math.PI/180,.7*-Math.sin(d)}pointAttribs(t,o){const i=f.prototype.pointAttribs.call(this,t,o);return i.fill=A(t.options.fillColor,t.options.color,"none"===this.options.fillColor?null:this.options.fillColor,this.color),i["fill-opacity"]=A(t.options.fillOpacity,this.options.fillOpacity),i["stroke-width"]=A(t.options.lineWidth,this.options.lineWidth,1),t.options.opacity&&(i.opacity=t.options.opacity),i}translate(){!this.chart.hasRendered||!this.isDirtyData&&this.hasRendered||(this.processData(),this.generatePoints());const p=[];let l=0,c=0;this.points.forEach(t=>{const o=this.chart,i=o.mapView,e=t.options,s=()=>{t.series.isDirty=!0},r=t=>{t=o.get(t);if(t instanceof d&&t.plotX&&t.plotY)return m(t,"update",s),{x:t.plotX,y:t.plotY}},n=t=>x(t)?{lon:t[0],lat:t[1]}:t;let a,h;"string"==typeof e.from?a=r(e.from):"object"==typeof e.from&&i&&(a=i.lonLatToPixels(n(e.from))),"string"==typeof e.to?h=r(e.to):"object"==typeof e.to&&i&&(h=i.lonLatToPixels(n(e.to))),t.fromPos=a,t.toPos=h,a&&h&&(l+=(a.x+h.x)/2,c+=(a.y+h.y)/2),A(t.options.weight,this.options.weight)&&p.push(A(t.options.weight,this.options.weight))}),this.smallestWeight=y(p),this.greatestWeight=u(p),this.centerOfPoints={x:l/this.points.length,y:c/this.points.length},this.points.forEach(t=>{this.getLinkWidth(t)?(t.fromPos&&(t.plotX=t.fromPos.x,t.plotY=t.fromPos.y),t.shapeType="path",t.shapeArgs=this.getPointShapeArgs(t),t.color=A(t.options.color,t.series.color)):t.shapeArgs={d:[]}})}getPointShapeArgs(t){var{fromPos:o,toPos:i}=t;if(!o||!i)return{};var e=this.getLinkWidth(t)/2,s=t.options,r=k(this.options.markerEnd,s.markerEnd),n=A(s.growTowards,this.options.growTowards),a=o.x||0,o=o.y||0;let h=i.x||0,p=i.y||0,l=A(s.curveFactor,this.options.curveFactor),c=r&&r.enabled&&r.height||0;if(W(l)||(l=this.autoCurve(a,o,h,p,this.centerOfPoints.x,this.centerOfPoints.y)),c){c=M(c,4*e);var s=h-a,d=p-o;const f=a+(s*=.5),g=o+(d*=.5),m=s,x=(s=d,d=-m,f+s*l),v=g+d*l;var[s,d]=O.normalize(x-h,v-p);s*=c,d*=c,h+=s,p+=d}s=h-a,d=p-o;const f=a+(s*=.5),g=o+(d*=.5);let m=s,[u,y]=(s=d,d=-m,O.normalize(s,d));var w=1+.25*Math.sqrt(l*l);u*=e*w,y*=e*w;const x=f+s*l,v=g+d*l;let[P,b]=O.normalize(x-a,v-o);m=P,P=b,b=-m,P*=e,b*=e;var[w,s]=O.normalize(x-h,v-p);m=w,w=-s,s=m,w*=e,s*=e,n&&(P/=e,b/=e,u/=4,y/=4);const L={d:[["M",a-P,o-b],["Q",x-u,v-y,h-w,p-s],["L",h+w,p+s],["Q",x+u,v+y,a+P,o+b],["Z"]]};r&&r.enabled&&L.d&&(d=O.markerEndPath([h-w,p-s],[h+w,p+s],[i.x,i.y],r),L.d.splice(2,0,...d));n=t.options.from,e=t.options.to,a=n.lat,o=n.lon,w=e.lat,s=e.lon;return a&&o&&(t.options.from=+a+", "+ +o),w&&s&&(t.options.to=+w+", "+ +s),L}}O.defaultOptions=k(g.defaultOptions,{animation:!0,dataLabels:{enabled:!1},fillOpacity:.5,markerEnd:{enabled:!0,height:"40%",width:"40%",markerType:"arrow"},width:1,maxWidth:25,minWidth:5,lineWidth:void 0,tooltip:{headerFormat:'<span style="font-size: 0.8em">{series.name}</span><br/>',pointFormat:"{point.options.from} â†’ {point.options.to}: <b>{point.options.weight}</b>"}}),w(O.prototype,{pointClass:n,pointArrayMap:["from","to","weight"],drawPoints:c.prototype.drawPoints,dataColumnKeys:c.prototype.dataColumnKeys,useMapGeometry:!0}),r().registerSeriesType("flowmap",O);const v=o();return t.default})());