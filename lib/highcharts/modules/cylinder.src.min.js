!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(t._Highcharts,t._Highcharts.Color,t._Highcharts.RendererRegistry,t._Highcharts.SeriesRegistry):"function"==typeof define&&define.amd?define("highcharts/modules/cylinder",["highcharts/highcharts"],function(t){return e(t,t.Color,t.RendererRegistry,t.SeriesRegistry)}):"object"==typeof exports?exports["highcharts/modules/cylinder"]=e(t._Highcharts,t._Highcharts.Color,t._Highcharts.RendererRegistry,t._Highcharts.SeriesRegistry):t.Highcharts=e(t.Highcharts,t.Highcharts.Color,t.Highcharts.RendererRegistry,t.Highcharts.SeriesRegistry)}("undefined"==typeof window?this:window,(O,j,F,N)=>(()=>{"use strict";var r={512:t=>{t.exports=N},608:t=>{t.exports=F},620:t=>{t.exports=j},944:t=>{t.exports=O}},s={};function o(t){var e=s[t];if(void 0!==e)return e.exports;e=s[t]={exports:{}};return r[t](e,e.exports,o),e.exports}o.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return o.d(e,{a:e}),e},o.d=(t,e)=>{for(var r in e)o.o(e,r)&&!o.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},o.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var t={},e=(o.d(t,{default:()=>E}),o(944)),e=o.n(e);const y=e()["deg2rad"],d=e()["pick"];function n(t,e,r,s){const o=e.options.chart.options3d,i=d(s,!!r&&e.inverted),h={x:e.plotWidth/2,y:e.plotHeight/2,z:o.depth/2,vd:d(o.depth,1)*d(o.viewDistance,0)},p=e.scale3d||1,n=y*o.beta*(i?-1:1),c=y*o.alpha*(i?-1:1),a={cosA:Math.cos(c),cosB:Math.cos(-n),sinA:Math.sin(c),sinB:Math.sin(-n)};return r||(h.x+=e.plotLeft,h.y+=e.plotTop),t.map(function(t){s=(i?t.y:t.x)-h.x,o=(i?t.x:t.y)-h.y,t=(t.z||0)-h.z;const e={x:(n=a).cosB*s-n.sinB*t,y:-n.sinA*n.sinB*s+n.cosA*o-n.cosB*n.sinA*t,z:n.cosA*n.sinB*s+n.sinA*o+n.cosA*n.cosB*t},r=u(e,h,h.vd);var s,o,n;return r.x=r.x*p+h.x,r.y=r.y*p+h.y,r.z=e.z*p+h.z,{x:i?r.y:r.x,y:i?r.x:r.y,z:r.z}})}function u(t,e,r){e=0<r&&r<Number.POSITIVE_INFINITY?r/(t.z+e.z+r):1;return{x:t.x*e,y:t.y*e}}function i(t){let e=0,r,s;for(r=0;r<t.length;r++)s=(r+1)%t.length,e+=t[r].x*t[s].y-t[s].x*t[r].y;return e/2}var h={perspective:n,perspective3D:u,pointCameraDistance:function(t,e){const r=e.options.chart.options3d,s=e.plotWidth/2,o=e.plotHeight/2,n=d(r.depth,1)*d(r.viewDistance,0)+r.depth,i=Math.sqrt(Math.pow(s-d(t.plotX,t.x),2)+Math.pow(o-d(t.plotY,t.y),2)+Math.pow(n-d(t.plotZ,t.z),2));return i},shapeArea:i,shapeArea3D:function(t,e,r){return i(n(t,e,r))}},p=o(620),p=o.n(p),c=o(608),c=o.n(c);const a=p()["parse"];p=c().getRendererType().prototype.Element3D;class l extends p{constructor(){super(...arguments),this.parts=["top","bottom","front","back"],this.pathType="cylinder"}fillSetter(t){return this.singleSetterForParts("fill",null,{front:t,back:t,top:a(t).brighten(.1).get(),bottom:a(t).brighten(-.1).get()}),this.color=this.fill=t,this}}const x=l,{charts:g,deg2rad:f}=e(),z=h["perspective"],{extend:C,pick:m}=e();function v(t){return!t.some(t=>"C"===t[0])}function b(t){return this.element3d("cylinder",t)}function M(t){var e=this,r=g[e.chartIndex],s=this.cuboidPath(t),o=!s.isTop,n=!s.isFront,i=e.getCylinderEnd(r,t),r=e.getCylinderEnd(r,t,!0);return{front:e.getCylinderFront(i,r),back:e.getCylinderBack(i,r),top:i,bottom:r,zIndexes:{top:o?3:0,bottom:o?0:3,front:n?2:1,back:n?1:2,group:s.zIndexes.group}}}function H(e){const r=[["M",e[0].x,e[0].y]],s=e.length-2;for(let t=1;t<s;t+=3)r.push(["C",e[t].x,e[t].y,e[t+1].x,e[t+1].y,e[t+2].x,e[t+2].y]);return r}function R(t,e){const r=[];var s,o;return v(t)?(s=t[0],o=t[2],"M"===s[0]&&"L"===o[0]&&(r.push(["M",o[1],o[2]]),r.push(t[3]),r.push(["L",s[1],s[2]]))):("C"===t[2][0]&&r.push(["M",t[2][5],t[2][6]]),r.push(t[3],t[4])),v(e)?"M"===(o=e[0])[0]&&(r.push(["L",o[1],o[2]]),r.push(e[3]),r.push(e[2])):(s=e[2],t=e[3],o=e[4],"C"===s[0]&&"C"===t[0]&&"C"===o[0]&&(r.push(["L",o[5],o[6]]),r.push(["C",o[3],o[4],o[1],o[2],t[5],t[6]]),r.push(["C",t[3],t[4],t[1],t[2],s[5],s[6]]))),r.push(["Z"]),r}function w(t,e,r){var{width:s=0,height:o=0,alphaCorrection:n=0}=e,i=m(e.depth,s,0),h=Math.min(s,i)/2,n=f*(t.options.chart.options3d.beta-90+n),r=(e.y||0)+(r?o:0),o=.5519*h,p=s/2+(e.x||0),c=i/2+(e.z||0),s=[{x:0,y:r,z:h},{x:o,y:r,z:h},{x:h,y:r,z:o},{x:h,y:r,z:0},{x:h,y:r,z:-o},{x:o,y:r,z:-h},{x:0,y:r,z:-h},{x:-o,y:r,z:-h},{x:-h,y:r,z:-o},{x:-h,y:r,z:0},{x:-h,y:r,z:o},{x:-o,y:r,z:h},{x:0,y:r,z:h}],a=Math.cos(n),y=Math.sin(n);let d,u,l;for(const x of s)u=x.x,l=x.z,x.x=u*a-l*y+p,x.z=l*a+u*y+c;i=z(s,t,!0);return d=Math.abs(i[3].y-i[9].y)<2.5&&Math.abs(i[0].y-i[6].y)<2.5?this.toLinePath([i[0],i[3],i[6],i[9]],!0):this.getCurvedPath(i)}function T(t,e){const r=t.slice(0,3);var s;return v(e)?"M"===(t=e[0])[0]&&(r.push(e[2]),r.push(e[1]),r.push(["L",t[1],t[2]])):(t=e[0],s=e[1],e=e[2],"M"===t[0]&&"C"===s[0]&&"C"===e[0]&&(r.push(["L",e[5],e[6]]),r.push(["C",e[3],e[4],e[1],e[2],s[5],s[6]]),r.push(["C",s[3],s[4],s[1],s[2],t[1],t[2]]))),r.push(["Z"]),r}var p={compose:function(t){const e=t.prototype;e.cylinder||(e.Element3D.types.cylinder=x,C(e,{cylinder:b,cylinderPath:M,getCurvedPath:H,getCylinderBack:R,getCylinderEnd:w,getCylinderFront:T}))}},h=o(512),h=o.n(h),{pointClass:_}=h().seriesTypes["column"]["prototype"];const A=e()["extend"];class B extends _{}A(B.prototype,{shapeType:"cylinder"});var _=B,P={},k=h().seriesTypes["column"];const{extend:I,merge:L}=e();class S extends k{}S.compose=p.compose,S.defaultOptions=L(k.defaultOptions,P),I(S.prototype,{pointClass:_}),h().registerSeriesType("cylinder",S);const D=S,E=(D.compose(c().getRendererType()),e());return t.default})());