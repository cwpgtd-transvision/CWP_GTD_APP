!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(t._Highcharts,t._Highcharts.Point):"function"==typeof define&&define.amd?define("highcharts/modules/pathfinder",["highcharts/highcharts"],function(t){return n(t,t.Point)}):"object"==typeof exports?exports["highcharts/modules/pathfinder"]=n(t._Highcharts,t._Highcharts.Point):t.Highcharts=n(t.Highcharts,t.Highcharts.Point)}("undefined"==typeof window?this:window,($,tt)=>(()=>{"use strict";var e={260:t=>{t.exports=tt},944:t=>{t.exports=$}},i={};function r(t){var n=i[t];if(void 0!==n)return n.exports;n=i[t]={exports:{}};return e[t](n,n.exports,r),n.exports}r.n=t=>{var n=t&&t.__esModule?()=>t.default:()=>t;return r.d(n,{a:n}),n},r.d=(t,n)=>{for(var e in n)r.o(n,e)&&!r.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:n[e]})},r.o=(t,n)=>Object.prototype.hasOwnProperty.call(t,n);var t={},n=(r.d(t,{default:()=>Q}),r(944)),n=r.n(n);const{defined:c,error:a,merge:x,objectEach:o}=n(),u=n().deg2rad,M=Math.max,l=Math.min;const d=class{constructor(t,n,e){this.init(t,n,e)}init(t,n,e){this.fromPoint=t,this.toPoint=n,this.options=e,this.chart=t.series.chart,this.pathfinder=this.chart.pathfinder}renderPath(t,n){const e=this.chart,i=e.styledMode,r=this.pathfinder,a={};let o=this.graphics&&this.graphics.path;r.group||(r.group=e.renderer.g().addClass("highcharts-pathfinder-group").attr({zIndex:-1}).add(e.seriesGroup)),r.group.translate(e.plotLeft,e.plotTop),o&&o.renderer||(o=e.renderer.path().add(r.group),i||o.attr({opacity:0})),o.attr(n),a.d=t,i||(a.opacity=1),o.animate(a),this.graphics=this.graphics||{},this.graphics.path=o}addMarker(t,n,e){const i=this,r=i.fromPoint.series.chart,a=r.pathfinder,o=r.renderer,s="start"===t?i.fromPoint:i.toPoint,h=s.getPathfinderAnchorPoint(n);let c,x,M,l,d,p,y,f;n.enabled&&((f="start"===t?e[1]:e[e.length-2])&&"M"===f[0]||"L"===f[0])&&(y={x:f[1],y:f[2]},x=s.getRadiansToVector(y,h),c=s.getMarkerVector(x,n.radius,h),M=-x/u,n.width&&n.height?(d=n.width,p=n.height):d=p=2*n.radius,i.graphics=i.graphics||{},l={x:c.x-d/2,y:c.y-p/2,width:d,height:p,rotation:M,rotationOriginX:c.x,rotationOriginY:c.y},i.graphics[t]?i.graphics[t].animate(l):(i.graphics[t]=o.symbol(n.symbol).addClass("highcharts-point-connecting-path-"+t+"-marker highcharts-color-"+this.fromPoint.colorIndex).attr(l).add(a.group),o.styledMode||i.graphics[t].attr({fill:n.color||i.fromPoint.color,stroke:n.lineColor,"stroke-width":n.lineWidth,opacity:0}).animate({opacity:1},s.series.options.animation)))}getPath(t){const n=this.pathfinder,e=this.chart,i=n.algorithms[t.type];let r=n.chartObstacles;return"function"!=typeof i?(a('"'+t.type+'" is not a Pathfinder algorithm.'),{path:[],obstacles:[]}):(i.requiresObstacles&&!r&&(r=n.chartObstacles=n.getChartObstacles(t),e.options.connectors.algorithmMargin=t.algorithmMargin,n.chartObstacleMetrics=n.getObstacleMetrics(r)),i(this.fromPoint.getPathfinderAnchorPoint(t.startMarker),this.toPoint.getPathfinderAnchorPoint(t.endMarker),x({chartObstacles:r,lineObstacles:n.lineObstacles||[],obstacleMetrics:n.chartObstacleMetrics,hardBounds:{xMin:0,xMax:e.plotWidth,yMin:0,yMax:e.plotHeight},obstacleOptions:{margin:t.algorithmMargin},startDirectionX:n.getAlgorithmStartDirection(t.startMarker)},t)))}render(){const t=this,n=t.fromPoint,e=n.series,i=e.chart,r=i.pathfinder,a={};let o=x(i.options.connectors,e.options.connectors,n.options.connectors,t.options);i.styledMode||(a.stroke=o.lineColor||n.color,a["stroke-width"]=o.lineWidth,o.dashStyle&&(a.dashstyle=o.dashStyle)),a.class="highcharts-point-connecting-path highcharts-color-"+n.colorIndex,o=x(a,o),c(o.marker.radius)||(o.marker.radius=l(M(Math.ceil((o.algorithmMargin||8)/2)-1,1),5));var s=t.getPath(o),h=s.path;s.obstacles&&(r.lineObstacles=r.lineObstacles||[],r.lineObstacles=r.lineObstacles.concat(s.obstacles)),t.renderPath(h,a),t.addMarker("start",x(o.marker,o.startMarker),h),t.addMarker("end",x(o.marker,o.endMarker),h)}destroy(){this.graphics&&(o(this.graphics,function(t){t.destroy()}),delete this.graphics)}};function p(n,e){const i=[];for(let t=0;t<n.length;t++){var r,a,o,s,h,c,x=n[t][1],M=n[t][2];"number"==typeof x&&"number"==typeof M&&(0===t?i.push(["M",x,M]):t!==n.length-1&&e?(a=n[t-1],s=n[t+1],a&&s&&(r=a[1],a=a[2],o=s[1],s=s[2],"number"==typeof r&&"number"==typeof o&&"number"==typeof a&&"number"==typeof s&&r!==o&&a!==s&&(h=r<o?1:-1,c=a<s?1:-1,i.push(["L",x-h*Math.min(Math.abs(x-r),e),M-c*Math.min(Math.abs(M-a),e)],["C",x,M,x,M,x+h*Math.min(Math.abs(x-o),e),M+c*Math.min(Math.abs(M-s),e)])))):i.push(["L",x,M]))}return i}const f={applyRadius:p,getLinkPath:{default:function(t){var{x1:t,y1:n,x2:e,y2:i,width:r=0,inverted:a=!1,radius:o,parentVisible:s}=t,h=[["M",t,n],["L",t,n],["C",t,n,t,i,t,i],["L",t,i],["C",t,n,t,i,t,i],["L",t,i]];return s?p([["M",t,n],["L",t+r*(a?-.5:.5),n],["L",t+r*(a?-.5:.5),i],["L",e,i]],o):h},straight:function(t){var{x1:t,y1:n,x2:e,y2:i,width:r=0,inverted:a=!1,parentVisible:o}=t;return o?[["M",t,n],["L",t+r*(a?-1:1),i],["L",e,i]]:[["M",t,n],["L",t,i],["L",t,i]]},curved:function(t){var{x1:t,y1:n,x2:e,y2:i,offset:r=0,width:a=0,inverted:o=!1,parentVisible:s}=t;return s?[["M",t,n],["C",t+r,n,t-r+a*(o?-1:1),i,t+a*(o?-1:1),i],["L",e,i]]:[["M",t,n],["C",t,n,t,i,t,i],["L",e,i]]}}},O=n()["pick"],{min:k,max:w,abs:L}=Math;function A(t,n,e){var i=n-1e-7;let r=e||0,a=t.length-1,o,s;for(;r<=a;)if(0<(s=i-t[o=a+r>>1].xMin))r=1+o;else{if(!(s<0))return o;a=o-1}return 0<r?r-1:0}function C(t,n){let e=A(t,n.x+1)+1;for(;e--;)if(t[e].xMax>=n.x&&(i=t[e],(r=n).x<=i.xMax&&r.x>=i.xMin&&r.y<=i.yMax&&r.y>=i.yMin))return e;var i,r;return-1}function I(n){const e=[];if(n.length){e.push(["M",n[0].start.x,n[0].start.y]);for(let t=0;t<n.length;++t)e.push(["L",n[t].end.x,n[t].end.y])}return e}function R(t,n){t.yMin=w(t.yMin,n.yMin),t.yMax=k(t.yMax,n.yMax),t.xMin=w(t.xMin,n.xMin),t.xMax=k(t.xMax,n.xMax)}function s(t,n,e){const i=[],r=e.chartObstacles,a=C(r,t),o=C(r,n);let s,h=O(e.startDirectionX,L(n.x-t.x)>L(n.y-t.y))?"x":"y",c,x,M,l,d;function p(t,n,e,i,r){const a={x:t.x,y:t.y};return a[n]=e[i||n]+(r||0),a}function y(t,n,e){var i=L(n[e]-t[e+"Min"])>L(n[e]-t[e+"Max"]);return p(n,e,t,e+(i?"Max":"Min"),i?1:-1)}return d=-1<o?(x=r[o],M=y(x,n,h),s={start:M,end:n},M):n,-1<a&&(c=r[a],M=y(c,t,h),i.push({start:t,end:M}),M[h]>=t[h]==M[h]>=d[h]&&(l=t[h="y"===h?"x":"y"]<n[h],i.push({start:M,end:p(M,h,c,h+(l?"Max":"Min"),l?1:-1)}),h="y"===h?"x":"y")),n=i.length?i[i.length-1].end:t,M=p(n,h,d),i.push({start:n,end:M}),h="y"===h?"x":"y",t=p(M,h,d),i.push({start:M,end:t}),i.push(s),{path:n=f.applyRadius(I(i),e.radius),obstacles:i}}function h(t,n,p){const e=O(p.startDirectionX,L(n.x-t.x)>L(n.y-t.y)),i=e?"x":"y",r=[],a=p.obstacleMetrics,y=k(t.x,n.x)-a.maxWidth-10,f=w(t.x,n.x)+a.maxWidth+10,u=k(t.y,n.y)-a.maxHeight-10,g=w(t.y,n.y)+a.maxHeight+10;let o,s,h,m=!1,b=p.chartObstacles,c=A(b,f);var x,M,l,d=A(b,y);function v(t,n,e){var i=t.x<n.x?1:-1;let r,a,o,s,h=(a=t.x<n.x?(r=t,n):(r=n,t),o=t.y<n.y?(s=t,n):(s=n,t),i<0?k(A(b,a.x),b.length-1):0);for(;b[h]&&(0<i&&b[h].xMin<=a.x||i<0&&b[h].xMax>=r.x);){if(b[h].xMin<=a.x&&b[h].xMax>=r.x&&b[h].yMin<=o.y&&b[h].yMax>=s.y)return e?{y:t.y,x:t.x<n.x?b[h].xMin-1:b[h].xMax+1,obstacle:b[h]}:{x:t.x,y:t.y<n.y?b[h].yMin-1:b[h].yMax+1,obstacle:b[h]};h+=i}return n}function P(t,n,e,i,r){const a=r.soft,o=r.hard,s=i?"x":"y",h={x:n.x,y:n.y},c={x:n.x,y:n.y},x=t[s+"Max"]>=a[s+"Max"],M=t[s+"Min"]<=a[s+"Min"],l=t[s+"Max"]>=o[s+"Max"],d=t[s+"Min"]<=o[s+"Min"],p=L(t[s+"Min"]-n[s]),y=L(t[s+"Max"]-n[s]);let f=L(p-y)<10?n[s]<e[s]:y<p;c[s]=t[s+"Min"],h[s]=t[s+"Max"];r=v(n,c,i)[s]!==c[s],e=v(n,h,i)[s]!==h[s];return f=r?!e||f:!e&&f,f=M?!x||f:!x&&f,f=d?!l||f:!l&&f}for(b=b.slice(d,c+1),-1<(c=C(b,n))&&(h=(d=b[c],x=n,M=t,l=k(d.xMax-x.x,x.x-d.xMin)<k(d.yMax-x.y,x.y-d.yMin),M=P(d,x,M,l,{soft:p.hardBounds,hard:p.hardBounds}),l?{y:x.y,x:d[M?"xMax":"xMin"]+(M?1:-1)}:{x:x.x,y:d[M?"yMax":"yMin"]+(M?1:-1)}),r.push({end:n,start:h}),n=h);-1<(c=C(b,n));)s=n[i]-t[i]<0,(h={x:n.x,y:n.y})[i]=b[c][s?i+"Max":i+"Min"]+(s?1:-1),r.push({end:n,start:h}),n=h;return{path:I(o=(o=function t(n,e,i){if(n.x===e.x&&n.y===e.y)return[];var r=i?"x":"y",a=p.obstacleOptions.margin,o={soft:{xMin:y,xMax:f,yMin:u,yMax:g},hard:p.hardBounds};let s,h,c,x,M,l,d;return-1<(M=C(b,n))?(M=b[M],x=P(M,n,e,i,o),R(M,p.hardBounds),d=i?{y:n.y,x:M[x?"xMax":"xMin"]+(x?1:-1)}:{x:n.x,y:M[x?"yMax":"yMin"]+(x?1:-1)},-1<(l=C(b,d))&&(R(l=b[l],p.hardBounds),d[r]=x?w(M[r+"Max"]-a+1,(l[r+"Min"]+M[r+"Max"])/2):k(M[r+"Min"]+a-1,(l[r+"Max"]+M[r+"Min"])/2),m=n.x===d.x&&n.y===d.y&&(m&&(d[r]=x?w(M[r+"Max"],l[r+"Max"])+1:k(M[r+"Min"],l[r+"Min"])-1),!m)),h=[{start:n,end:d}]):(s=v(n,{x:(i?e:n).x,y:(i?n:e).y},i),h=[{start:n,end:{x:s.x,y:s.y}}],s[i?"x":"y"]!==e[i?"x":"y"]&&(x=P(s.obstacle,s,e,!i,o),R(s.obstacle,p.hardBounds),c={x:i?s.x:s.obstacle[x?"xMax":"xMin"]+(x?1:-1),y:i?s.obstacle[x?"yMax":"yMin"]+(x?1:-1):s.y},i=!i,h=h.concat(t({x:s.x,y:s.y},c,i)))),h=h.concat(t(h[h.length-1].end,e,!i))}(t,n,e)).concat(r.reverse())),obstacles:o}}h.requiresObstacles=s.requiresObstacles=!0;var y={fastAvoid:h,straight:function(t,n){return{path:[["M",t.x,t.y],["L",n.x,n.y]],obstacles:[{start:t,end:n}]}},simpleConnect:s};const X={connectors:{type:"straight",radius:0,lineWidth:1,marker:{enabled:!1,align:"center",verticalAlign:"middle",inside:!1,lineWidth:1},startMarker:{symbol:"diamond"},endMarker:{symbol:"arrow-filled"}}},j=n()["setOptions"],{defined:_,error:D,merge:g}=n();function m(t){var n=t.shapeArgs;if(n)return{xMin:n.x||0,xMax:(n.x||0)+(n.width||0),yMin:n.y||0,yMax:(n.y||0)+(n.height||0)};n=t.graphic&&t.graphic.getBBox();return n?{xMin:t.plotX-n.width/2,xMax:t.plotX+n.width/2,yMin:t.plotY-n.height/2,yMax:t.plotY+n.height/2}:null}function S(t){var n=m(this);let e,i;switch(t.align){case"right":e="xMax";break;case"left":e="xMin"}switch(t.verticalAlign){case"top":i="yMin";break;case"bottom":i="yMax"}return{x:e?n[e]:(n.xMin+n.xMax)/2,y:i?n[i]:(n.yMin+n.yMax)/2}}function Y(t,n){var e;return _(n)||(e=m(this))&&(n={x:(e.xMin+e.xMax)/2,y:(e.yMin+e.yMax)/2}),Math.atan2(n.y-t.y,t.x-n.x)}function q(t,n,e){const i=2*Math.PI,r=m(this),a=r.xMax-r.xMin,o=r.yMax-r.yMin,s=Math.atan2(o,a),h=a/2,c=o/2,x=r.xMin+h,M=r.yMin+c,l={x:x,y:M};let d=t,p,y=!1,f=1,u=1;for(;d<-Math.PI;)d+=i;for(;d>Math.PI;)d-=i;return p=Math.tan(d),d>-s&&d<=s?(u=-1,y=!0):d>s&&d<=Math.PI-s?u=-1:d>Math.PI-s||d<=-(Math.PI-s)?(f=-1,y=!0):f=-1,y?(l.x+=f*h,l.y+=u*h*p):(l.x+=f*(o/(2*p)),l.y+=u*c),e.x!==x&&(l.x=e.x),e.y!==M&&(l.y=e.y),{x:l.x+n*Math.cos(d),y:l.y-n*Math.sin(d)}}(b||(b={})).compose=function(t,n,e){const i=e.prototype;i.getPathfinderAnchorPoint||(t.prototype.callbacks.push(function(t){!1!==t.options.connectors.enabled&&(((t=t).options.pathfinder||t.series.reduce(function(t,n){return n.options&&g(!0,n.options.connectors=n.options.connectors||{},n.options.pathfinder),t||n.options&&n.options.pathfinder},!1))&&(g(!0,t.options.connectors=t.options.connectors||{},t.options.pathfinder),D('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.')),this.pathfinder=new n(this),this.pathfinder.update(!0))}),i.getMarkerVector=q,i.getPathfinderAnchorPoint=S,i.getRadiansToVector=Y,j(X))};const G=b;var b=r(260),T=r.n(b);const{addEvent:v,defined:N,pick:P,splat:z}=n(),U=Math.max,Z=Math.min;function F(e){const i=e.length,r=[];var a;for(let n=0;n<i;++n)for(let t=n+1;t<i;++t)(a=function t(n,e,i){var i=P(i,10),r=n.yMax+i>e.yMin-i&&n.yMin-i<e.yMax+i,a=n.xMax+i>e.xMin-i&&n.xMin-i<e.xMax+i,o=r?n.xMin>e.xMax?n.xMin-e.xMax:e.xMin-n.xMax:1/0,s=a?n.yMin>e.yMax?n.yMin-e.yMax:e.yMin-n.yMax:1/0;return a&&r?i?t(n,e,Math.floor(i/2)):1/0:Z(o,s)}(e[n],e[t]))<80&&r.push(a);return r.push(80),U(Math.floor(r.sort(function(t,n){return t-n})[Math.floor(r.length/10)]/2-1),1)}class E{static compose(t,n){G.compose(t,E,n)}constructor(t){this.init(t)}init(t){this.chart=t,this.connections=[],v(t,"redraw",function(){this.pathfinder.update()})}update(t){const r=this.chart,a=this,o=a.connections;a.connections=[],r.series.forEach(function(t){t.visible&&!t.options.isInternal&&t.points.forEach(function(e){const t=e.options,n=(t&&t.dependency&&(t.connect=t.dependency),e.options?.connect?z(e.options.connect):[]);let i;e.visible&&!1!==e.isInside&&n.forEach(t=>{var n="string"==typeof t?t:t.to;(i=n?r.get(n):i)instanceof T()&&i.series.visible&&i.visible&&!1!==i.isInside&&a.connections.push(new d(e,i,"string"==typeof t?{}:t))})})});for(let t=0,n,e,i=o.length,r=a.connections.length;t<i;++t){e=!1;const s=o[t];for(n=0;n<r;++n){const h=a.connections[n];if((s.options&&s.options.type)===(h.options&&h.options.type)&&s.fromPoint===h.fromPoint&&s.toPoint===h.toPoint){h.graphics=s.graphics,e=!0;break}}e||s.destroy()}delete this.chartObstacles,delete this.lineObstacles,a.renderConnections(t)}renderConnections(t){t?this.chart.series.forEach(function(e){function t(){const t=e.chart.pathfinder,n=t&&t.connections||[];n.forEach(function(t){t.fromPoint&&t.fromPoint.series===e&&t.render()}),e.pathfinderRemoveRenderEvent&&(e.pathfinderRemoveRenderEvent(),delete e.pathfinderRemoveRenderEvent)}!1===e.options.animation?t():e.pathfinderRemoveRenderEvent=v(e,"afterAnimate",t)}):this.connections.forEach(function(t){t.render()})}getChartObstacles(t){var a,o,s=this.chart.series,h=P(t.algorithmMargin,0);let c=[],n;for(let r=0,t=s.length;r<t;++r)if(s[r].visible&&!s[r].options.isInternal)for(let t=0,n=s[r].points.length,e,i;t<n;++t)(i=s[r].points[t]).visible&&(o=void 0,(e=(o=(a=i).shapeArgs)?{xMin:o.x||0,xMax:(o.x||0)+(o.width||0),yMin:o.y||0,yMax:(o.y||0)+(o.height||0)}:(o=a.graphic&&a.graphic.getBBox())?{xMin:a.plotX-o.width/2,xMax:a.plotX+o.width/2,yMin:a.plotY-o.height/2,yMax:a.plotY+o.height/2}:null)&&c.push({xMin:e.xMin-h,xMax:e.xMax+h,yMin:e.yMin-h,yMax:e.yMax+h}));return c=c.sort(function(t,n){return t.xMin-n.xMin}),N(t.algorithmMargin)||(n=t.algorithmMargin=F(c),c.forEach(function(t){t.xMin-=n,t.xMax+=n,t.yMin-=n,t.yMax+=n})),c}getObstacleMetrics(t){let n=0,e=0,i,r,a=t.length;for(;a--;)i=t[a].xMax-t[a].xMin,r=t[a].yMax-t[a].yMin,n<i&&(n=i),e<r&&(e=r);return{maxHeight:e,maxWidth:n}}getAlgorithmStartDirection(t){var n="left"!==t.align&&"right"!==t.align,t="top"!==t.verticalAlign&&"bottom"!==t.verticalAlign;return n?t&&void 0:t||void 0}}E.prototype.algorithms=y;b=E;function B(t,n,e,i){return[["M",t,n+i/2],["L",t+e,n],["L",t,n+i/2],["L",t+e,n+i]]}function J(t,n,e,i){return B(t,n,e/2,i)}function H(t,n,e,i){return[["M",t+e,n],["L",t,n+i/2],["L",t+e,n+i],["Z"]]}function W(t,n,e,i){return H(t,n,e/2,i)}const K={compose:function(t){const n=t.prototype.symbols;n.arrow=B,n["arrow-filled"]=H,n["arrow-filled-half"]=W,n["arrow-half"]=J,n["triangle-left"]=H,n["triangle-left-half"]=W}},V=n(),Q=(V.Pathfinder=V.Pathfinder||b,K.compose(V.SVGRenderer),V.Pathfinder.compose(V.Chart,V.Point),n());return t.default})());