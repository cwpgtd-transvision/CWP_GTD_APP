!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(t._Highcharts):"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts/highcharts"],function(t){return e(t)}):"object"==typeof exports?exports["highcharts/modules/marker-clusters"]=e(t._Highcharts):t.Highcharts=e(t.Highcharts)}("undefined"==typeof window?this:window,It=>(()=>{"use strict";var o={944:t=>{t.exports=It}},s={};function r(t){var e=s[t];if(void 0!==e)return e.exports;e=s[t]={exports:{}};return o[t](e,e.exports,r),e.exports}r.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return r.d(e,{a:e}),e},r.d=(t,e)=>{for(var o in e)r.o(e,o)&&!r.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var t,e={},a=(r.d(e,{default:()=>Ct}),r(944)),a=r.n(a);const i={cluster:{enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}},{setLength:y,splice:l}=((x=t=t||{}).setLength=function(t,e,o){return Array.isArray(t)?(t.length=e,t):t[o?"subarray":"slice"](0,e)},x.splice=function(t,e,o,s,r=[]){if(Array.isArray(t))return Array.isArray(r)||(r=Array.from(r)),{removed:t.splice(e,o,...r),array:t};const a=Object.getPrototypeOf(t).constructor;var s=t[s?"subarray":"slice"](e,e+o),i=t.length-o+r.length;const n=new a(i);return n.set(t.subarray(0,e),0),n.set(r,e),n.set(t.subarray(e+o),e+r.length),{removed:s,array:n}},t),{fireEvent:p,objectEach:u,uniqueKey:d}=a();const G=class{constructor(t={}){this.autoId=!t.id,this.columns={},this.id=t.id||d(),(this.modified=this).rowCount=0,this.versionTag=d();let o=0;u(t.columns||{},(t,e)=>{this.columns[e]=t.slice(),o=Math.max(o,t.length)}),this.applyRowCount(o)}applyRowCount(o){this.rowCount=o,u(this.columns,(t,e)=>{t.length!==o&&(this.columns[e]=y(t,o))})}deleteRows(s,r=1){if(0<r&&s<this.rowCount){let o=0;u(this.columns,(t,e)=>{this.columns[e]=l(t,s,r).array,o=t.length}),this.rowCount=o}p(this,"afterDeleteRows",{rowIndex:s,rowCount:r}),this.versionTag=d()}getColumn(t,e){return this.columns[t]}getColumns(t,e){return(t||Object.keys(this.columns)).reduce((t,e)=>(t[e]=this.columns[e],t),{})}getRow(e,t){return(t||Object.keys(this.columns)).map(t=>this.columns[t]?.[e])}setColumn(t,e=[],o=0,s){this.setColumns({[t]:e},o,s)}setColumns(t,e,o){let s=this.rowCount;u(t,(t,e)=>{this.columns[e]=t.slice(),s=t.length}),this.applyRowCount(s),o?.silent||(p(this,"afterSetColumns"),this.versionTag=d())}setRow(t,s=this.rowCount,r,a){const i=this["columns"],n=r?this.rowCount+1:s+1;u(t,(t,e)=>{let o=i[e]||!1!==a?.addColumns&&new Array(n);o&&(r?o=l(o,s,0,!0,[t]).array:o[s]=t,i[e]=o)}),n>this.rowCount&&this.applyRowCount(n),a?.silent||(p(this,"afterSetRows"),this.versionTag=d())}},M=a()["animObject"],O=i["cluster"],{addEvent:P,defined:D,error:X,isArray:S,isFunction:L,isObject:A,isNumber:z,merge:w,objectEach:Y,relativeLength:T,syncTimeout:C}=a(),F={grid:function(t,e,o,s){const r={},a=this.getGridOffset(),i=this.getScaledGridSize(s);let n,l,p,u,d;for(d=0;d<t.length;d++){var c=R(this,{x:t[d],y:e[d]});n=c.x-a.plotLeft,l=c.y-a.plotTop,p=Math.floor(n/i),u=Math.floor(l/i)+":"+p,r[u]??(r[u]=[]),r[u].push({dataIndex:o[d],x:t[d],y:e[d]})}return r},kmeans:function(e,o,s,t){const r=this,a=[],i=[],n={},l=t.processedDistance||O.layoutAlgorithm.distance,p=t.iterations;let u=0,d=!0,c,h,m,f=[];t.processedGridSize=t.processedDistance;var g=r.markerClusterAlgorithms?r.markerClusterAlgorithms.grid.call(r,e,o,s,t):{};for(const x in g)1<g[x].length&&(m=j(g[x]),a.push({posX:m.x,posY:m.y,oldX:0,oldY:0,startPointsLen:g[x].length,points:[]}));for(;d;){for(const y of a)y.points.length=0;for(let t=i.length=0;t<e.length;t++)c=e[t],h=o[t],((f=r.getClusterDistancesFromPoint(a,c,h)).length&&f[0].distance<l?a[f[0].clusterIndex].points:i).push({x:c,y:h,dataIndex:s[t]});for(let t=0;t<a.length;t++)1===a[t].points.length&&(f=r.getClusterDistancesFromPoint(a,a[t].points[0].x,a[t].points[0].y))[1].distance<l&&(a[f[1].clusterIndex].points.push(a[t].points[0]),a[f[0].clusterIndex].points.length=0);d=!1;for(let t=0;t<a.length;t++)m=j(a[t].points),a[t].oldX=a[t].posX,a[t].oldY=a[t].posY,a[t].posX=m.x,a[t].posY=m.y,(a[t].posX>a[t].oldX+1||a[t].posX<a[t].oldX-1||a[t].posY>a[t].oldY+1||a[t].posY<a[t].oldY-1)&&(d=!0);p&&(d=u<p-1),u++}for(let t=0,e=a.length;t<e;++t)n["cluster"+t]=a[t].points;for(let t=0,e=i.length;t<e;++t)n["noise"+t]=[i[t]];return n},optimizedKmeans:function(t,e,o,s){var r=this,a=s.processedDistance||O.layoutAlgorithm.gridSize,i=r.getRealExtremes(),n=(r.options.cluster||{}).marker;let l,p={},u,d;if(!r.markerClusterInfo||r.initMaxX&&r.initMaxX<i.maxX||r.initMinX&&r.initMinX>i.minX||r.initMaxY&&r.initMaxY<i.maxY||r.initMinY&&r.initMinY>i.minY)r.initMaxX=i.maxX,r.initMinX=i.minX,r.initMaxY=i.maxY,r.initMinY=i.minY,p=r.markerClusterAlgorithms?r.markerClusterAlgorithms.kmeans.call(r,t,e,o,s):{},r.baseClusters=null;else{r.baseClusters??(r.baseClusters={clusters:r.markerClusterInfo.clusters,noise:r.markerClusterInfo.noise});for(const m of r.baseClusters.clusters){m.pointsOutside=[],m.pointsInside=[];for(const f of m.data){var c=R(r,f),h=R(r,m);l=Math.sqrt(Math.pow(c.x-h.x,2)+Math.pow(c.y-h.y,2)),u=0<=a-(d=(m.clusterZone?.marker?.radius?m.clusterZone.marker:n?.radius?n:O.marker).radius)?a-d:d,l>d+u&&D(m.pointsOutside)?m.pointsOutside.push(f):D(m.pointsInside)&&m.pointsInside.push(f)}m.pointsInside.length&&(p[m.id]=m.pointsInside);let t=0;for(const g of m.pointsOutside)p[m.id+"_noise"+t++]=[g]}for(const x of r.baseClusters.noise)p[x.id]=x.data}return p}};let V,c=[],H=0;function n(t,e,o){t.attr({opacity:e}).animate({opacity:1},o)}function I(t,e,o,s){k(t,s,o,!0,!0);for(const r of e)r.point?.destroy?.()}function k(t,e,o,s,r){t.point&&(s&&t.point.graphic&&(t.point.graphic.show(),n(t.point.graphic,e,o)),r&&t.point.dataLabel&&(t.point.dataLabel.show(),n(t.point.dataLabel,e,o)))}function j(e){var o=e.length;let s=0,r=0;for(let t=0;t<o;t++)s+=e[t].x,r+=e[t].y;return{x:s/o,y:r/o}}function h(t,e){const o=[];return o.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){o[t.dataIndex]=t})}),t.noise.forEach(function(t){o[t.data[0].dataIndex]=t.data[0]}),o}function v(){return Math.random().toString(36).substring(2,7)+"-"+H++}function b(t,e,o){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),o&&t.point.dataLabel&&t.point.dataLabel.hide())}function Z(t){const e=t.point||t.target;e.firePointEvent("drillToCluster",t,function(r){const t=r.point||r.target,e=t.series,{xAxis:a,yAxis:i,chart:n}=e,{inverted:l,mapView:o,pointer:p}=n,s=e.options.cluster?.drillToCluster;if(s&&t.clusteredData){var r=t.clusteredData.map(t=>t.x).sort((t,e)=>t-e),u=t.clusteredData.map(t=>t.y).sort((t,e)=>t-e),d=r[0],r=r[r.length-1],c=u[0],u=u[u.length-1],h=Math.abs(.1*(r-d)),m=Math.abs(.1*(u-c)),f=Math.min(d,r)-h,d=Math.max(d,r)+h,r=Math.min(c,u)-m,h=Math.max(c,u)+m;if(o)o.fitToBounds({x1:f,x2:d,y1:r,y2:h});else if(a&&i){let t=a.toPixels(f),e=a.toPixels(d),o=i.toPixels(r),s=i.toPixels(h);l&&([t,e,o,s]=[o,s,t,e]),t>e&&([t,e]=[e,t]),o>s&&([o,s]=[s,o]),p&&(p.zoomX=!0,p.zoomY=!0),n.transform({from:{x:t,y:o,width:e-t,height:s-o}})}}})}function E(t,e){const{chart:o,xAxis:s,yAxis:r}=t;return o.mapView?o.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:r?r.toValue(e.y):0}}function W(t){const e=this.chart,o=e.mapView,s=M(this.options.cluster?.animation),r=s.duration||500,a=this.markerClusterInfo?.pointsState,i=a?.newState,n=a?.oldState,l=[];let p,u,d,c,h,m,f,g=!1,x=!1;var y;n&&i&&(y=R(this,d=i[t.stateId]),m=y.x-(o?0:e.plotLeft),f=y.y-(o?0:e.plotTop),1===d.parentsId.length?(p=i?.[t.stateId].parentsId[0],u=n[p],d.point?.graphic&&u.point?.plotX&&u.point.plotY&&(u.point.plotX!==d.point.plotX||u.point.plotY!==d.point.plotY)&&(c=d.point.graphic.getBBox(),h=d.point.graphic?.isImg?0:c.width/2,d.point.graphic.attr({x:u.point.plotX-h,y:u.point.plotY-h}),d.point.graphic.animate({x:m-(d.point.graphic.radius||0),y:f-(d.point.graphic.radius||0)},s,function(){x=!0,u.point?.destroy?.()}),d.point.dataLabel?.alignAttr&&u.point.dataLabel?.alignAttr&&(d.point.dataLabel.attr({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y}),d.point.dataLabel.animate({x:d.point.dataLabel.alignAttr.x,y:d.point.dataLabel.alignAttr.y},s)))):0===d.parentsId.length?(b(d,!0,!0),C(function(){k(d,.1,s,!0,!0)},r/2)):(b(d,!0,!0),d.parentsId.forEach(function(t){n?.[t]&&(u=n[t],l.push(u),u.point?.graphic&&(g=!0,u.point.graphic.show(),u.point.graphic.animate({x:m-(u.point.graphic.radius||0),y:f-(u.point.graphic.radius||0),opacity:.4},s,function(){x=!0,I(d,l,s,.7)}),u.point.dataLabel&&-9999!==u.point.dataLabel.y&&d.point?.dataLabel?.alignAttr&&(u.point.dataLabel.show(),u.point.dataLabel.animate({x:d.point.dataLabel.alignAttr.x,y:d.point.dataLabel.alignAttr.y,opacity:.4},s))))}),C(function(){x||I(d,l,s,.85)},r),g||C(function(){I(d,l,s,.1)},r/2)))}function _(){this.markerClusterSeriesData?.forEach(t=>{t?.destroy?.()}),this.markerClusterSeriesData=null}function q(){const o=this,t=o["chart"],e=t.mapView,s=o.getColumn("x"),r=o.getColumn("y"),a=o.options.cluster,i=o.getRealExtremes(),n=[],l=[],p=[];let u,d,c,h,m,f,g,x,y,C,I,k,b,M,S,A;if(e&&o.is("mappoint")&&s&&r&&o.options.data?.forEach((t,e)=>{t=o.projectPoint(t);t&&(s[e]=t.x,r[e]=t.y)}),a?.enabled&&s?.length&&r?.length&&!t.polar){I=a.layoutAlgorithm.type,(S=a.layoutAlgorithm).processedGridSize=T(S.gridSize||O.layoutAlgorithm.gridSize,t.plotWidth),S.processedDistance=T(S.distance||O.layoutAlgorithm.distance,t.plotWidth),h=S.kmeansThreshold||O.layoutAlgorithm.kmeansThreshold;var w=S.processedGridSize/2,v=E(o,{x:0,y:0}),w=E(o,{x:w,y:w});m=Math.abs(v.x-w.x),f=Math.abs(v.y-w.y);for(let t=0;t<s.length;t++)o.dataMaxX||(D(x)&&D(g)&&D(C)&&D(y)?z(r[t])&&z(C)&&z(y)&&(x=Math.max(s[t],x),g=Math.min(s[t],g),C=Math.max(r[t]||C,C),y=Math.min(r[t]||y,y)):(x=g=s[t],C=y=r[t])),s[t]>=i.minX-m&&s[t]<=i.maxX+m&&(r[t]||i.minY)>=i.minY-f&&(r[t]||i.maxY)<=i.maxY+f&&(n.push(s[t]),l.push(r[t]),p.push(t));if(D(x)&&D(g)&&z(C)&&z(y)&&(o.dataMaxX=x,o.dataMinX=g,o.dataMaxY=C,o.dataMinY=y),b=(M=(k=L(I)?I:o.markerClusterAlgorithms?I&&o.markerClusterAlgorithms[I]?o.markerClusterAlgorithms[I]:n.length<h?o.markerClusterAlgorithms.kmeans:o.markerClusterAlgorithms.grid:()=>!1).call(this,n,l,p,S))&&o.getClusteredData(M,a),a.animation&&o.markerClusterInfo?.pointsState?.oldState){var X=o.markerClusterInfo.pointsState.oldState;for(const Y of Object.keys(X))X[Y].point?.destroy?.();u=o.markerClusterInfo.pointsState.newState}else u={};d=s.length,c=o.markerClusterInfo,b&&(o.dataTable.modified=new G({columns:{x:b.groupedXData,y:b.groupedYData}}),o.hasGroupedData=!0,o.markerClusterInfo=b,o.groupMap=b.groupMap),V.apply(this),b&&o.markerClusterInfo&&(o.markerClusterInfo.clusters?.forEach(t=>{(A=o.points[t.index]).isCluster=!0,A.clusteredData=t.data,A.clusterPointsAmount=t.data.length,t.point=A,P(A,"click",Z)}),o.markerClusterInfo.noise?.forEach(t=>{t.point=o.points[t.index]}),a.animation&&o.markerClusterInfo&&(o.markerClusterInfo.pointsState={oldState:u,newState:o.getPointsState(b,c,d)}),a.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else V.apply(this)}function N(e,o,s){const r=[];for(let t=0;t<e.length;t++){var a=R(this,{x:o,y:s}),i=R(this,{x:e[t].posX,y:e[t].posY}),a=Math.sqrt(Math.pow(a.x-i.x,2)+Math.pow(a.y-i.y,2));r.push({clusterIndex:t,distance:a})}return r.sort((t,e)=>t.distance-e.distance)}function B(e,o){const t=this,s=t.options.data,r=[],a=[],i=[],n=[],l=[],p=Math.max(2,o.minimumClusterSize||2);let u=0,d,c,h,m,f,g,x,y,C,I,k,b;if(L(o.layoutAlgorithm.type)&&!t.isValidGroupedDataObject(e))return X("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,t.chart),!1;for(const M in e)if(e[M].length>=p){if(h=e[M],d=v(),f=h.length,o.zones)for(let t=0;t<o.zones.length;t++)f>=o.zones[t].from&&f<=o.zones[t].to&&((k=o.zones[t]).zoneIndex=t,I=o.zones[t].marker,b=o.zones[t].className);C=j(h),x="grid"!==o.layoutAlgorithm.type||o.allowOverlap?{x:C.x,y:C.y}:(g=t.options.marker||{},t.preventClusterCollisions({x:C.x,y:C.y,key:M,groupedData:e,gridSize:t.getScaledGridSize(o.layoutAlgorithm),defaultRadius:g.radius||3+(g.lineWidth||0),clusterRadius:I&&I.radius?I.radius:(o.marker||{}).radius||O.marker.radius}));for(let t=0;t<f;t++)h[t].parentStateId=d;if(i.push({x:x.x,y:x.y,id:M,stateId:d,index:u,data:h,clusterZone:k,clusterZoneClassName:b}),r.push(x.x),a.push(x.y),l.push({options:{formatPrefix:"cluster",dataLabels:o.dataLabels,marker:w(o.marker,{states:o.states},I||{})}}),s?.length)for(let t=0;t<f;t++)A(s[h[t].dataIndex])&&(h[t].options=s[h[t].dataIndex]);u++,I=null}else for(let t=0;t<e[M].length;t++)c=e[M][t],d=v(),y=null,m=s?.[c.dataIndex],r.push(c.x),a.push(c.y),c.parentStateId=d,n.push({x:c.x,y:c.y,id:M,stateId:d,index:u,data:e[M]}),y=m&&"object"==typeof m&&!S(m)?w(m,{x:c.x,y:c.y}):{userOptions:m,x:c.x,y:c.y},l.push({options:y}),u++;return{clusters:i,noise:n,groupedXData:r,groupedYData:a,groupMap:l}}function U(){const t=this,{chart:e,xAxis:o,yAxis:s}=t;let r=0,a=0;return r=o&&t.dataMinX&&t.dataMaxX?o.reversed?o.toPixels(t.dataMaxX):o.toPixels(t.dataMinX):e.plotLeft,a=s&&t.dataMinY&&t.dataMaxY?s.reversed?s.toPixels(t.dataMinY):s.toPixels(t.dataMaxY):e.plotTop,{plotLeft:r,plotTop:a}}function K(t,e,o){const s=e?h(e,o):[],r=h(t,o),a={};var i,n;c=[],t.clusters.forEach(t=>{a[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(t=>{a[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<r.length;t++)i=r[t],n=s[t],i?.parentStateId&&n?.parentStateId&&-1===a[i.parentStateId]?.parentsId.indexOf(n.parentStateId)&&(a[i.parentStateId].parentsId.push(n.parentStateId),-1===c.indexOf(n.parentStateId)&&c.push(n.parentStateId));return a}function J(){var t=this.chart,e=t.mapView?0:t.plotLeft,o=E(this,{x:e,y:t.mapView?0:t.plotTop}),e=E(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=o.x,s=e.x,o=o.y,e=e.y;return{minX:Math.min(t,s),maxX:Math.max(t,s),minY:Math.min(o,e),maxY:Math.max(o,e)}}function Q(t){const e=this,o=e.xAxis,s=e.chart.mapView,r=t.processedGridSize||O.layoutAlgorithm.gridSize;let a=!0,i=1,n=1;e.gridValueSize||(s?e.gridValueSize=r/s.getScale():e.gridValueSize=Math.abs(o.toValue(r)-o.toValue(0)));for(var l=+(r/(s?e.gridValueSize*s.getScale():o.toPixels(e.gridValueSize)-o.toPixels(0))).toFixed(14);a&&1!=l;){var p=Math.pow(2,i);.75<l&&l<1.25?a=!1:1/p<=l&&l<1/p*2?(a=!1,n=p):l<=p&&p/2<l&&(a=!1,n=1/p),i++}return r/n/l}function $(){const t=this.markerClusterSeriesData,e=this.markerClusterInfo?.pointsState?.oldState,o=c.map(t=>e?.[t].point?.id||"");t?.forEach(t=>{t&&-1!==o.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t?.destroy?.()})}function tt(t){let o=!1;return!!A(t)&&(Y(t,e=>{if(o=!0,S(e)&&e.length){for(let t=0;t<e.length;t++)if(!A(e[t])||!e[t].x||!e[t].y)return void(o=!1)}else o=!1}),o)}function et(e){const t=this,[o,s]=e.key.split(":").map(parseFloat),r=e.gridSize,a=e.groupedData,i=e.defaultRadius,n=e.clusterRadius,l=s*r,p=o*r,u=R(t,e),d=[],c=t.options.cluster?.marker,h=t.options.cluster?.zones,m=t.getGridOffset();let f=u.x,g=u.y,x,y=0,C,I,k,b,M,S,A,w,v,X,Y,P;f-=m.plotLeft,g-=m.plotTop;for(let t=1;t<5;t++)for(k=t%2?-1:1,b=t<3?-1:1,M=Math.floor((f+k*n)/r),P=[(S=Math.floor((g+b*n)/r))+":"+M,S+":"+s,o+":"+M],A=0;A<P.length;A++)-1===d.indexOf(P[A])&&P[A]!==e.key&&d.push(P[A]);for(const z of d)if(a[z]){a[z].posX||(X=j(a[z]),a[z].posX=X.x,a[z].posY=X.y);const L=R(t,{x:a[z].posX||0,y:a[z].posY||0});if(C=L.x-m.plotLeft,I=L.y-m.plotTop,[v,w]=z.split(":").map(parseFloat),h){x=a[z].length;for(let t=0;t<h.length;t++)x>=h[t].from&&x<=h[t].to&&(y=D(h[t].marker?.radius)?h[t].marker.radius||0:(c?.radius?c:O.marker).radius)}1<a[z].length&&0===y&&c?.radius?y=c.radius:1===a[z].length&&(y=i),Y=n+y,y=0,w!==s&&Math.abs(f-C)<Y&&(f=w-s<0?l+n:l+r-n),v!==o&&Math.abs(g-I)<Y&&(g=v-o<0?p+n:p+r-n)}const L=E(t,{x:f+m.plotLeft,y:g+m.plotTop});return a[e.key].posX=L.x,a[e.key].posY=L.y,L}function R(t,e){const{chart:o,xAxis:s,yAxis:r}=t;return o.mapView?o.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:r?r.toPixels(e.y):0}}const ot={compose:function(t,e){const o=e.prototype;o.markerClusterAlgorithms||(V=o.generatePoints,o.markerClusterAlgorithms=F,o.animateClusterPoint=W,o.destroyClusteredData=_,o.generatePoints=q,o.getClusterDistancesFromPoint=N,o.getClusteredData=B,o.getGridOffset=U,o.getPointsState=K,o.getRealExtremes=J,o.getScaledGridSize=Q,o.hideClusteredData=$,o.isValidGroupedDataObject=tt,o.preventClusterCollisions=et,P(e,"destroy",o.destroyClusteredData),t.plotOptions&&(t.plotOptions.series=w(t.plotOptions.series,i)))}},st=a()["animObject"],m=a()["defaultOptions"],rt=a()["composed"],{addEvent:f,defined:at,error:it,isFunction:nt,merge:lt,pushUnique:pt,syncTimeout:ut}=a();function dt(){const t=this.chart;let e=0;for(const o of t.series)o.markerClusterInfo&&(e=st((o.options.cluster||{}).animation).duration||0);ut(()=>{t.tooltip&&t.tooltip.destroy()},e)}function ct(){for(const o of this.series||[])if(o.markerClusterInfo){var t=o.options.cluster,e=((o.markerClusterInfo||{}).pointsState||{}).oldState;if((t||{}).animation&&o.markerClusterInfo&&0===(o.chart.pointer?.pinchDown||[]).length&&"pan"!==((o.xAxis||{}).eventArgs||{}).trigger&&e&&Object.keys(e).length){for(const s of o.markerClusterInfo.clusters)o.animateClusterPoint(s);for(const r of o.markerClusterInfo.noise)o.animateClusterPoint(r)}}}function ht(t){const e=t.point||t.target,o=e.series,s=o.options.cluster,r=((s||{}).events||{}).drillToCluster;nt(r)&&r.call(this,t)}function mt(){if(this.dataGroup)return it("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function ft(){var t=(this.options.cluster||{}).drillToCluster;if(this.markerClusterInfo&&this.markerClusterInfo.clusters)for(const e of this.markerClusterInfo.clusters)e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),at(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))}(m.plotOptions||{}).series=lt((m.plotOptions||{}).series,i);const gt={compose:function(t,e,o,s){var r,a;pt(rt,"MarkerClusters")&&(r=s.prototype.pointClass,a=s.types["scatter"],f(t,"setExtremes",dt),f(e,"render",ct),f(r,"drillToCluster",ht),f(r,"update",mt),f(s,"afterRender",ft),a&&ot.compose(o,a))}};let g;function xt(t,e,o,s){const r=o/2,a=s/2,i=g.arc(t+r,e+a,r-4,a-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),n=g.arc(t+r,e+a,r-3,a-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:r-2,open:!1}),l=g.arc(t+r,e+a,r-1,a-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:r,open:!1});return l.concat(n,i)}const yt={compose:function(t){(g=t.prototype.symbols).cluster=xt}};var x=a();gt.compose(x.Axis,x.Chart,x.defaultOptions,x.Series),yt.compose(x.SVGRenderer);const Ct=a();return e.default})());