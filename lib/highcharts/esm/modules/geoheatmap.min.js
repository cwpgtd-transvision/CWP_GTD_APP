import*as t from"../highcharts.js";var e={n:t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return e.d(i,{a:i}),i},d:(t,i)=>{for(var a in i)e.o(i,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:i[a]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};let i=t.default;var a=e.n(i);let o=t.default.SeriesRegistry;var s=e.n(o);let{prototype:{pointClass:r}}=s().seriesTypes["map"],n=a()["isNumber"],l=class extends r{applyOptions(t,e){let i=super.applyOptions.call(this,t,e),{lat:a,lon:o}=i.options;var r,s;return n(o)&&n(a)&&({colsize:t=1,rowsize:e=1}=this.series.options,r=o-t/2,s=a-e/2,i.geometry=i.options.geometry={type:"Polygon",coordinates:[[[r,s],[r+t,s],[r+t,s+e],[r,s+e],[r,s]]]}),i}},p=a()["doc"],{defined:h,pick:d}=a(),{animObject:g,stop:c}=a(),u=a()["noop"],{colorFromPoint:y,getContext:m}={colorFromPoint:function(e,i){let a=i.series.colorAxis;if(a){let t=a.toColor(e||0,i).split(")")[0].split("(")[1].split(",").map(t=>d(parseFloat(t),parseInt(t,10)));return t[3]=255*d(t[3],1),h(e)&&i.visible||(t[3]=0),t}return[0,0,0,0]},getContext:function(t){let{canvas:e,context:i}=t;return e&&i?(i.clearRect(0,0,e.width,e.height),i):(t.canvas=p.createElement("canvas"),t.context=t.canvas.getContext("2d",{willReadFrequently:!0})||void 0,t.context)}},{map:f}=s()["seriesTypes"],{addEvent:b,error:x,extend:w,isNumber:D,isObject:v,merge:C,pick:P}=a();function I(t){return t-360*Math.floor((t+180)/360)}class T extends f{constructor(){super(...arguments),this.isDirtyCanvas=!0}update(){this.options=C(this.options,arguments[0]),this.getInterpolation().enabled&&(this.isDirtyCanvas=!0,this.points.forEach(t=>{t.graphic&&(t.graphic.destroy(),delete t.graphic)})),super.update.apply(this,arguments)}translate(){this.getInterpolation().enabled&&this.image&&!this.isDirty&&!this.isDirtyData||super.translate.apply(this,arguments)}getInterpolation(){return v(this.options.interpolation)?this.options.interpolation:{blur:1,enabled:this.options.interpolation}}drawPoints(){let I=this.chart.mapView,a=this.options;if(this.getInterpolation().enabled&&I&&this.bounds){let b=this.context||m(this),{canvas:f,colorAxis:t,image:s,chart:n,points:v}=this,[w,T]=[P(a.colsize,1),P(a.rowsize,1)],e=I.projectedUnitsToPixels({x:this.bounds.x1,y:this.bounds.y2}),i=I.projectedUnitsToPixels({x:this.bounds.x2,y:this.bounds.y1});if(f&&b&&t&&e&&i){let{x:h,y:d}=e,u=i.x-h,m=i.y-d,t={x:h,y:d,width:u,height:m};if(this.isDirtyCanvas||this.isDirtyData||"Orthographic"===I.projection.options.name){let e=f.width=1+~~(360/w),i=f.height=1+~~(180/T),a=new Uint8ClampedArray(e*i*4),{lat:t=0,lon:o=0}=v[0].options,r=o%T!=0,s=t%w!=0,n=r?t=>Math.round(t/T)*T:t=>t,l=s?t=>Math.round(t/w)*w:t=>t,p=v.length;(r||s)&&x("Highcharts Warning: For best performance, lon/lat datapoints should spaced by a single colsize/rowsize",!1,this.chart,{colsize:String(w),rowsize:String(T)}),this.directTouch=!1,this.isDirtyCanvas=!0;for(let t=0;t<p;t++){var j=v[t],{lon:z,lat:O}=j.options;D(z)&&D(O)&&a.set(y(j.value,j),4*(j=n(z),Math.ceil(e*(i-1-(l(O)+90)/T)+(j+180)/w)))}var L=this.getInterpolation().blur,L=0===L?1:11*L,A=~~(e*L),L=~~(i*L),U=~~u,M=~~m,R=new ImageData(a,e,i),R=(f.width=A,f.height=L,b.putImageData(R,0,0),b.globalCompositeOperation="copy",b.drawImage(f,0,0,R.width,R.height,0,0,A,L),this.getProjectedImageData(I,U,M,b.getImageData(0,0,A,L),f,h,d));f.width=U,f.height=M,b.putImageData(new ImageData(R,U,M),0,0)}if(s)if(n.renderer.globalAnimation&&n.hasRendered){let i=Number(s.attr("x")),a=Number(s.attr("y")),o=Number(s.attr("width")),r=Number(s.attr("height")),t=C(g(n.renderer.globalAnimation)),e=t.step;t.step=function(){e&&e.apply(this,arguments),((t,e)=>{e=e.pos;s.attr({x:i+(h-i)*e,y:a+(d-a)*e,width:o+(u-o)*e,height:r+(m-r)*e})}).apply(this,arguments)},s.attr(C({animator:0},this.isDirtyCanvas?{href:f.toDataURL("image/png",1)}:void 0)).animate({animator:1},t)}else c(s),s.attr(C(t,this.isDirtyCanvas?{href:f.toDataURL("image/png",1)}:void 0));else this.image=n.renderer.image(f.toDataURL("image/png",1)).attr(t).add(this.group);this.isDirtyCanvas=!1}}else super.drawPoints.apply(this,arguments)}getProjectedImageData(i,a,t,o,r,s,n){let l=new Uint8ClampedArray(a*t*4),p=P(i.projection.options.rotation?.[0],0),h=r.width/360,d=-1*r.height/180,c=-1;for(let e=0;e<l.length;e+=4){var g,u=e/4%a;0==u&&c++;let t=i.pixelsToLonLat({x:s+u,y:n+c});t&&(t.lon>-180-p&&t.lon<180-p&&(t.lon=I(t.lon)),g=(u=[t.lon,t.lat])[0]*h+r.width/2,u=u[1]*d+r.height/2,0<=g&&g<=r.width&&0<=u&&u<=r.height&&(u=Math.floor(u)*r.width*4+4*Math.round(g),l[e]=o.data[u],l[e+1]=o.data[1+u],l[e+2]=o.data[2+u],l[e+3]=o.data[3+u]))}return l}searchPoint(t,e){let i=this.chart,a=i.mapView;if(a&&this.bounds&&this.image&&i.tooltip&&i.tooltip.options.enabled)if(!i.pointer.hasDragged&&(+this.image.attr("animator")<=.01||.99<=+this.image.attr("animator"))){var o=a.projectedUnitsToPixels({x:this.bounds.x1,y:this.bounds.y2}),r=a.projectedUnitsToPixels({x:this.bounds.x2,y:this.bounds.y1});if(i.pointer.normalize(t),t.lon&&t.lat&&o&&r&&t.chartX-i.plotLeft>o.x&&t.chartX-i.plotLeft<r.x&&t.chartY-i.plotTop>o.y&&t.chartY-i.plotTop<r.y)return this.searchKDTree({clientX:t.chartX,lon:I(t.lon),lat:t.lat},e,t)}else i.tooltip.destroy()}}T.defaultOptions=C(f.defaultOptions,{nullColor:"transparent",tooltip:{pointFormat:"Lat: {point.lat}, Lon: {point.lon}, Value: {point.value}<br/>"},borderWidth:0,colsize:1,rowsize:1,stickyTracking:!0,interpolation:{enabled:!1,blur:1}}),b(T,"afterDataClassLegendClick",function(){this.isDirtyCanvas=!0,this.drawPoints()}),w(T.prototype,{type:"geoheatmap",applyJitter:u,pointClass:l,pointArrayMap:["lon","lat","value"],kdAxisArray:["lon","lat"]}),s().registerSeriesType("geoheatmap",T);let j=a();export{j as default};