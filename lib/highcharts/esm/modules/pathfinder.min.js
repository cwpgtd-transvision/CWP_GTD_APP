import*as t from"../highcharts.js";var e,n={n:t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},d:(t,e)=>{for(var i in e)n.o(e,i)&&!n.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},o:(t,n)=>Object.prototype.hasOwnProperty.call(t,n)};let i=t.default;var r=n.n(i);let{defined:a,error:o,merge:s,objectEach:h}=r(),c=r().deg2rad,l=Math.max,x=Math.min,M=class{constructor(t,n,e){this.init(t,n,e)}init(t,n,e){this.fromPoint=t,this.toPoint=n,this.options=e,this.chart=t.series.chart,this.pathfinder=this.chart.pathfinder}renderPath(t,n){let e=this.chart,i=e.styledMode,r=this.pathfinder,a={},o=this.graphics&&this.graphics.path;r.group||(r.group=e.renderer.g().addClass("highcharts-pathfinder-group").attr({zIndex:-1}).add(e.seriesGroup)),r.group.translate(e.plotLeft,e.plotTop),o&&o.renderer||(o=e.renderer.path().add(r.group),i||o.attr({opacity:0})),o.attr(n),a.d=t,i||(a.opacity=1),o.animate(a),this.graphics=this.graphics||{},this.graphics.path=o}addMarker(t,n,e){let i,r,a,o,s,h,x,l=this.fromPoint.series.chart,M=l.pathfinder,d=l.renderer,y="start"===t?this.fromPoint:this.toPoint,p=y.getPathfinderAnchorPoint(n);n.enabled&&((x="start"===t?e[1]:e[e.length-2])&&"M"===x[0]||"L"===x[0])&&(h={x:x[1],y:x[2]},r=y.getRadiansToVector(h,p),i=y.getMarkerVector(r,n.radius,p),n.width&&n.height?(o=n.width,s=n.height):o=s=2*n.radius,this.graphics=this.graphics||{},a={x:i.x-o/2,y:i.y-s/2,width:o,height:s,rotation:-r/c,rotationOriginX:i.x,rotationOriginY:i.y},this.graphics[t]?this.graphics[t].animate(a):(this.graphics[t]=d.symbol(n.symbol).addClass("highcharts-point-connecting-path-"+t+"-marker highcharts-color-"+this.fromPoint.colorIndex).attr(a).add(M.group),d.styledMode||this.graphics[t].attr({fill:n.color||this.fromPoint.color,stroke:n.lineColor,"stroke-width":n.lineWidth,opacity:0}).animate({opacity:1},y.series.options.animation)))}getPath(t){let n=this.pathfinder,e=this.chart,i=n.algorithms[t.type],r=n.chartObstacles;return"function"!=typeof i?(o('"'+t.type+'" is not a Pathfinder algorithm.'),{path:[],obstacles:[]}):(i.requiresObstacles&&!r&&(r=n.chartObstacles=n.getChartObstacles(t),e.options.connectors.algorithmMargin=t.algorithmMargin,n.chartObstacleMetrics=n.getObstacleMetrics(r)),i(this.fromPoint.getPathfinderAnchorPoint(t.startMarker),this.toPoint.getPathfinderAnchorPoint(t.endMarker),s({chartObstacles:r,lineObstacles:n.lineObstacles||[],obstacleMetrics:n.chartObstacleMetrics,hardBounds:{xMin:0,xMax:e.plotWidth,yMin:0,yMax:e.plotHeight},obstacleOptions:{margin:t.algorithmMargin},startDirectionX:n.getAlgorithmStartDirection(t.startMarker)},t)))}render(){let t=this.fromPoint,n=t.series,e=n.chart,i=e.pathfinder,r={},o=s(e.options.connectors,n.options.connectors,t.options.connectors,this.options);e.styledMode||(r.stroke=o.lineColor||t.color,r["stroke-width"]=o.lineWidth,o.dashStyle&&(r.dashstyle=o.dashStyle)),r.class="highcharts-point-connecting-path highcharts-color-"+t.colorIndex,a((o=s(r,o)).marker.radius)||(o.marker.radius=x(l(Math.ceil((o.algorithmMargin||8)/2)-1,1),5));var h=this.getPath(o),c=h.path;h.obstacles&&(i.lineObstacles=i.lineObstacles||[],i.lineObstacles=i.lineObstacles.concat(h.obstacles)),this.renderPath(c,r),this.addMarker("start",s(o.marker,o.startMarker),c),this.addMarker("end",s(o.marker,o.endMarker),c)}destroy(){this.graphics&&(h(this.graphics,function(t){t.destroy()}),delete this.graphics)}},d=function(n,e){let i=[];for(let t=0;t<n.length;t++){var r,a,o,s,h,c,x=n[t][1],l=n[t][2];"number"==typeof x&&"number"==typeof l&&(0===t?i.push(["M",x,l]):t!==n.length-1&&e?(a=n[t-1],s=n[t+1],a&&s&&(r=a[1],a=a[2],o=s[1],s=s[2],"number"==typeof r&&"number"==typeof o&&"number"==typeof a&&"number"==typeof s&&r!==o&&a!==s&&(h=r<o?1:-1,c=a<s?1:-1,i.push(["L",x-h*Math.min(Math.abs(x-r),e),l-c*Math.min(Math.abs(l-a),e)],["C",x,l,x,l,x+h*Math.min(Math.abs(x-o),e),l+c*Math.min(Math.abs(l-s),e)])))):i.push(["L",x,l]))}return i},y=r()["pick"],{min:p,max:f,abs:u}=Math;function g(t,n,e){let i=n-1e-7,r=e||0,a=t.length-1,o,s;for(;r<=a;)if(0<(s=i-t[o=a+r>>1].xMin))r=1+o;else{if(!(s<0))return o;a=o-1}return 0<r?r-1:0}function m(t,n){let e=g(t,n.x+1)+1;for(;e--;){var i;if(t[e].xMax>=n.x&&(i=t[e],n.x<=i.xMax&&n.x>=i.xMin&&n.y<=i.yMax&&n.y>=i.yMin))return e}return-1}function b(n){let e=[];if(n.length){e.push(["M",n[0].start.x,n[0].start.y]);for(let t=0;t<n.length;++t)e.push(["L",n[t].end.x,n[t].end.y])}return e}function P(t,n){t.yMin=f(t.yMin,n.yMin),t.yMax=p(t.yMax,n.yMax),t.xMin=f(t.xMin,n.xMin),t.xMax=p(t.xMax,n.xMax)}let O=function(t,n,e){let i=[],r=e.chartObstacles,a=m(r,t),o=m(r,n),s,h=y(e.startDirectionX,u(n.x-t.x)>u(n.y-t.y))?"x":"y",c,x,l,M;function p(t,n,e,i,r){let a={x:t.x,y:t.y};return a[n]=e[i||n]+(r||0),a}function f(t,n,e){var i=u(n[e]-t[e+"Min"])>u(n[e]-t[e+"Max"]);return p(n,e,t,e+(i?"Max":"Min"),i?1:-1)}M=-1<o?(s={start:x=f(r[o],n,h),end:n},x):n,-1<a&&(x=f(c=r[a],t,h),i.push({start:t,end:x}),x[h]>=t[h]==x[h]>=M[h]&&(l=t[h="y"===h?"x":"y"]<n[h],i.push({start:x,end:p(x,h,c,h+(l?"Max":"Min"),l?1:-1)}),h="y"===h?"x":"y"));n=i.length?i[i.length-1].end:t,x=p(n,h,M),i.push({start:n,end:x}),t=p(x,h="y"===h?"x":"y",M);return i.push({start:x,end:t}),i.push(s),{path:d(b(i),e.radius),obstacles:i}};function v(t,n,v){let e=y(v.startDirectionX,u(n.x-t.x)>u(n.y-t.y)),i=e?"x":"y",r=[],a=v.obstacleMetrics,O=p(t.x,n.x)-a.maxWidth-10,k=f(t.x,n.x)+a.maxWidth+10,w=p(t.y,n.y)-a.maxHeight-10,A=f(t.y,n.y)+a.maxHeight+10,o,s,h,I=!1,R=v.chartObstacles,c=g(R,k),x=g(R,O);function E(t,n,e){let i,r,a,o,s=t.x<n.x?1:-1,h=(r=t.x<n.x?(i=t,n):(i=n,t),a=t.y<n.y?(o=t,n):(o=n,t),s<0?p(g(R,r.x),R.length-1):0);for(;R[h]&&(0<s&&R[h].xMin<=r.x||s<0&&R[h].xMax>=i.x);){if(R[h].xMin<=r.x&&R[h].xMax>=i.x&&R[h].yMin<=a.y&&R[h].yMax>=o.y)return e?{y:t.y,x:t.x<n.x?R[h].xMin-1:R[h].xMax+1,obstacle:R[h]}:{x:t.x,y:t.y<n.y?R[h].yMin-1:R[h].yMax+1,obstacle:R[h]};h+=s}return n}function L(t,n,e,i,r){let a=r.soft,o=r.hard,s=i?"x":"y",h={x:n.x,y:n.y},c={x:n.x,y:n.y},x=t[s+"Max"]>=a[s+"Max"],l=t[s+"Min"]<=a[s+"Min"],M=t[s+"Max"]>=o[s+"Max"],d=t[s+"Min"]<=o[s+"Min"],y=u(t[s+"Min"]-n[s]),p=u(t[s+"Max"]-n[s]),f=u(y-p)<10?n[s]<e[s]:p<y;c[s]=t[s+"Min"],h[s]=t[s+"Max"];r=E(n,c,i)[s]!==c[s],e=E(n,h,i)[s]!==h[s];return f=r?!e||f:!e&&f,f=l?!x||f:!x&&f,f=d?!M||f:!M&&f}for(-1<(c=m(R=R.slice(x,c+1),n))&&(h=(l=R[c],M=n,d=t,B=p(l.xMax-M.x,M.x-l.xMin)<p(l.yMax-M.y,M.y-l.yMin),d=L(l,M,d,B,{soft:v.hardBounds,hard:v.hardBounds}),B?{y:M.y,x:l[d?"xMax":"xMin"]+(d?1:-1)}:{x:M.x,y:l[d?"yMax":"yMin"]+(d?1:-1)}),r.push({end:n,start:h}),n=h);-1<(c=m(R,n));)s=n[i]-t[i]<0,(h={x:n.x,y:n.y})[i]=R[c][s?i+"Max":i+"Min"]+(s?1:-1),r.push({end:n,start:h}),n=h;var l,M,d,B;return{path:b(o=(o=function t(n,e,i){let r,a,o,s,h,c,x;if(n.x===e.x&&n.y===e.y)return[];var l=i?"x":"y",M=v.obstacleOptions.margin,d={soft:{xMin:O,xMax:k,yMin:w,yMax:A},hard:v.hardBounds};return-1<(h=m(R,n))?(s=L(h=R[h],n,e,i,d),P(h,v.hardBounds),x=i?{y:n.y,x:h[s?"xMax":"xMin"]+(s?1:-1)}:{x:n.x,y:h[s?"yMax":"yMin"]+(s?1:-1)},-1<(c=m(R,x))&&(P(c=R[c],v.hardBounds),x[l]=s?f(h[l+"Max"]-M+1,(c[l+"Min"]+h[l+"Max"])/2):p(h[l+"Min"]+M-1,(c[l+"Max"]+h[l+"Min"])/2),I=n.x===x.x&&n.y===x.y&&(I&&(x[l]=s?f(h[l+"Max"],c[l+"Max"])+1:p(h[l+"Min"],c[l+"Min"])-1),!I)),a=[{start:n,end:x}]):(r=E(n,{x:(i?e:n).x,y:(i?n:e).y},i),a=[{start:n,end:{x:r.x,y:r.y}}],r[i?"x":"y"]!==e[i?"x":"y"]&&(s=L(r.obstacle,r,e,!i,d),P(r.obstacle,v.hardBounds),o={x:i?r.x:r.obstacle[s?"xMax":"xMin"]+(s?1:-1),y:i?r.obstacle[s?"yMax":"yMin"]+(s?1:-1):r.y},i=!i,a=a.concat(t({x:r.x,y:r.y},o,i)))),a=a.concat(t(a[a.length-1].end,e,!i))}(t,n,e)).concat(r.reverse())),obstacles:o}}O.requiresObstacles=!0;let k={connectors:{type:"straight",radius:0,lineWidth:1,marker:{enabled:!(v.requiresObstacles=!0),align:"center",verticalAlign:"middle",inside:!1,lineWidth:1},startMarker:{symbol:"diamond"},endMarker:{symbol:"arrow-filled"}}},w=r()["setOptions"],{defined:A,error:I,merge:L}=r();function R(t){var n=t.shapeArgs;if(n)return{xMin:n.x||0,xMax:(n.x||0)+(n.width||0),yMin:n.y||0,yMax:(n.y||0)+(n.height||0)};n=t.graphic&&t.graphic.getBBox();return n?{xMin:t.plotX-n.width/2,xMax:t.plotX+n.width/2,yMin:t.plotY-n.height/2,yMax:t.plotY+n.height/2}:null}!function(){function r(t){let n,e,i=R(this);switch(t.align){case"right":n="xMax";break;case"left":n="xMin"}switch(t.verticalAlign){case"top":e="yMin";break;case"bottom":e="yMax"}return{x:n?i[n]:(i.xMin+i.xMax)/2,y:e?i[e]:(i.yMin+i.yMax)/2}}function a(t,n){let e;return!A(n)&&(e=R(this))&&(n={x:(e.xMin+e.xMax)/2,y:(e.yMin+e.yMax)/2}),Math.atan2(n.y-t.y,t.x-n.x)}function o(t,n,e){let i=2*Math.PI,r=R(this),a=r.xMax-r.xMin,o=r.yMax-r.yMin,s=Math.atan2(o,a),h=a/2,c=o/2,x=r.xMin+h,l=r.yMin+c,M={x:x,y:l},d=t,y,p=!1,f=1,u=1;for(;d<-Math.PI;)d+=i;for(;d>Math.PI;)d-=i;return y=Math.tan(d),d>-s&&d<=s?(u=-1,p=!0):d>s&&d<=Math.PI-s?u=-1:d>Math.PI-s||d<=-(Math.PI-s)?(f=-1,p=!0):f=-1,p?(M.x+=f*h,M.y+=u*h*y):(M.x+=o/(2*y)*f,M.y+=u*c),e.x!==x&&(M.x=e.x),e.y!==l&&(M.y=e.y),{x:M.x+n*Math.cos(d),y:M.y-n*Math.sin(d)}}(e||(e={})).compose=function(t,n,e){let i=e.prototype;i.getPathfinderAnchorPoint||(t.prototype.callbacks.push(function(t){!1!==t.options.connectors.enabled&&((t.options.pathfinder||t.series.reduce(function(t,n){return n.options&&L(!0,n.options.connectors=n.options.connectors||{},n.options.pathfinder),t||n.options&&n.options.pathfinder},!1))&&(L(!0,t.options.connectors=t.options.connectors||{},t.options.pathfinder),I('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.')),this.pathfinder=new n(this),this.pathfinder.update(!0))}),i.getMarkerVector=o,i.getPathfinderAnchorPoint=r,i.getRadiansToVector=a,w(k))}}();let B=e,E=t.default.Point;var C=n.n(E);let{addEvent:W,defined:X,pick:D,splat:S}=r(),V=Math.max,Y=Math.min;class H{static compose(t,n){B.compose(t,H,n)}constructor(t){this.init(t)}init(t){this.chart=t,this.connections=[],W(t,"redraw",function(){this.pathfinder.update()})}update(t){let r=this.chart,a=this,o=a.connections;a.connections=[],r.series.forEach(function(t){t.visible&&!t.options.isInternal&&t.points.forEach(function(e){let i,t=e.options,n=(t&&t.dependency&&(t.connect=t.dependency),e.options?.connect?S(e.options.connect):[]);e.visible&&!1!==e.isInside&&n.forEach(t=>{var n="string"==typeof t?t:t.to;(i=n?r.get(n):i)instanceof C()&&i.series.visible&&i.visible&&!1!==i.isInside&&a.connections.push(new M(e,i,"string"==typeof t?{}:t))})})});for(let t=0,e,i,n=o.length,r=a.connections.length;t<n;++t){i=!1;let n=o[t];for(e=0;e<r;++e){let t=a.connections[e];if((n.options&&n.options.type)===(t.options&&t.options.type)&&n.fromPoint===t.fromPoint&&n.toPoint===t.toPoint){t.graphics=n.graphics,i=!0;break}}i||n.destroy()}delete this.chartObstacles,delete this.lineObstacles,a.renderConnections(t)}renderConnections(t){t?this.chart.series.forEach(function(n){function t(){let t=n.chart.pathfinder;(t&&t.connections||[]).forEach(function(t){t.fromPoint&&t.fromPoint.series===n&&t.render()}),n.pathfinderRemoveRenderEvent&&(n.pathfinderRemoveRenderEvent(),delete n.pathfinderRemoveRenderEvent)}!1===n.options.animation?t():n.pathfinderRemoveRenderEvent=W(n,"afterAnimate",t)}):this.connections.forEach(function(t){t.render()})}getChartObstacles(t){let a=this.chart.series,o=D(t.algorithmMargin,0),s=[],n;for(let r=0,t=a.length;r<t;++r)if(a[r].visible&&!a[r].options.isInternal)for(let t=0,n=a[r].points.length,e,i;t<n;++t)(i=a[r].points[t]).visible&&(e=function(t){var n=t.shapeArgs;if(n)return{xMin:n.x||0,xMax:(n.x||0)+(n.width||0),yMin:n.y||0,yMax:(n.y||0)+(n.height||0)};n=t.graphic&&t.graphic.getBBox();return n?{xMin:t.plotX-n.width/2,xMax:t.plotX+n.width/2,yMin:t.plotY-n.height/2,yMax:t.plotY+n.height/2}:null}(i))&&s.push({xMin:e.xMin-o,xMax:e.xMax+o,yMin:e.yMin-o,yMax:e.yMax+o});return s=s.sort(function(t,n){return t.xMin-n.xMin}),X(t.algorithmMargin)||(n=t.algorithmMargin=function(e){let i,r=e.length,a=[];for(let n=0;n<r;++n)for(let t=n+1;t<r;++t)(i=function t(n,e,i){var i=D(i,10),r=n.yMax+i>e.yMin-i&&n.yMin-i<e.yMax+i,a=n.xMax+i>e.xMin-i&&n.xMin-i<e.xMax+i,o=r?n.xMin>e.xMax?n.xMin-e.xMax:e.xMin-n.xMax:1/0,s=a?n.yMin>e.yMax?n.yMin-e.yMax:e.yMin-n.yMax:1/0;return a&&r?i?t(n,e,Math.floor(i/2)):1/0:Y(o,s)}(e[n],e[t]))<80&&a.push(i);return a.push(80),V(Math.floor(a.sort(function(t,n){return t-n})[Math.floor(a.length/10)]/2-1),1)}(s),s.forEach(function(t){t.xMin-=n,t.xMax+=n,t.yMin-=n,t.yMax+=n})),s}getObstacleMetrics(t){let n=0,e=0,i,r,a=t.length;for(;a--;)i=t[a].xMax-t[a].xMin,r=t[a].yMax-t[a].yMin,n<i&&(n=i),e<r&&(e=r);return{maxHeight:e,maxWidth:n}}getAlgorithmStartDirection(t){var n="left"!==t.align&&"right"!==t.align,t="top"!==t.verticalAlign&&"bottom"!==t.verticalAlign;return n?!!t&&void 0:!!t||void 0}}function j(t,n,e,i){return[["M",t,n+i/2],["L",t+e,n],["L",t,n+i/2],["L",t+e,n+i]]}function q(t,n,e,i){return j(t,n,e/2,i)}function G(t,n,e,i){return[["M",t+e,n],["L",t,n+i/2],["L",t+e,n+i],["Z"]]}function T(t,n,e,i){return G(t,n,e/2,i)}H.prototype.algorithms={fastAvoid:v,straight:function(t,n){return{path:[["M",t.x,t.y],["L",n.x,n.y]],obstacles:[{start:t,end:n}]}},simpleConnect:O};let _=r(),N=(_.Pathfinder=_.Pathfinder||H,function(t){let n=t.prototype.symbols;n.arrow=j,n["arrow-filled"]=G,n["arrow-filled-half"]=T,n["arrow-half"]=q,n["triangle-left"]=G,n["triangle-left-half"]=T}(_.SVGRenderer),_.Pathfinder.compose(_.Chart,_.Point),r());export{N as default};