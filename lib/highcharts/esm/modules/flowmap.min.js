import*as t from"../highcharts.js";var o={n:t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return o.d(i,{a:i}),i},d:(t,i)=>{for(var e in i)o.o(i,e)&&!o.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:i[e]})},o:(t,o)=>Object.prototype.hasOwnProperty.call(t,o)};let e=t.default;var i=o.n(e);let s=t.default.SeriesRegistry;var r=o.n(s);let{mapline:{prototype:{pointClass:n}}}=r()["seriesTypes"],{pick:a,isString:p,isNumber:l}=i(),h=class extends n{isValid(){let o=!(!this.options.to||!this.options.from);return[this.options.to,this.options.from].forEach(function(t){o=!!(o&&t&&(p(t)||l(a(t[0],t.lat))&&l(a(t[1],t.lon))))}),o}},{series:{prototype:{pointClass:d}},seriesTypes:{column:f,map:m,mapline:g}}=r(),{addEvent:y,arrayMax:c,arrayMin:u,defined:w,extend:x,isArray:P,merge:b,pick:L,relativeLength:W}=i();class k extends g{static getLength(t,o){return Math.sqrt(t*t+o*o)}static normalize(t,o){var i=this.getLength(t,o);return[t/i,o/i]}static markerEndPath(t,o,i,e){let s=W(e.width||0,this.getLength(o[0]-t[0],o[1]-t[1])),r=e.markerType||"arrow",[a,n]=this.normalize(o[0]-t[0],o[1]-t[1]),p=[];var h,l,d,g;return"arrow"===r&&([e,h]=t,e-=a*s,h-=n*s,p.push(["L",e,h]),p.push(["L",i[0],i[1]]),[e,h]=o,e+=a*s,h+=n*s,p.push(["L",e,h])),"mushroom"===r&&([e,h]=t,[t,o]=o,[i,l]=i,d=(t-e)/2+e,g=(o-h)/2+h,e-=a*s,h-=n*s,p.push(["L",e,h]),t+=a*s,o+=n*s,p.push(["Q",2*(i-d)+d,2*(l-g)+g,t,o])),p}animate(t){let o=this.points;t||o.forEach(t=>{if(t.shapeArgs&&P(t.shapeArgs.d)&&t.shapeArgs.d.length){var e=t.shapeArgs.d,s=e[0][1],r=e[0][2];if(s&&r){let i=[];for(let o=0;o<e.length;o++){i.push([...e[o]]);for(let t=1;t<e[o].length;t++)i[o][t]=t%2?s:r}t.graphic&&(t.graphic.attr({d:i}),t.graphic.animate({d:e}))}}})}getLinkWidth(t){var o=this.options.width,i=t.options.weight||this.options.weight;if(t.options.weight=i,o&&!i)return o;t=this.smallestWeight,o=this.greatestWeight;if(!w(i)||!t||!o)return 0;var e=this.options.minWidth;return(i-t)*(this.options.maxWidth-e)/(o-t||1)+e}autoCurve(t,o,i,e,s,r){let a=i-t,n=e-o,p=(i-t)/2+t,h=(e-o)/2+o,l=p-s,d=h-r,g=a*l+n*d,f=Math.atan2(a*d-n*l,g),m=180*f/Math.PI;return m<0&&(m=360+m),-.7*Math.sin(m*Math.PI/180)}pointAttribs(t,o){let i=m.prototype.pointAttribs.call(this,t,o);return i.fill=L(t.options.fillColor,t.options.color,"none"===this.options.fillColor?null:this.options.fillColor,this.color),i["fill-opacity"]=L(t.options.fillOpacity,this.options.fillOpacity),i["stroke-width"]=L(t.options.lineWidth,this.options.lineWidth,1),t.options.opacity&&(i.opacity=t.options.opacity),i}translate(){!this.chart.hasRendered||!this.isDirtyData&&this.hasRendered||(this.processData(),this.generatePoints());let h=[],l=0,g=0;this.points.forEach(t=>{let o,i,e=this.chart,s=e.mapView,r=t.options,a=()=>{t.series.isDirty=!0},n=t=>{t=e.get(t);if(t instanceof d&&t.plotX&&t.plotY)return y(t,"update",a),{x:t.plotX,y:t.plotY}},p=t=>P(t)?{lon:t[0],lat:t[1]}:t;"string"==typeof r.from?o=n(r.from):"object"==typeof r.from&&s&&(o=s.lonLatToPixels(p(r.from))),"string"==typeof r.to?i=n(r.to):"object"==typeof r.to&&s&&(i=s.lonLatToPixels(p(r.to))),t.fromPos=o,t.toPos=i,o&&i&&(l+=(o.x+i.x)/2,g+=(o.y+i.y)/2),L(t.options.weight,this.options.weight)&&h.push(L(t.options.weight,this.options.weight))}),this.smallestWeight=u(h),this.greatestWeight=c(h),this.centerOfPoints={x:l/this.points.length,y:g/this.points.length},this.points.forEach(t=>{this.getLinkWidth(t)?(t.fromPos&&(t.plotX=t.fromPos.x,t.plotY=t.fromPos.y),t.shapeType="path",t.shapeArgs=this.getPointShapeArgs(t),t.color=L(t.options.color,t.series.color)):t.shapeArgs={d:[]}})}getPointShapeArgs(t){var{fromPos:o,toPos:i}=t;if(!o||!i)return{};let e=this.getLinkWidth(t)/2,s=t.options,r=b(this.options.markerEnd,s.markerEnd),a=L(s.growTowards,this.options.growTowards),n=o.x||0,p=o.y||0,h=i.x||0,l=i.y||0,d=L(s.curveFactor,this.options.curveFactor),g=r&&r.enabled&&r.height||0;w(d)||(d=this.autoCurve(n,p,h,l,this.centerOfPoints.x,this.centerOfPoints.y)),g&&(g=W(g,4*e),o=h-n,f=l-p,m=n+(o*=.5),c=p+(f*=.5),y=o,m=m+(o=f)*d,o=c+(f=-y)*d,[c,y]=k.normalize(m-h,o-l),c*=g,y*=g,h+=c,l+=y);var f=h-n,m=l-p,o=n+(f*=.5),c=p+(m*=.5),y=f,f=m,m=-y;let[u,P]=k.normalize(f,m),v=1+.25*Math.sqrt(d*d),x=(u*=e*v,P*=e*v,o+f*d),A=c+m*d,[M,O]=k.normalize(x-n,A-p);y=M,M=O,O=-y,M*=e,O*=e;var[o,f]=k.normalize(x-h,A-l),y=o,o=-f,f=y;o*=e,f*=e,a&&(M/=e,O/=e,u/=4,P/=4);let C={d:[["M",n-M,p-O],["Q",x-u,A-P,h-o,l-f],["L",h+o,l+f],["Q",x+u,A+P,n+M,p+O],["Z"]]};r&&r.enabled&&C.d&&(c=k.markerEndPath([h-o,l-f],[h+o,l+f],[i.x,i.y],r),C.d.splice(2,0,...c));m=t.options.from,y=t.options.to,o=m.lat,f=m.lon,i=y.lat,c=y.lon;return o&&f&&(t.options.from=+o+", "+ +f),i&&c&&(t.options.to=+i+", "+ +c),C}}k.defaultOptions=b(g.defaultOptions,{animation:!0,dataLabels:{enabled:!1},fillOpacity:.5,markerEnd:{enabled:!0,height:"40%",width:"40%",markerType:"arrow"},width:1,maxWidth:25,minWidth:5,lineWidth:void 0,tooltip:{headerFormat:'<span style="font-size: 0.8em">{series.name}</span><br/>',pointFormat:"{point.options.from} â†’ {point.options.to}: <b>{point.options.weight}</b>"}}),x(k.prototype,{pointClass:h,pointArrayMap:["from","to","weight"],drawPoints:f.prototype.drawPoints,dataColumnKeys:f.prototype.dataColumnKeys,useMapGeometry:!0}),r().registerSeriesType("flowmap",k);let A=i();export{A as default};