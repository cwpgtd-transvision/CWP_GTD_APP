import*as __WEBPACK_EXTERNAL_MODULE__highcharts_src_js_8202131d__ from"../highcharts.src.js";var __webpack_require__={n:t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return __webpack_require__.d(e,{a:e}),e},d:(t,e)=>{for(var s in e)__webpack_require__.o(e,s)&&!__webpack_require__.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};const external_highcharts_src_js_default_namespaceObject=__WEBPACK_EXTERNAL_MODULE__highcharts_src_js_8202131d__.default;var ColumnUtils,external_highcharts_src_js_default_default=__webpack_require__.n(external_highcharts_src_js_default_namespaceObject);const cluster={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},tooltip={clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"},MarkerClusterDefaults={cluster:cluster,tooltip:tooltip},MarkerClusters_MarkerClusterDefaults=MarkerClusterDefaults,Data_ColumnUtils=(!function(t){t.setLength=function(t,e,s){return Array.isArray(t)?(t.length=e,t):t[s?"subarray":"slice"](0,e)},t.splice=function(t,e,s,r,a=[]){if(Array.isArray(t))return Array.isArray(a)||(a=Array.from(a)),{removed:t.splice(e,s,...a),array:t};const o=Object.getPrototypeOf(t).constructor;var r=t[r?"subarray":"slice"](e,e+s),i=t.length-s+a.length;const n=new o(i);return n.set(t.subarray(0,e),0),n.set(a,e),n.set(t.subarray(e+s),e+a.length),{removed:r,array:n}}}(ColumnUtils=ColumnUtils||{}),ColumnUtils),{setLength,splice}=Data_ColumnUtils,{fireEvent,objectEach,uniqueKey}=external_highcharts_src_js_default_default();class DataTableCore{constructor(t={}){this.autoId=!t.id,this.columns={},this.id=t.id||uniqueKey(),(this.modified=this).rowCount=0,this.versionTag=uniqueKey();let s=0;objectEach(t.columns||{},(t,e)=>{this.columns[e]=t.slice(),s=Math.max(s,t.length)}),this.applyRowCount(s)}applyRowCount(s){this.rowCount=s,objectEach(this.columns,(t,e)=>{t.length!==s&&(this.columns[e]=setLength(t,s))})}deleteRows(r,a=1){if(0<a&&r<this.rowCount){let s=0;objectEach(this.columns,(t,e)=>{this.columns[e]=splice(t,r,a).array,s=t.length}),this.rowCount=s}fireEvent(this,"afterDeleteRows",{rowIndex:r,rowCount:a}),this.versionTag=uniqueKey()}getColumn(t,e){return this.columns[t]}getColumns(t,e){return(t||Object.keys(this.columns)).reduce((t,e)=>(t[e]=this.columns[e],t),{})}getRow(e,t){return(t||Object.keys(this.columns)).map(t=>this.columns[t]?.[e])}setColumn(t,e=[],s=0,r){this.setColumns({[t]:e},s,r)}setColumns(t,e,s){let r=this.rowCount;objectEach(t,(t,e)=>{this.columns[e]=t.slice(),r=t.length}),this.applyRowCount(r),s?.silent||(fireEvent(this,"afterSetColumns"),this.versionTag=uniqueKey())}setRow(t,r=this.rowCount,a,o){const i=this["columns"],n=a?this.rowCount+1:r+1;objectEach(t,(t,e)=>{let s=i[e]||!1!==o?.addColumns&&new Array(n);s&&(a?s=splice(s,r,0,!0,[t]).array:s[r]=t,i[e]=s)}),n>this.rowCount&&this.applyRowCount(n),o?.silent||(fireEvent(this,"afterSetRows"),this.versionTag=uniqueKey())}}const Data_DataTableCore=DataTableCore,animObject=external_highcharts_src_js_default_default()["animObject"],clusterDefaults=MarkerClusters_MarkerClusterDefaults["cluster"],{addEvent,defined,error,isArray,isFunction,isObject,isNumber,merge,objectEach:MarkerClusterScatter_objectEach,relativeLength,syncTimeout}=external_highcharts_src_js_default_default(),markerClusterAlgorithms={grid:function(t,e,s,r){const a={},o=this.getGridOffset(),i=this.getScaledGridSize(r);let n,l,u,d,c;for(c=0;c<t.length;c++){var p=valuesToPixels(this,{x:t[c],y:e[c]});n=p.x-o.plotLeft,l=p.y-o.plotTop,u=Math.floor(n/i),d=Math.floor(l/i)+":"+u,a[d]??(a[d]=[]),a[d].push({dataIndex:s[c],x:t[c],y:e[c]})}return a},kmeans:function(e,s,r,t){const a=this,o=[],i=[],n={},l=t.processedDistance||clusterDefaults.layoutAlgorithm.distance,u=t.iterations;let d=0,c=!0,p,h,m,f=[];t.processedGridSize=t.processedDistance;var g=a.markerClusterAlgorithms?a.markerClusterAlgorithms.grid.call(a,e,s,r,t):{};for(const C in g)1<g[C].length&&(m=getClusterPosition(g[C]),o.push({posX:m.x,posY:m.y,oldX:0,oldY:0,startPointsLen:g[C].length,points:[]}));for(;c;){for(const x of o)x.points.length=0;for(let t=i.length=0;t<e.length;t++)p=e[t],h=s[t],((f=a.getClusterDistancesFromPoint(o,p,h)).length&&f[0].distance<l?o[f[0].clusterIndex].points:i).push({x:p,y:h,dataIndex:r[t]});for(let t=0;t<o.length;t++)1===o[t].points.length&&(f=a.getClusterDistancesFromPoint(o,o[t].points[0].x,o[t].points[0].y))[1].distance<l&&(o[f[1].clusterIndex].points.push(o[t].points[0]),o[f[0].clusterIndex].points.length=0);c=!1;for(let t=0;t<o.length;t++)m=getClusterPosition(o[t].points),o[t].oldX=o[t].posX,o[t].oldY=o[t].posY,o[t].posX=m.x,o[t].posY=m.y,(o[t].posX>o[t].oldX+1||o[t].posX<o[t].oldX-1||o[t].posY>o[t].oldY+1||o[t].posY<o[t].oldY-1)&&(c=!0);u&&(c=d<u-1),d++}for(let t=0,e=o.length;t<e;++t)n["cluster"+t]=o[t].points;for(let t=0,e=i.length;t<e;++t)n["noise"+t]=[i[t]];return n},optimizedKmeans:function(t,e,s,r){var a=this,o=r.processedDistance||clusterDefaults.layoutAlgorithm.gridSize,i=a.getRealExtremes(),n=(a.options.cluster||{}).marker;let l,u={},d,c;if(!a.markerClusterInfo||a.initMaxX&&a.initMaxX<i.maxX||a.initMinX&&a.initMinX>i.minX||a.initMaxY&&a.initMaxY<i.maxY||a.initMinY&&a.initMinY>i.minY)a.initMaxX=i.maxX,a.initMinX=i.minX,a.initMaxY=i.maxY,a.initMinY=i.minY,u=a.markerClusterAlgorithms?a.markerClusterAlgorithms.kmeans.call(a,t,e,s,r):{},a.baseClusters=null;else{a.baseClusters??(a.baseClusters={clusters:a.markerClusterInfo.clusters,noise:a.markerClusterInfo.noise});for(const m of a.baseClusters.clusters){m.pointsOutside=[],m.pointsInside=[];for(const f of m.data){var p=valuesToPixels(a,f),h=valuesToPixels(a,m);l=Math.sqrt(Math.pow(p.x-h.x,2)+Math.pow(p.y-h.y,2)),d=0<=o-(c=(m.clusterZone?.marker?.radius?m.clusterZone.marker:n?.radius?n:clusterDefaults.marker).radius)?o-c:c,l>c+d&&defined(m.pointsOutside)?m.pointsOutside.push(f):defined(m.pointsInside)&&m.pointsInside.push(f)}m.pointsInside.length&&(u[m.id]=m.pointsInside);let t=0;for(const g of m.pointsOutside)u[m.id+"_noise"+t++]=[g]}for(const C of a.baseClusters.noise)u[C.id]=C.data}return u}};let baseGeneratePoints,oldPointsStateId=[],stateIdCounter=0;function compose(t,e){const s=e.prototype;s.markerClusterAlgorithms||(baseGeneratePoints=s.generatePoints,s.markerClusterAlgorithms=markerClusterAlgorithms,s.animateClusterPoint=seriesAnimateClusterPoint,s.destroyClusteredData=seriesDestroyClusteredData,s.generatePoints=seriesGeneratePoints,s.getClusterDistancesFromPoint=seriesGetClusterDistancesFromPoint,s.getClusteredData=seriesGetClusteredData,s.getGridOffset=seriesGetGridOffset,s.getPointsState=seriesGetPointsState,s.getRealExtremes=seriesGetRealExtremes,s.getScaledGridSize=seriesGetScaledGridSize,s.hideClusteredData=seriesHideClusteredData,s.isValidGroupedDataObject=seriesIsValidGroupedDataObject,s.preventClusterCollisions=seriesPreventClusterCollisions,addEvent(e,"destroy",s.destroyClusteredData),t.plotOptions&&(t.plotOptions.series=merge(t.plotOptions.series,MarkerClusters_MarkerClusterDefaults)))}function destroyOldPoints(t){for(const e of Object.keys(t))t[e].point?.destroy?.()}function fadeInElement(t,e,s){t.attr({opacity:e}).animate({opacity:1},s)}function fadeInNewPointAndDestoryOld(t,e,s,r){fadeInStatePoint(t,r,s,!0,!0);for(const a of e)a.point?.destroy?.()}function fadeInStatePoint(t,e,s,r,a){t.point&&(r&&t.point.graphic&&(t.point.graphic.show(),fadeInElement(t.point.graphic,e,s)),a&&t.point.dataLabel&&(t.point.dataLabel.show(),fadeInElement(t.point.dataLabel,e,s)))}function getClusterPosition(e){var s=e.length;let r=0,a=0;for(let t=0;t<s;t++)r+=e[t].x,a+=e[t].y;return{x:r/s,y:a/s}}function getDataState(t,e){const s=[];return s.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){s[t.dataIndex]=t})}),t.noise.forEach(function(t){s[t.data[0].dataIndex]=t.data[0]}),s}function getStateId(){return Math.random().toString(36).substring(2,7)+"-"+stateIdCounter++}function hideStatePoint(t,e,s){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),s&&t.point.dataLabel&&t.point.dataLabel.hide())}function onPointDrillToCluster(t){const e=t.point||t.target;e.firePointEvent("drillToCluster",t,function(a){const t=a.point||a.target,e=t.series,{xAxis:o,yAxis:i,chart:n}=e,{inverted:l,mapView:s,pointer:u}=n,r=e.options.cluster?.drillToCluster;if(r&&t.clusteredData){var a=t.clusteredData.map(t=>t.x).sort((t,e)=>t-e),d=t.clusteredData.map(t=>t.y).sort((t,e)=>t-e),c=a[0],a=a[a.length-1],p=d[0],d=d[d.length-1],h=Math.abs(.1*(a-c)),m=Math.abs(.1*(d-p)),f=Math.min(c,a)-h,c=Math.max(c,a)+h,a=Math.min(p,d)-m,h=Math.max(p,d)+m;if(s)s.fitToBounds({x1:f,x2:c,y1:a,y2:h});else if(o&&i){let t=o.toPixels(f),e=o.toPixels(c),s=i.toPixels(a),r=i.toPixels(h);l&&([t,e,s,r]=[s,r,t,e]),t>e&&([t,e]=[e,t]),s>r&&([s,r]=[r,s]),u&&(u.zoomX=!0,u.zoomY=!0),n.transform({from:{x:t,y:s,width:e-t,height:r-s}})}}})}function pixelsToValues(t,e){const{chart:s,xAxis:r,yAxis:a}=t;return s.mapView?s.mapView.pixelsToProjectedUnits(e):{x:r?r.toValue(e.x):0,y:a?a.toValue(e.y):0}}function seriesAnimateClusterPoint(t){const e=this.chart,s=e.mapView,r=animObject(this.options.cluster?.animation),a=r.duration||500,o=this.markerClusterInfo?.pointsState,i=o?.newState,n=o?.oldState,l=[];let u,d,c,p,h,m,f,g=!1,C=!1;var x;n&&i&&(x=valuesToPixels(this,c=i[t.stateId]),m=x.x-(s?0:e.plotLeft),f=x.y-(s?0:e.plotTop),1===c.parentsId.length?(u=i?.[t.stateId].parentsId[0],d=n[u],c.point?.graphic&&d.point?.plotX&&d.point.plotY&&(d.point.plotX!==c.point.plotX||d.point.plotY!==c.point.plotY)&&(p=c.point.graphic.getBBox(),h=c.point.graphic?.isImg?0:p.width/2,c.point.graphic.attr({x:d.point.plotX-h,y:d.point.plotY-h}),c.point.graphic.animate({x:m-(c.point.graphic.radius||0),y:f-(c.point.graphic.radius||0)},r,function(){C=!0,d.point?.destroy?.()}),c.point.dataLabel?.alignAttr&&d.point.dataLabel?.alignAttr&&(c.point.dataLabel.attr({x:d.point.dataLabel.alignAttr.x,y:d.point.dataLabel.alignAttr.y}),c.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y},r)))):0===c.parentsId.length?(hideStatePoint(c,!0,!0),syncTimeout(function(){fadeInStatePoint(c,.1,r,!0,!0)},a/2)):(hideStatePoint(c,!0,!0),c.parentsId.forEach(function(t){n?.[t]&&(d=n[t],l.push(d),d.point?.graphic&&(g=!0,d.point.graphic.show(),d.point.graphic.animate({x:m-(d.point.graphic.radius||0),y:f-(d.point.graphic.radius||0),opacity:.4},r,function(){C=!0,fadeInNewPointAndDestoryOld(c,l,r,.7)}),d.point.dataLabel&&-9999!==d.point.dataLabel.y&&c.point?.dataLabel?.alignAttr&&(d.point.dataLabel.show(),d.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y,opacity:.4},r))))}),syncTimeout(function(){C||fadeInNewPointAndDestoryOld(c,l,r,.85)},a),g||syncTimeout(function(){fadeInNewPointAndDestoryOld(c,l,r,.1)},a/2)))}function seriesDestroyClusteredData(){this.markerClusterSeriesData?.forEach(t=>{t?.destroy?.()}),this.markerClusterSeriesData=null}function seriesGeneratePoints(){const s=this,t=s["chart"],e=t.mapView,r=s.getColumn("x"),a=s.getColumn("y"),o=s.options.cluster,i=s.getRealExtremes(),n=[],l=[],u=[];let d,c,p,h,m,f,g,C,x,y,_,k,M,b,S,I;if(e&&s.is("mappoint")&&r&&a&&s.options.data?.forEach((t,e)=>{t=s.projectPoint(t);t&&(r[e]=t.x,a[e]=t.y)}),o?.enabled&&r?.length&&a?.length&&!t.polar){_=o.layoutAlgorithm.type,(S=o.layoutAlgorithm).processedGridSize=relativeLength(S.gridSize||clusterDefaults.layoutAlgorithm.gridSize,t.plotWidth),S.processedDistance=relativeLength(S.distance||clusterDefaults.layoutAlgorithm.distance,t.plotWidth),h=S.kmeansThreshold||clusterDefaults.layoutAlgorithm.kmeansThreshold;var P=S.processedGridSize/2,D=pixelsToValues(s,{x:0,y:0}),P=pixelsToValues(s,{x:P,y:P});m=Math.abs(D.x-P.x),f=Math.abs(D.y-P.y);for(let t=0;t<r.length;t++)s.dataMaxX||(defined(C)&&defined(g)&&defined(y)&&defined(x)?isNumber(a[t])&&isNumber(y)&&isNumber(x)&&(C=Math.max(r[t],C),g=Math.min(r[t],g),y=Math.max(a[t]||y,y),x=Math.min(a[t]||x,x)):(C=g=r[t],y=x=a[t])),r[t]>=i.minX-m&&r[t]<=i.maxX+m&&(a[t]||i.minY)>=i.minY-f&&(a[t]||i.maxY)<=i.maxY+f&&(n.push(r[t]),l.push(a[t]),u.push(t));defined(C)&&defined(g)&&isNumber(y)&&isNumber(x)&&(s.dataMaxX=C,s.dataMinX=g,s.dataMaxY=y,s.dataMinY=x),M=(b=(k=isFunction(_)?_:s.markerClusterAlgorithms?_&&s.markerClusterAlgorithms[_]?s.markerClusterAlgorithms[_]:n.length<h?s.markerClusterAlgorithms.kmeans:s.markerClusterAlgorithms.grid:()=>!1).call(this,n,l,u,S))&&s.getClusteredData(b,o),d=o.animation&&s.markerClusterInfo?.pointsState?.oldState?(destroyOldPoints(s.markerClusterInfo.pointsState.oldState),s.markerClusterInfo.pointsState.newState):{},c=r.length,p=s.markerClusterInfo,M&&(s.dataTable.modified=new Data_DataTableCore({columns:{x:M.groupedXData,y:M.groupedYData}}),s.hasGroupedData=!0,s.markerClusterInfo=M,s.groupMap=M.groupMap),baseGeneratePoints.apply(this),M&&s.markerClusterInfo&&(s.markerClusterInfo.clusters?.forEach(t=>{(I=s.points[t.index]).isCluster=!0,I.clusteredData=t.data,I.clusterPointsAmount=t.data.length,t.point=I,addEvent(I,"click",onPointDrillToCluster)}),s.markerClusterInfo.noise?.forEach(t=>{t.point=s.points[t.index]}),o.animation&&s.markerClusterInfo&&(s.markerClusterInfo.pointsState={oldState:d,newState:s.getPointsState(M,p,c)}),o.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else baseGeneratePoints.apply(this)}function seriesGetClusterDistancesFromPoint(e,s,r){const a=[];for(let t=0;t<e.length;t++){var o=valuesToPixels(this,{x:s,y:r}),i=valuesToPixels(this,{x:e[t].posX,y:e[t].posY}),o=Math.sqrt(Math.pow(o.x-i.x,2)+Math.pow(o.y-i.y,2));a.push({clusterIndex:t,distance:o})}return a.sort((t,e)=>t.distance-e.distance)}function seriesGetClusteredData(e,s){const t=this,r=t.options.data,a=[],o=[],i=[],n=[],l=[],u=Math.max(2,s.minimumClusterSize||2);let d=0,c,p,h,m,f,g,C,x,y,_,k,M;if(isFunction(s.layoutAlgorithm.type)&&!t.isValidGroupedDataObject(e))return error("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,t.chart),!1;for(const b in e)if(e[b].length>=u){if(h=e[b],c=getStateId(),f=h.length,s.zones)for(let t=0;t<s.zones.length;t++)f>=s.zones[t].from&&f<=s.zones[t].to&&((k=s.zones[t]).zoneIndex=t,_=s.zones[t].marker,M=s.zones[t].className);y=getClusterPosition(h),C="grid"!==s.layoutAlgorithm.type||s.allowOverlap?{x:y.x,y:y.y}:(g=t.options.marker||{},t.preventClusterCollisions({x:y.x,y:y.y,key:b,groupedData:e,gridSize:t.getScaledGridSize(s.layoutAlgorithm),defaultRadius:g.radius||3+(g.lineWidth||0),clusterRadius:_&&_.radius?_.radius:(s.marker||{}).radius||clusterDefaults.marker.radius}));for(let t=0;t<f;t++)h[t].parentStateId=c;if(i.push({x:C.x,y:C.y,id:b,stateId:c,index:d,data:h,clusterZone:k,clusterZoneClassName:M}),a.push(C.x),o.push(C.y),l.push({options:{formatPrefix:"cluster",dataLabels:s.dataLabels,marker:merge(s.marker,{states:s.states},_||{})}}),r?.length)for(let t=0;t<f;t++)isObject(r[h[t].dataIndex])&&(h[t].options=r[h[t].dataIndex]);d++,_=null}else for(let t=0;t<e[b].length;t++)p=e[b][t],c=getStateId(),x=null,m=r?.[p.dataIndex],a.push(p.x),o.push(p.y),p.parentStateId=c,n.push({x:p.x,y:p.y,id:b,stateId:c,index:d,data:e[b]}),x=m&&"object"==typeof m&&!isArray(m)?merge(m,{x:p.x,y:p.y}):{userOptions:m,x:p.x,y:p.y},l.push({options:x}),d++;return{clusters:i,noise:n,groupedXData:a,groupedYData:o,groupMap:l}}function seriesGetGridOffset(){const t=this,{chart:e,xAxis:s,yAxis:r}=t;let a=0,o=0;return a=s&&t.dataMinX&&t.dataMaxX?s.reversed?s.toPixels(t.dataMaxX):s.toPixels(t.dataMinX):e.plotLeft,o=r&&t.dataMinY&&t.dataMaxY?r.reversed?r.toPixels(t.dataMinY):r.toPixels(t.dataMaxY):e.plotTop,{plotLeft:a,plotTop:o}}function seriesGetPointsState(t,e,s){const r=e?getDataState(e,s):[],a=getDataState(t,s),o={};var i,n;oldPointsStateId=[],t.clusters.forEach(t=>{o[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(t=>{o[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<a.length;t++)i=a[t],n=r[t],i?.parentStateId&&n?.parentStateId&&-1===o[i.parentStateId]?.parentsId.indexOf(n.parentStateId)&&(o[i.parentStateId].parentsId.push(n.parentStateId),-1===oldPointsStateId.indexOf(n.parentStateId)&&oldPointsStateId.push(n.parentStateId));return o}function seriesGetRealExtremes(){var t=this.chart,e=t.mapView?0:t.plotLeft,s=pixelsToValues(this,{x:e,y:t.mapView?0:t.plotTop}),e=pixelsToValues(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=s.x,r=e.x,s=s.y,e=e.y;return{minX:Math.min(t,r),maxX:Math.max(t,r),minY:Math.min(s,e),maxY:Math.max(s,e)}}function seriesGetScaledGridSize(t){const e=this,s=e.xAxis,r=e.chart.mapView,a=t.processedGridSize||clusterDefaults.layoutAlgorithm.gridSize;let o=!0,i=1,n=1;e.gridValueSize||(r?e.gridValueSize=a/r.getScale():e.gridValueSize=Math.abs(s.toValue(a)-s.toValue(0)));for(var l=+(a/(r?e.gridValueSize*r.getScale():s.toPixels(e.gridValueSize)-s.toPixels(0))).toFixed(14);o&&1!=l;){var u=Math.pow(2,i);.75<l&&l<1.25?o=!1:1/u<=l&&l<1/u*2?(o=!1,n=u):l<=u&&u/2<l&&(o=!1,n=1/u),i++}return a/n/l}function seriesHideClusteredData(){const t=this.markerClusterSeriesData,e=this.markerClusterInfo?.pointsState?.oldState,s=oldPointsStateId.map(t=>e?.[t].point?.id||"");t?.forEach(t=>{t&&-1!==s.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t?.destroy?.()})}function seriesIsValidGroupedDataObject(t){let s=!1;return!!isObject(t)&&(MarkerClusterScatter_objectEach(t,e=>{if(s=!0,isArray(e)&&e.length){for(let t=0;t<e.length;t++)if(!isObject(e[t])||!e[t].x||!e[t].y)return void(s=!1)}else s=!1}),s)}function seriesPreventClusterCollisions(e){const t=this,[s,r]=e.key.split(":").map(parseFloat),a=e.gridSize,o=e.groupedData,i=e.defaultRadius,n=e.clusterRadius,l=r*a,u=s*a,d=valuesToPixels(t,e),c=[],p=t.options.cluster?.marker,h=t.options.cluster?.zones,m=t.getGridOffset();let f=d.x,g=d.y,C,x=0,y,_,k,M,b,S,I,P,D,A,v,w;f-=m.plotLeft,g-=m.plotTop;for(let t=1;t<5;t++)for(k=t%2?-1:1,M=t<3?-1:1,b=Math.floor((f+k*n)/a),w=[(S=Math.floor((g+M*n)/a))+":"+b,S+":"+r,s+":"+b],I=0;I<w.length;I++)-1===c.indexOf(w[I])&&w[I]!==e.key&&c.push(w[I]);for(const T of c)if(o[T]){o[T].posX||(A=getClusterPosition(o[T]),o[T].posX=A.x,o[T].posY=A.y);const O=valuesToPixels(t,{x:o[T].posX||0,y:o[T].posY||0});if(y=O.x-m.plotLeft,_=O.y-m.plotTop,[D,P]=T.split(":").map(parseFloat),h){C=o[T].length;for(let t=0;t<h.length;t++)C>=h[t].from&&C<=h[t].to&&(x=defined(h[t].marker?.radius)?h[t].marker.radius||0:(p?.radius?p:clusterDefaults.marker).radius)}1<o[T].length&&0===x&&p?.radius?x=p.radius:1===o[T].length&&(x=i),v=n+x,x=0,P!==r&&Math.abs(f-y)<v&&(f=P-r<0?l+n:l+a-n),D!==s&&Math.abs(g-_)<v&&(g=D-s<0?u+n:u+a-n)}const O=pixelsToValues(t,{x:f+m.plotLeft,y:g+m.plotTop});return o[e.key].posX=O.x,o[e.key].posY=O.y,O}function valuesToPixels(t,e){const{chart:s,xAxis:r,yAxis:a}=t;return s.mapView?s.mapView.projectedUnitsToPixels(e):{x:r?r.toPixels(e.x):0,y:a?a.toPixels(e.y):0}}const MarkerClusterScatter={compose:compose},MarkerClusters_MarkerClusterScatter=MarkerClusterScatter,MarkerClusters_animObject=external_highcharts_src_js_default_default()["animObject"],defaultOptions=external_highcharts_src_js_default_default()["defaultOptions"],composed=external_highcharts_src_js_default_default()["composed"],{addEvent:MarkerClusters_addEvent,defined:MarkerClusters_defined,error:MarkerClusters_error,isFunction:MarkerClusters_isFunction,merge:MarkerClusters_merge,pushUnique,syncTimeout:MarkerClusters_syncTimeout}=external_highcharts_src_js_default_default();function MarkerClusters_compose(t,e,s,r){var a,o;pushUnique(composed,"MarkerClusters")&&(a=r.prototype.pointClass,o=r.types["scatter"],MarkerClusters_addEvent(t,"setExtremes",onAxisSetExtremes),MarkerClusters_addEvent(e,"render",onChartRender),MarkerClusters_addEvent(a,"drillToCluster",MarkerClusters_onPointDrillToCluster),MarkerClusters_addEvent(a,"update",onPointUpdate),MarkerClusters_addEvent(r,"afterRender",onSeriesAfterRender),o&&MarkerClusters_MarkerClusterScatter.compose(s,o))}function onAxisSetExtremes(){const t=this.chart;let e=0;for(const s of t.series)s.markerClusterInfo&&(e=MarkerClusters_animObject((s.options.cluster||{}).animation).duration||0);MarkerClusters_syncTimeout(()=>{t.tooltip&&t.tooltip.destroy()},e)}function onChartRender(){for(const s of this.series||[])if(s.markerClusterInfo){var t=s.options.cluster,e=((s.markerClusterInfo||{}).pointsState||{}).oldState;if((t||{}).animation&&s.markerClusterInfo&&0===(s.chart.pointer?.pinchDown||[]).length&&"pan"!==((s.xAxis||{}).eventArgs||{}).trigger&&e&&Object.keys(e).length){for(const r of s.markerClusterInfo.clusters)s.animateClusterPoint(r);for(const a of s.markerClusterInfo.noise)s.animateClusterPoint(a)}}}function MarkerClusters_onPointDrillToCluster(t){const e=t.point||t.target,s=e.series,r=s.options.cluster,a=((r||{}).events||{}).drillToCluster;MarkerClusters_isFunction(a)&&a.call(this,t)}function onPointUpdate(){if(this.dataGroup)return MarkerClusters_error("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function onSeriesAfterRender(){var t=(this.options.cluster||{}).drillToCluster;if(this.markerClusterInfo&&this.markerClusterInfo.clusters)for(const e of this.markerClusterInfo.clusters)e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),MarkerClusters_defined(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))}(defaultOptions.plotOptions||{}).series=MarkerClusters_merge((defaultOptions.plotOptions||{}).series,MarkerClusters_MarkerClusterDefaults);const MarkerClusters={compose:MarkerClusters_compose},MarkerClusters_MarkerClusters=MarkerClusters;let symbols;function MarkerClusterSymbols_cluster(t,e,s,r){const a=s/2,o=r/2,i=symbols.arc(t+a,e+o,a-4,o-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),n=symbols.arc(t+a,e+o,a-3,o-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a-2,open:!1}),l=symbols.arc(t+a,e+o,a-1,o-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a,open:!1});return l.concat(n,i)}function MarkerClusterSymbols_compose(t){(symbols=t.prototype.symbols).cluster=MarkerClusterSymbols_cluster}const MarkerClusterSymbols={compose:MarkerClusterSymbols_compose},MarkerClusters_MarkerClusterSymbols=MarkerClusterSymbols,G=external_highcharts_src_js_default_default(),marker_clusters_src=(MarkerClusters_MarkerClusters.compose(G.Axis,G.Chart,G.defaultOptions,G.Series),MarkerClusters_MarkerClusterSymbols.compose(G.SVGRenderer),external_highcharts_src_js_default_default());export{marker_clusters_src as default};