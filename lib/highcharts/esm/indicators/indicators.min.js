import*as t from"../highcharts.js";import"../modules/stock.js";var e,a={n:t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return a.d(e,{a:e}),e},d:(t,e)=>{for(var i in e)a.o(e,i)&&!a.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};let i=t.default;var s=a.n(i);let n=t.default.Chart;var r=a.n(n);let o=t.default.SeriesRegistry;var l=a.n(o);let p=l().seriesTypes["line"],{addEvent:h,fireEvent:u,error:d,extend:c,isArray:f,merge:m,pick:y}=s(),x=(e,a)=>{let t=[],i=e.pointArrayMap,s=a&&e.dataTable.modified||e.dataTable;if(!i)return e.getColumn("y",a);let n=i.map(t=>e.getColumn(t,a));for(let a=0;a<s.rowCount;a++){var r=i.map((t,e)=>n[e]?.[a]||0);t.push(r)}return t};class g extends p{destroy(){this.dataEventsToUnbind.forEach(function(t){t()}),super.destroy.apply(this,arguments)}getName(){let a=[],t=this.name;return t||((this.nameComponents||[]).forEach(function(t,e){a.push(this.options.params[t]+y(this.nameSuffixes[e],""))},this),t=(this.nameBase||this.type.toUpperCase())+(this.nameComponents?" ("+a.join(", ")+")":"")),t}getValues(t,e){let a=e.period,i=t.xData||[],s=t.yData,n=s.length,r=[],o=[],l=[],p,h=-1,d=0,u,c=0;if(!(i.length<a)){for(f(s[0])&&(h=e.index||0);d<a-1;)c+=h<0?s[d]:s[d][h],d++;for(p=d;p<n;p++)c+=h<0?s[p]:s[p][h],u=[i[p],c/a],r.push(u),o.push(u[0]),l.push(u[1]),c-=h<0?s[p-d]:s[p-d][h];return{values:r,xData:o,yData:l}}}init(e,t){let a=this;super.init.call(a,e,t);t=h(r(),"afterLinkSeries",function({isUpdating:t}){if(!t){t=!!a.dataEventsToUnbind.length;if(!a.linkedParent)return d("Series "+a.options.linkedTo+" not found! Check `linkedTo`.",!1,e);if(t||(a.dataEventsToUnbind.push(h(a.linkedParent,"updatedData",function(){a.recalculateValues()})),a.calculateOn.xAxis&&a.dataEventsToUnbind.push(h(a.linkedParent.xAxis,a.calculateOn.xAxis,function(){a.recalculateValues()}))),"init"===a.calculateOn.chart)a.closestPointRange||a.recalculateValues();else if(!t){let t=h(a.chart,a.calculateOn.chart,function(){a.recalculateValues(),t()})}}},{order:0});a.dataEventsToUnbind=[],a.eventsToUnbind.push(t)}recalculateValues(){let i=[],e=this.dataTable,s=this.points||[],t=this.dataTable.rowCount,a=!0,n,r,o,l,p=this.linkedParent.yData,h=this.linkedParent.processedYData,d=(this.linkedParent.xData=this.linkedParent.getColumn("x"),this.linkedParent.yData=x(this.linkedParent),this.linkedParent.processedYData=x(this.linkedParent,!0),this.linkedParent.options&&this.linkedParent.dataTable.rowCount&&this.getValues(this.linkedParent,this.options.params)||{values:[],xData:[],yData:[]}),c=(delete this.linkedParent.xData,this.linkedParent.yData=p,this.linkedParent.processedYData=h,this.pointArrayMap||["y"]),m={};if(d.yData.forEach(i=>{c.forEach((t,e)=>{let a=m[t]||[];a.push(f(i)?i[e]:i),m[t]||(m[t]=a)})}),t&&!this.hasGroupedData&&this.visible&&this.points)if(this.cropped){this.xAxis&&(o=this.xAxis.min,l=this.xAxis.max);let t=this.cropData(e,o,l),a=["x",...this.pointArrayMap||["y"]];for(let e=0;e<(t.modified?.rowCount||0);e++){var y=a.map(t=>this.getColumn(t)[e]||0);i.push(y)}var g=this.getColumn("x");n=d.xData.indexOf(g[0]),r=d.xData.indexOf(g[g.length-1]),-1===n&&r===d.xData.length-2&&i[0][0]===s[0].x&&i.shift(),this.updateData(i)}else(this.updateAllPoints||d.xData.length!==t-1&&d.xData.length!==t+1)&&(a=!1,this.updateData(d.values));a&&(e.setColumns({...m,x:d.xData}),this.options.data=d.values),this.calculateOn.xAxis&&this.getColumn("x",!0).length&&(this.isDirty=!0,this.redraw()),this.isDirtyData=!!this.linkedSeries.length,u(this,"updatedData")}processData(){var t=this.options.compareToMain,e=this.linkedParent;super.processData.apply(this,arguments),this.dataModify&&e&&e.dataModify&&e.dataModify.compareValue&&t&&(this.dataModify.compareValue=e.dataModify.compareValue)}}g.defaultOptions=m(p.defaultOptions,{name:void 0,tooltip:{valueDecimals:4},linkedTo:void 0,compareToMain:!1,params:{index:3,period:14}}),c(g.prototype,{calculateOn:{chart:"init"},hasDerivedData:!0,nameComponents:["period"],nameSuffixes:[],useCommonDataGrouping:!0}),l().registerSeriesType("sma",g);let D=l().seriesTypes["sma"],{correctFloat:P,isArray:k,merge:v}=s();class A extends D{accumulatePeriodPoints(t,e,a){let i=0,s=0;for(;s<t;)i+=e<0?a[s]:a[s][e],s++;return i}calculateEma(t,e,a,i,s,n,r){t=t[a-1],e=n<0?e[a-1]:e[a-1][n];return[t,void 0===s?r:P(e*i+s*(1-i))]}getValues(t,e){let a=e.period,i=t.xData,s=t.yData,n=s?s.length:0,r=2/(a+1),o=[],l=[],p=[],h,d,u,c=-1,f;if(!(n<a)){for(k(s[0])&&(c=e.index||0),f=this.accumulatePeriodPoints(a,c,s)/a,u=a;u<n+1;u++)d=this.calculateEma(i,s,u,r,h,c,f),o.push(d),l.push(d[0]),p.push(d[1]),h=d[1];return{values:o,xData:l,yData:p}}}}A.defaultOptions=v(D.defaultOptions,{params:{index:3,period:9}}),l().registerSeriesType("ema",A);let{prototype:C}=l().seriesTypes["sma"],{defined:T,error:M,merge:O}=s(),E=(!function(t){let a=["bottomLine"],i=["top","bottom"],s=["top"];function m(t){return"plot"+t.charAt(0).toUpperCase()+t.slice(1)}function y(t,e){let a=[];return(t.pointArrayMap||[]).forEach(t=>{t!==e&&a.push(m(t))}),a}function n(){let a=this,t=a.pointValKey,e=a.linesApiNames,i=a.areaLinesNames,s=a.points,n=a.options,r=a.graph,o={options:{gapSize:n.gapSize}},l=[],p=y(a,t),h=s.length,d;var u,c,f;p.forEach((t,e)=>{for(l[e]=[];h--;)d=s[h],l[e].push({x:d.x,plotX:d.plotX,plotY:d[t],isNull:!T(d[t])});h=s.length}),a.userOptions.fillColor&&i.length&&(u=l[p.indexOf(m(i[0]))],c=1===i.length?s:l[p.indexOf(m(i[1]))],f=a.color,a.points=c,a.nextPoints=u,a.color=a.userOptions.fillColor,a.options=O(s,o),a.graph=a.area,a.fillGraph=!0,C.drawGraph.call(a),a.area=a.graph,delete a.nextPoints,delete a.fillGraph,a.color=f),e.forEach((t,e)=>{l[e]?(a.points=l[e],n[t]?a.options=O(n[t].styles,o):M('Error: "There is no '+t+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),a.graph=a["graph"+t],C.drawGraph.call(a),a["graph"+t]=a.graph):M('Error: "'+t+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),a.points=s,a.options=n,a.graph=r,C.drawGraph.call(a)}function r(t){let e,a=[],i;if(t=t||this.points,this.fillGraph&&this.nextPoints){if((e=C.getGraphPath.call(this,this.nextPoints))&&e.length){e[0][0]="L",a=C.getGraphPath.call(this,t);for(let t=(i=e.slice(0,a.length)).length-1;0<=t;t--)a.push(i[t])}}else a=C.getGraphPath.apply(this,arguments);return a}function o(e){let a=[];return(this.pointArrayMap||[]).forEach(t=>{a.push(e[t])}),a}function l(){let t=this.pointArrayMap,i,s;i=y(this),C.translate.apply(this,arguments),this.points.forEach(a=>{t.forEach((t,e)=>{s=a[t],null!==(s=this.dataModify?this.dataModify.modifyValue(s):s)&&(a[i[e]]=this.yAxis.toPixels(s,!0))})})}t.compose=function(t){let e=t.prototype;return e.linesApiNames=e.linesApiNames||a.slice(),e.pointArrayMap=e.pointArrayMap||i.slice(),e.pointValKey=e.pointValKey||"top",e.areaLinesNames=e.areaLinesNames||s.slice(),e.drawGraph=n,e.getGraphPath=r,e.toYData=o,e.translate=l,t}}(e=e||{}),e),b=(a.d({},{}),s()),V=(b.MultipleLinesComposition=b.MultipleLinesComposition||E,s());export{V as default};