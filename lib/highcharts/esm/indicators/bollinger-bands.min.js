import*as t from"../highcharts.js";import"../modules/stock.js";var e,o={n:t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return o.d(e,{a:e}),e},d:(t,e)=>{for(var a in e)o.o(e,a)&&!o.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:e[a]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};let i=t.default;var a=o.n(i);o.d({},{});let r=t.default.SeriesRegistry;var s=o.n(r);let{prototype:n}=s().seriesTypes["sma"],{defined:l,error:p,merge:h}=a(),d=(!function(t){let o=["bottomLine"],a=["top","bottom"],i=["top"];function x(t){return"plot"+t.charAt(0).toUpperCase()+t.slice(1)}function v(t,e){let o=[];return(t.pointArrayMap||[]).forEach(t=>{t!==e&&o.push(x(t))}),o}function r(){let o=this,t=o.pointValKey,e=o.linesApiNames,a=o.areaLinesNames,i=o.points,r=o.options,s=o.graph,d={options:{gapSize:r.gapSize}},c=[],y=v(o,t),f=i.length,m;var u,g,b;y.forEach((t,e)=>{for(c[e]=[];f--;)m=i[f],c[e].push({x:m.x,plotX:m.plotX,plotY:m[t],isNull:!l(m[t])});f=i.length}),o.userOptions.fillColor&&a.length&&(u=c[y.indexOf(x(a[0]))],g=1===a.length?i:c[y.indexOf(x(a[1]))],b=o.color,o.points=g,o.nextPoints=u,o.color=o.userOptions.fillColor,o.options=h(i,d),o.graph=o.area,o.fillGraph=!0,n.drawGraph.call(o),o.area=o.graph,delete o.nextPoints,delete o.fillGraph,o.color=b),e.forEach((t,e)=>{c[e]?(o.points=c[e],r[t]?o.options=h(r[t].styles,d):p('Error: "There is no '+t+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),o.graph=o["graph"+t],n.drawGraph.call(o),o["graph"+t]=o.graph):p('Error: "'+t+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),o.points=i,o.options=r,o.graph=s,n.drawGraph.call(o)}function s(t){let e,o=[],a;if(t=t||this.points,this.fillGraph&&this.nextPoints){if((e=n.getGraphPath.call(this,this.nextPoints))&&e.length){e[0][0]="L",o=n.getGraphPath.call(this,t);for(let t=(a=e.slice(0,o.length)).length-1;0<=t;t--)o.push(a[t])}}else o=n.getGraphPath.apply(this,arguments);return o}function d(e){let o=[];return(this.pointArrayMap||[]).forEach(t=>{o.push(e[t])}),o}function c(){let t=this.pointArrayMap,a,i;a=v(this),n.translate.apply(this,arguments),this.points.forEach(o=>{t.forEach((t,e)=>{i=o[t],null!==(i=this.dataModify?this.dataModify.modifyValue(i):i)&&(o[a[e]]=this.yAxis.toPixels(i,!0))})})}t.compose=function(t){let e=t.prototype;return e.linesApiNames=e.linesApiNames||o.slice(),e.pointArrayMap=e.pointArrayMap||a.slice(),e.pointValKey=e.pointValKey||"top",e.areaLinesNames=e.areaLinesNames||i.slice(),e.drawGraph=r,e.getGraphPath=s,e.toYData=d,e.translate=c,t}}(e=e||{}),e),c=s().seriesTypes["sma"],{extend:m,isArray:u,merge:y}=a();class f extends c{init(){s().seriesTypes.sma.prototype.init.apply(this,arguments),this.options=y({topLine:{styles:{lineColor:this.color}},bottomLine:{styles:{lineColor:this.color}}},this.options)}getValues(t,e){let o,a,i,r,n,p,l,h,d,c=e.period,y=e.standardDeviation,f=[],m=[],g=t.xData,b=t.yData,x=b?b.length:0,v=[];if(!(g.length<c)){var A=u(b[0]);for(d=c;d<=x;d++)n=g.slice(d-c,d),p=b.slice(d-c,d),r=(h=s().seriesTypes.sma.prototype.getValues.call(this,{xData:n,yData:p},e)).xData[0],a=(o=h.yData[0])+y*(l=function(t,e,o,a){let i=t.length,r=0,s,n=0;for(;r<i;r++)n+=(s=(o?t[r][e]:t[r])-a)*s;return Math.sqrt(n/=i-1)}(p,e.index,A,o)),i=o-y*l,v.push([r,a,o,i]),f.push(r),m.push([a,o,i]);return{values:v,xData:f,yData:m}}}}f.defaultOptions=y(c.defaultOptions,{params:{period:20,standardDeviation:2,index:3},bottomLine:{styles:{lineWidth:1,lineColor:void 0}},topLine:{styles:{lineWidth:1,lineColor:void 0}},tooltip:{pointFormat:'<span style="color:{point.color}">‚óè</span><b> {series.name}</b><br/>Top: {point.top}<br/>Middle: {point.middle}<br/>Bottom: {point.bottom}<br/>'},marker:{enabled:!1},dataGrouping:{approximation:"averages"}}),m(f.prototype,{areaLinesNames:["top","bottom"],linesApiNames:["topLine","bottomLine"],nameComponents:["period","standardDeviation"],pointArrayMap:["top","middle","bottom"],pointValKey:"middle"}),d.compose(f),s().registerSeriesType("bb",f);let g=a();export{g as default};