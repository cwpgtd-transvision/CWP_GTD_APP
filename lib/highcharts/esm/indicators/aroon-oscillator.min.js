import*as t from"../highcharts.js";import"../modules/stock.js";var e,a={n:t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return a.d(e,{a:e}),e},d:(t,e)=>{for(var o in e)a.o(e,o)&&!a.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};let o=t.default;var r=a.n(o);a.d({},{});let i=t.default.SeriesRegistry;var s=a.n(i);let{prototype:l}=s().seriesTypes["sma"],{defined:n,error:p,merge:h}=r(),c=(!function(t){let a=["bottomLine"],o=["top","bottom"],r=["top"];function x(t){return"plot"+t.charAt(0).toUpperCase()+t.slice(1)}function O(t,e){let a=[];return(t.pointArrayMap||[]).forEach(t=>{t!==e&&a.push(x(t))}),a}function i(){let a=this,t=a.pointValKey,e=a.linesApiNames,o=a.areaLinesNames,r=a.points,i=a.options,s=a.graph,c={options:{gapSize:i.gapSize}},u=[],f=O(a,t),y=r.length,d;var g,m,A;f.forEach((t,e)=>{for(u[e]=[];y--;)d=r[y],u[e].push({x:d.x,plotX:d.plotX,plotY:d[t],isNull:!n(d[t])});y=r.length}),a.userOptions.fillColor&&o.length&&(g=u[f.indexOf(x(o[0]))],m=1===o.length?r:u[f.indexOf(x(o[1]))],A=a.color,a.points=m,a.nextPoints=g,a.color=a.userOptions.fillColor,a.options=h(r,c),a.graph=a.area,a.fillGraph=!0,l.drawGraph.call(a),a.area=a.graph,delete a.nextPoints,delete a.fillGraph,a.color=A),e.forEach((t,e)=>{u[e]?(a.points=u[e],i[t]?a.options=h(i[t].styles,c):p('Error: "There is no '+t+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),a.graph=a["graph"+t],l.drawGraph.call(a),a["graph"+t]=a.graph):p('Error: "'+t+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),a.points=r,a.options=i,a.graph=s,l.drawGraph.call(a)}function s(t){let e,a=[],o;if(t=t||this.points,this.fillGraph&&this.nextPoints){if((e=l.getGraphPath.call(this,this.nextPoints))&&e.length){e[0][0]="L",a=l.getGraphPath.call(this,t);for(let t=(o=e.slice(0,a.length)).length-1;0<=t;t--)a.push(o[t])}}else a=l.getGraphPath.apply(this,arguments);return a}function c(e){let a=[];return(this.pointArrayMap||[]).forEach(t=>{a.push(e[t])}),a}function u(){let t=this.pointArrayMap,o,r;o=O(this),l.translate.apply(this,arguments),this.points.forEach(a=>{t.forEach((t,e)=>{r=a[t],null!==(r=this.dataModify?this.dataModify.modifyValue(r):r)&&(a[o[e]]=this.yAxis.toPixels(r,!0))})})}t.compose=function(t){let e=t.prototype;return e.linesApiNames=e.linesApiNames||a.slice(),e.pointArrayMap=e.pointArrayMap||o.slice(),e.pointValKey=e.pointValKey||"top",e.areaLinesNames=e.areaLinesNames||r.slice(),e.drawGraph=i,e.getGraphPath=s,e.toYData=c,e.translate=u,t}}(e=e||{}),e),u=s().seriesTypes["aroon"],{extend:f,merge:y}=r();class d extends u{getValues(t,e){let a,o,r=[],i=[],s=[],l=super.getValues.call(this,t,e);for(o=0;o<l.yData.length;o++)a=l.yData[o][0]-l.yData[o][1],r.push([l.xData[o],a]),i.push(l.xData[o]),s.push(a);return{values:r,xData:i,yData:s}}}d.defaultOptions=y(u.defaultOptions,{tooltip:{pointFormat:'<span style="color:{point.color}">‚óè</span><b> {series.name}</b>: {point.y}'}}),f(d.prototype,{nameBase:"Aroon Oscillator",linesApiNames:[],pointArrayMap:["y"],pointValKey:"y"}),c.compose(u),s().registerSeriesType("aroonoscillator",d);let g=r();export{g as default};