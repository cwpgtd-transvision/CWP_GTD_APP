import*as e from"../highcharts.js";import"../modules/stock.js";var t,a={n:e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return a.d(t,{a:t}),t},d:(e,t)=>{for(var i in t)a.o(t,i)&&!a.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};let i=e.default;var o=a.n(i);a.d({},{});let s=e.default.SeriesRegistry;var r=a.n(s);let{prototype:n}=r().seriesTypes["sma"],{defined:l,error:p,merge:h}=o(),c=(!function(e){let a=["bottomLine"],i=["top","bottom"],o=["top"];function A(e){return"plot"+e.charAt(0).toUpperCase()+e.slice(1)}function D(e,t){let a=[];return(e.pointArrayMap||[]).forEach(e=>{e!==t&&a.push(A(e))}),a}function r(){let a=this,e=a.pointValKey,t=a.linesApiNames,i=a.areaLinesNames,o=a.points,r=a.options,s=a.graph,c={options:{gapSize:r.gapSize}},d=[],u=D(a,e),f=o.length,m;var y,g,x;u.forEach((e,t)=>{for(d[t]=[];f--;)m=o[f],d[t].push({x:m.x,plotX:m.plotX,plotY:m[e],isNull:!l(m[e])});f=o.length}),a.userOptions.fillColor&&i.length&&(y=d[u.indexOf(A(i[0]))],g=1===i.length?o:d[u.indexOf(A(i[1]))],x=a.color,a.points=g,a.nextPoints=y,a.color=a.userOptions.fillColor,a.options=h(o,c),a.graph=a.area,a.fillGraph=!0,n.drawGraph.call(a),a.area=a.graph,delete a.nextPoints,delete a.fillGraph,a.color=x),t.forEach((e,t)=>{d[t]?(a.points=d[t],r[e]?a.options=h(r[e].styles,c):p('Error: "There is no '+e+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),a.graph=a["graph"+e],n.drawGraph.call(a),a["graph"+e]=a.graph):p('Error: "'+e+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),a.points=o,a.options=r,a.graph=s,n.drawGraph.call(a)}function s(e){let t,a=[],i;if(e=e||this.points,this.fillGraph&&this.nextPoints){if((t=n.getGraphPath.call(this,this.nextPoints))&&t.length){t[0][0]="L",a=n.getGraphPath.call(this,e);for(let e=(i=t.slice(0,a.length)).length-1;0<=e;e--)a.push(i[e])}}else a=n.getGraphPath.apply(this,arguments);return a}function c(t){let a=[];return(this.pointArrayMap||[]).forEach(e=>{a.push(t[e])}),a}function d(){let e=this.pointArrayMap,i,o;i=D(this),n.translate.apply(this,arguments),this.points.forEach(a=>{e.forEach((e,t)=>{o=a[e],null!==(o=this.dataModify?this.dataModify.modifyValue(o):o)&&(a[i[t]]=this.yAxis.toPixels(o,!0))})})}e.compose=function(e){let t=e.prototype;return t.linesApiNames=t.linesApiNames||a.slice(),t.pointArrayMap=t.pointArrayMap||i.slice(),t.pointValKey=t.pointValKey||"top",t.areaLinesNames=t.areaLinesNames||o.slice(),t.drawGraph=r,t.getGraphPath=s,t.toYData=c,t.translate=d,e}}(t=t||{}),t),d=r().seriesTypes["sma"],{correctFloat:u,extend:f,merge:y}=o();class m extends d{getValues(e,t){let a,i,o,r,s,n,p,l,h,c,d,f=t.period,m=t.factor,y=t.index,g=e.xData,x=e.yData,A=x?x.length:0,D=[],v=[],G=[],M=[],N=[];if(!(A<f)){for(d=0;d<=A;d++){var O,P;d<A&&(O=x[d][2],P=x[d][1],s=u(P-O)/(u(P+O)/2)*1e3*m,D.push(x[d][1]*u(1+2*s)),v.push(x[d][2]*u(1-2*s))),d>=f&&(h=g.slice(d-f,d),c=x.slice(d-f,d),p=super.getValues.call(this,{xData:h,yData:D.slice(d-f,d)},{period:f}),l=super.getValues.call(this,{xData:h,yData:v.slice(d-f,d)},{period:f}),r=(n=super.getValues.call(this,{xData:h,yData:c},{period:f,index:y})).xData[0],i=p.yData[0],o=l.yData[0],a=n.yData[0],G.push([r,i,a,o]),M.push(r),N.push([i,a,o]))}return{values:G,xData:M,yData:N}}}}m.defaultOptions=y(d.defaultOptions,{params:{period:20,factor:.001,index:3},lineWidth:1,topLine:{styles:{lineWidth:1}},bottomLine:{styles:{lineWidth:1}},dataGrouping:{approximation:"averages"}}),f(m.prototype,{areaLinesNames:["top","bottom"],linesApiNames:["topLine","bottomLine"],nameBase:"Acceleration Bands",nameComponents:["period","factor"],pointArrayMap:["top","middle","bottom"],pointValKey:"middle"}),c.compose(m),r().registerSeriesType("abands",m);let g=o();export{g as default};